<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Twitch Giveaways</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@500;600;700&display=swap" rel="stylesheet">
    <style>
        .language-btn {
    flex-shrink: 0 !important;
    height: 44px !important;
    display: flex !important;
    align-items: center !important;
    gap: 1rem !important;
}

.language-btn svg {
    flex-shrink: 0 !important;
    width: 20px !important;
    height: 16px !important;
}

.language-btn span {
    flex-shrink: 0 !important;
    font-size: 15px !important;
    font-weight: 500 !important;
    text-align: left !important;
}

.language-btn:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
}

.language-btn:active {
    transform: translateY(0) !important;
}
        /* Language buttons - статичный размер */
.language-flag {
    flex-shrink: 0 !important;
    width: 90px !important;
    height: 44px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    gap: 0.5rem !important;
}

.language-flag svg {
    flex-shrink: 0 !important;
    width: 20px !important;
    height: 16px !important;
}

.language-flag span {
    flex-shrink: 0 !important;
    font-size: 14px !important;
    font-weight: 500 !important;
}

.language-flag:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3) !important;
    border-color: #7c3aed !important;
}

.language-flag:active {
    transform: translateY(0) !important;
}
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        
        @keyframes animate-gradient {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .animate-gradient {
            animation: animate-gradient 3s ease infinite;
        }
        
        .twitch-gradient {
            background: linear-gradient(135deg, #9146FF 0%, #9B59B6 30%, #E91E63 60%, #F368E0 100%);
            background-size: 300% 300%;
            animation: rainbow 8s ease infinite;
        }
        
        .neon-border {
            box-shadow: 0 0 20px rgba(145, 70, 255, 0.4), 0 0 40px rgba(145, 70, 255, 0.2), 
                        inset 0 0 20px rgba(145, 70, 255, 0.1);
            border: 1px solid rgba(145, 70, 255, 0.3);
            backdrop-filter: blur(10px);
            background: rgba(31, 41, 55, 0.7);
        }
        
        .neon-text {
            text-shadow: 0 0 10px rgba(145, 70, 255, 0.8), 0 0 20px rgba(145, 70, 255, 0.6),
                         0 0 30px rgba(145, 70, 255, 0.4);
        }
        
        /* Glassmorphism effect */
        .glass-card {
            background: rgba(31, 41, 55, 0.6);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .glass-card:hover {
            background: rgba(31, 41, 55, 0.8);
            border-color: rgba(145, 70, 255, 0.5);
            box-shadow: 0 12px 40px rgba(145, 70, 255, 0.2);
            transform: translateY(-2px);
            transition: all 0.3s ease;
        }
        
        /* Modern gradient buttons */
        .gradient-btn {
            background: linear-gradient(135deg, #9146FF 0%, #E91E63 50%, #F368E0 100%);
            background-size: 200% 200%;
            animation: gradientShift 3s ease infinite;
            position: relative;
            overflow: hidden;
        }
        
        .gradient-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .gradient-btn:hover::before {
            left: 100%;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .celebrate-animation {
            animation: pulse 1s infinite, rainbow 5s linear infinite;
        }
        
        .chat-message {
            transition: all 0.3s ease;
            border-left: 3px solid transparent;
            padding-left: 0.5rem;
        }
        
        .chat-message:hover {
            transform: translateX(5px);
            border-left-color: rgba(145, 70, 255, 0.6);
            background: rgba(145, 70, 255, 0.05);
            border-radius: 0.5rem;
        }
        
        /* Moderation buttons styling */
        .mod-action {
            font-size: 14px;
            transition: all 0.2s ease;
            border-radius: 6px;
            padding: 4px 6px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid transparent;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            height: 28px;
            flex-shrink: 0;
        }
        
        .mod-action::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .mod-action:hover::before {
            left: 100%;
        }
        
        .mod-action:hover {
            transform: scale(1.08) translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .mod-action:active {
            transform: scale(0.96);
        }
        
        /* Specific button styles */
        .mod-warn {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2) 0%, rgba(217, 119, 6, 0.2) 100%);
            border-color: rgba(245, 158, 11, 0.3);
            color: #FCD34D;
        }
        
        .mod-warn:hover {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.3) 0%, rgba(217, 119, 6, 0.3) 100%);
            border-color: rgba(245, 158, 11, 0.5);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }
        
        .mod-timeout {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.2) 0%, rgba(234, 88, 12, 0.2) 100%);
            border-color: rgba(251, 146, 60, 0.3);
            color: #FED7AA;
        }
        
        .mod-timeout:hover {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.3) 0%, rgba(234, 88, 12, 0.3) 100%);
            border-color: rgba(251, 146, 60, 0.5);
            box-shadow: 0 8px 25px rgba(251, 146, 60, 0.4);
        }
        
        .mod-ban {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(220, 38, 38, 0.2) 100%);
            border-color: rgba(239, 68, 68, 0.3);
            color: #FCA5A5;
        }
        
        .mod-ban:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(220, 38, 38, 0.3) 100%);
            border-color: rgba(239, 68, 68, 0.5);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }
        
        .winner-action-btn {
            position: relative;
            overflow: hidden;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.3s ease, filter 0.3s ease;
            box-shadow: 0 12px 30px rgba(18, 16, 56, 0.45);
            backdrop-filter: blur(6px);
        }
        
        .winner-action-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05));
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .winner-action-btn:hover {
            transform: translateY(-2px) scale(1.02);
            filter: brightness(1.05);
        }
        
        .winner-action-btn:hover::before {
            opacity: 1;
        }
        
        .winner-action-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        .winner-action-follow {
            background: linear-gradient(135deg, #7C3AED 0%, #C084FC 40%, #F472B6 100%);
            color: #fff;
        }
        
        .winner-action-messages {
            background: linear-gradient(135deg, rgba(55, 65, 81, 0.9) 0%, rgba(75, 85, 99, 0.95) 100%);
            color: #E5E7EB;
            border: 1px solid rgba(148, 163, 184, 0.35);
        }
        
        .winner-action-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Moderation status badges styling */
        .mod-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border: 1px solid;
            position: relative;
            backdrop-filter: blur(5px);
            animation: modBadgeGlow 2s ease-in-out infinite alternate;
        }
        
        .mod-badge-warned {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.8) 0%, rgba(217, 119, 6, 0.9) 100%);
            border-color: rgba(245, 158, 11, 0.6);
            color: #FFFBEB;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            box-shadow: 
                0 2px 8px rgba(245, 158, 11, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .mod-badge-timeout {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.8) 0%, rgba(234, 88, 12, 0.9) 100%);
            border-color: rgba(251, 146, 60, 0.6);
            color: #FFF7ED;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            box-shadow: 
                0 2px 8px rgba(251, 146, 60, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        .mod-badge-banned {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.8) 0%, rgba(220, 38, 38, 0.9) 100%);
            border-color: rgba(239, 68, 68, 0.6);
            color: #FEF2F2;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
            box-shadow: 
                0 2px 8px rgba(239, 68, 68, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        @keyframes modBadgeGlow {
            0% {
                box-shadow: 
                    0 2px 8px rgba(var(--glow-color), 0.4),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
            }
            100% {
                box-shadow: 
                    0 4px 16px rgba(var(--glow-color), 0.6),
                    0 0 0 1px rgba(var(--glow-color), 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.3);
            }
        }
        
        .mod-badge-warned {
            --glow-color: 245, 158, 11;
        }
        
        .mod-badge-timeout {
            --glow-color: 251, 146, 60;
        }
        
        .mod-badge-banned {
            --glow-color: 239, 68, 68;
        }
        
        /* Disconnect button styling */
        #disconnectBtn {
            border-radius: 8px;
        }
        
        #disconnectBtn:hover {
            background: rgba(239, 68, 68, 0.1);
        }
        
        /* Clear winners button styling */
        #clearWinnersBtn {
            position: relative;
            overflow: hidden;
        }
        
        #clearWinnersBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(239, 68, 68, 0.3), transparent);
            transition: left 0.5s;
        }
        
        #clearWinnersBtn:hover::before {
            left: 100%;
        }
        
        #clearWinnersBtn:active {
            transform: scale(0.95);
        }
        
        /* Confirmation modal styling */
        .confirm-modal {
            backdrop-filter: blur(10px);
            animation: modalFadeIn 0.3s ease-out;
        }
        
        @keyframes modalFadeIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        .confirm-modal-content {
            animation: modalSlideUp 0.3s ease-out;
        }
        
        @keyframes modalSlideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes modalFadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.9);
            }
        }
        
        .sidebar {
            transition: transform 0.3s ease;
        }
        
        .floating-btn {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            z-index: 50;
            transition: all 0.3s ease;
        }
        
        .floating-btn:hover {
            transform: translateY(-5px) scale(1.05);
        }
        
        .slide-in {
            animation: slideIn 0.5s forwards;
        }
        
        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .success-message {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.2);
        }
        
        .error-message {
            background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
            border: 1px solid rgba(239, 68, 68, 0.3);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.2);
        }
        
        /* Custom scrollbar for chat */
        #chatContainer::-webkit-scrollbar {
            width: 10px;
        }
        
        #chatContainer::-webkit-scrollbar-track {
            background: rgba(31, 41, 55, 0.5);
            border-radius: 10px;
        }
        
        #chatContainer::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #7c3aed 0%, #ec4899 100%);
            border-radius: 10px;
            border: 2px solid rgba(31, 41, 55, 0.5);
        }
        
        #chatContainer::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #8b5cf6 0%, #f472b6 100%);
            box-shadow: 0 0 10px rgba(124, 58, 237, 0.5);
        }
        
        /* Custom scrollbar for winner chat */
        #winnerChatContainer::-webkit-scrollbar {
            width: 6px;
        }
        
        #winnerChatContainer::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 3px;
        }
        
        #winnerChatContainer::-webkit-scrollbar-thumb {
            background: #7c3aed;
            border-radius: 3px;
        }
        
        #winnerChatContainer::-webkit-scrollbar-thumb:hover {
            background: #9333ea;
        }
        
        /* Winner modal container styles */
        .winner-modal-container {
            border: 1px solid rgba(124, 58, 237, 0.3);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(124, 58, 237, 0.2);
        }
        
        /* Profile picture glow animation */
        @keyframes profileGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(124, 58, 237, 0.5), 0 0 40px rgba(124, 58, 237, 0.3);
            }
            50% {
                box-shadow: 0 0 30px rgba(124, 58, 237, 0.7), 0 0 60px rgba(124, 58, 237, 0.4);
            }
        }
        
        .winner-modal-container .w-24.h-24 {
            animation: profileGlow 3s ease-in-out infinite;
        }
        
        /* Animated Twitch logo background for auth modal */
        .twitch-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
        }
        
        .twitch-logo {
            position: absolute;
            opacity: 0.08;
            animation: float 20s infinite linear;
            color: #9146FF;
        }
        
        .twitch-logo:nth-child(1) {
            top: 10%;
            left: 10%;
            animation-delay: 0s;
            animation-duration: 25s;
        }
        
        .twitch-logo:nth-child(2) {
            top: 20%;
            left: 80%;
            animation-delay: -5s;
            animation-duration: 30s;
        }
        
        .twitch-logo:nth-child(3) {
            top: 60%;
            left: 15%;
            animation-delay: -10s;
            animation-duration: 35s;
        }
        
        .twitch-logo:nth-child(4) {
            top: 40%;
            left: 70%;
            animation-delay: -15s;
            animation-duration: 28s;
        }
        
        .twitch-logo:nth-child(5) {
            top: 80%;
            left: 50%;
            animation-delay: -20s;
            animation-duration: 22s;
        }
        
        .twitch-logo:nth-child(6) {
            top: 15%;
            left: 45%;
            animation-delay: -8s;
            animation-duration: 32s;
        }
        
        .twitch-logo:nth-child(7) {
            top: 70%;
            left: 85%;
            animation-delay: -12s;
            animation-duration: 26s;
        }
        
        .twitch-logo:nth-child(8) {
            top: 35%;
            left: 20%;
            animation-delay: -18s;
            animation-duration: 24s;
        }
        
        @keyframes float {
            0% {
                transform: translateY(0px) rotate(0deg) scale(1);
                opacity: 0.08;
            }
            25% {
                opacity: 0.12;
                transform: translateY(-5px) rotate(90deg) scale(1.1);
            }
            50% {
                opacity: 0.15;
                transform: translateY(-10px) rotate(180deg) scale(0.9);
            }
            75% {
                opacity: 0.1;
                transform: translateY(-15px) rotate(270deg) scale(1.2);
            }
            100% {
                transform: translateY(-20px) rotate(360deg) scale(1);
                opacity: 0.08;
            }
        }
        
        /* Dashboard animated background */
        .dashboard-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            opacity: 0.6;
            pointer-events: none;
        }
        
        .dashboard-icon {
            position: absolute;
            animation: dashboardFloat 20s infinite linear;
            opacity: 0.08;
            filter: drop-shadow(0 0 10px rgba(145, 70, 255, 0.3));
        }
        
        /* Twitch and streaming icons for dashboard */
        .dashboard-icon:nth-child(1) {
            top: 5%;
            left: 5%;
            animation-delay: 0s;
            animation-duration: 25s;
            color: #9146FF;
        }
        
        .dashboard-icon:nth-child(2) {
            top: 15%;
            right: 10%;
            animation-delay: -3s;
            animation-duration: 22s;
            color: #FF6B6B;
        }
        
        .dashboard-icon:nth-child(3) {
            top: 35%;
            left: 8%;
            animation-delay: -7s;
            animation-duration: 28s;
            color: #4ECDC4;
        }
        
        .dashboard-icon:nth-child(4) {
            top: 50%;
            right: 15%;
            animation-delay: -12s;
            animation-duration: 24s;
            color: #45B7D1;
        }
        
        .dashboard-icon:nth-child(5) {
            top: 70%;
            left: 12%;
            animation-delay: -16s;
            animation-duration: 30s;
            color: #96CEB4;
        }
        
        .dashboard-icon:nth-child(6) {
            bottom: 15%;
            right: 8%;
            animation-delay: -20s;
            animation-duration: 26s;
            color: #FFEAA7;
        }
        
        .dashboard-icon:nth-child(7) {
            top: 25%;
            left: 50%;
            animation-delay: -9s;
            animation-duration: 32s;
            color: #DDA0DD;
        }
        
        .dashboard-icon:nth-child(8) {
            bottom: 30%;
            left: 35%;
            animation-delay: -14s;
            animation-duration: 27s;
            color: #98D8C8;
        }
        
        .dashboard-icon:nth-child(9) {
            top: 10%;
            left: 75%;
            animation-delay: -18s;
            animation-duration: 29s;
            color: #F7DC6F;
        }
        
        .dashboard-icon:nth-child(10) {
            bottom: 40%;
            right: 25%;
            animation-delay: -22s;
            animation-duration: 23s;
            color: #BB8FCE;
        }
        
        .dashboard-icon:nth-child(11) {
            top: 60%;
            left: 60%;
            animation-delay: -5s;
            animation-duration: 35s;
            color: #9146FF;
        }
        
        .dashboard-icon:nth-child(12) {
            bottom: 10%;
            left: 20%;
            animation-delay: -11s;
            animation-duration: 31s;
            color: #FF6B6B;
        }
        
        .dashboard-icon:nth-child(13) {
            top: 40%;
            right: 40%;
            animation-delay: -25s;
            animation-duration: 33s;
            color: #4ECDC4;
        }
        
        .dashboard-icon:nth-child(14) {
            bottom: 20%;
            right: 50%;
            animation-delay: -8s;
            animation-duration: 21s;
            color: #45B7D1;
        }
        
        .dashboard-icon:nth-child(15) {
            top: 80%;
            left: 80%;
            animation-delay: -15s;
            animation-duration: 34s;
            color: #96CEB4;
        }
        
        @keyframes dashboardFloat {
            0% {
                transform: translateY(0px) rotate(0deg) scale(1);
                opacity: 0.08;
            }
            15% {
                opacity: 0.12;
                transform: translateY(-5px) rotate(54deg) scale(1.05);
            }
            30% {
                opacity: 0.15;
                transform: translateY(-8px) rotate(108deg) scale(0.95);
            }
            45% {
                opacity: 0.18;
                transform: translateY(-12px) rotate(162deg) scale(1.1);
            }
            60% {
                opacity: 0.14;
                transform: translateY(-10px) rotate(216deg) scale(0.9);
            }
            75% {
                opacity: 0.11;
                transform: translateY(-6px) rotate(270deg) scale(1.08);
            }
            90% {
                opacity: 0.09;
                transform: translateY(-3px) rotate(324deg) scale(0.98);
            }
            100% {
                transform: translateY(0px) rotate(360deg) scale(1);
                opacity: 0.08;
            }
        }
        
        /* Floating particles for dashboard */
        .particle {
            position: absolute;
            background: linear-gradient(135deg, #9146FF, #FF6B6B, #4ECDC4, #45B7D1);
            border-radius: 50%;
            animation: particleFloat 20s infinite linear;
            opacity: 0.15;
            filter: blur(1px);
        }
        
        .particle:nth-child(odd) {
            animation-direction: reverse;
        }
        
        .particle:nth-child(3n) {
            background: radial-gradient(circle, #9146FF, #DDA0DD);
        }
        
        .particle:nth-child(4n) {
            background: radial-gradient(circle, #4ECDC4, #96CEB4);
        }
        
        .particle:nth-child(5n) {
            background: radial-gradient(circle, #FF6B6B, #FFEAA7);
        }
        
        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) rotate(0deg) scale(0.8);
                opacity: 0;
            }
            5% {
                opacity: 0.1;
            }
            50% {
                opacity: 0.2;
                transform: translateY(50vh) rotate(180deg) scale(1.2);
            }
            95% {
                opacity: 0.1;
            }
            100% {
                transform: translateY(-100px) rotate(360deg) scale(0.8);
                opacity: 0;
            }
        }
        
        /* Twitch streaming elements */
        .streaming-element {
            position: absolute;
            animation: streamingFloat 15s infinite ease-in-out;
            opacity: 0.1;
            color: #9146FF;
        }
        
        .streaming-element:nth-child(odd) {
            animation-direction: alternate;
        }
        
        @keyframes streamingFloat {
            0%, 100% {
                transform: translateY(0px) rotate(0deg);
                opacity: 0.1;
            }
            25% {
                transform: translateY(-20px) rotate(90deg);
                opacity: 0.2;
            }
            50% {
                transform: translateY(-10px) rotate(180deg);
                opacity: 0.15;
            }
            75% {
                transform: translateY(-30px) rotate(270deg);
                opacity: 0.25;
            }
        }
        
        /* Pulsing effect for special elements */
        .dashboard-pulse {
            animation: dashboardPulse 3s ease-in-out infinite;
        }
        
        @keyframes dashboardPulse {
            0%, 100% {
                opacity: 0.08;
                transform: scale(1);
            }
            50% {
                opacity: 0.2;
                transform: scale(1.05);
            }
        }
        
        /* Pulsing animation for auth modal */
        .auth-modal-pulse {
            animation: authPulse 2s ease-in-out infinite;
        }
        
        @keyframes authPulse {
            0%, 100% {
                box-shadow: 0 0 10px rgba(145, 70, 255, 0.6), 0 0 20px rgba(145, 70, 255, 0.4);
            }
            50% {
                box-shadow: 0 0 20px rgba(145, 70, 255, 0.8), 0 0 40px rgba(145, 70, 255, 0.6);
            }
        }
        
        /* Settings gear rotation animation */
        .settings-gear {
            transition: transform 0.3s ease;
        }
        
        .settings-gear:hover {
            animation: rotateGear 1s ease-in-out infinite;
        }
        
        @keyframes rotateGear {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom scrollbar styles */
        .chat-messages::-webkit-scrollbar,
        .winners-list::-webkit-scrollbar,
        .modal-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .chat-messages::-webkit-scrollbar-track,
        .winners-list::-webkit-scrollbar-track,
        .modal-content::-webkit-scrollbar-track {
            background: #374151;
            border-radius: 4px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb,
        .winners-list::-webkit-scrollbar-thumb,
        .modal-content::-webkit-scrollbar-thumb {
            background: #6B7280;
            border-radius: 4px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover,
        .winners-list::-webkit-scrollbar-thumb:hover,
        .modal-content::-webkit-scrollbar-thumb:hover {
            background: #9CA3AF;
        }
        
        /* Giveaway modal background animations */
        .giveaway-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: -1;
            opacity: 0.8;
        }
        
        .giveaway-icon {
            position: absolute;
            animation: giveawayFloat 15s infinite linear;
            color: #9146FF;
            opacity: 0.1;
        }
        
        .giveaway-icon:nth-child(1) {
            top: 5%;
            left: 10%;
            animation-delay: 0s;
            animation-duration: 20s;
        }
        
        .giveaway-icon:nth-child(2) {
            top: 15%;
            right: 15%;
            animation-delay: -3s;
            animation-duration: 18s;
        }
        
        .giveaway-icon:nth-child(3) {
            top: 40%;
            left: 5%;
            animation-delay: -6s;
            animation-duration: 22s;
        }
        
        .giveaway-icon:nth-child(4) {
            top: 60%;
            right: 10%;
            animation-delay: -9s;
            animation-duration: 16s;
        }
        
        .giveaway-icon:nth-child(5) {
            bottom: 20%;
            left: 20%;
            animation-delay: -12s;
            animation-duration: 24s;
        }
        
        .giveaway-icon:nth-child(6) {
            bottom: 10%;
            right: 25%;
            animation-delay: -15s;
            animation-duration: 19s;
        }
        
        .giveaway-icon:nth-child(7) {
            top: 25%;
            left: 50%;
            animation-delay: -18s;
            animation-duration: 21s;
        }
        
        @keyframes giveawayFloat {
            0% {
                transform: translateY(0px) rotate(0deg) scale(1);
                opacity: 0.1;
            }
            25% {
                opacity: 0.2;
                transform: translateY(-10px) rotate(90deg) scale(1.1);
            }
            50% {
                opacity: 0.15;
                transform: translateY(-5px) rotate(180deg) scale(0.9);
            }
            75% {
                opacity: 0.25;
                transform: translateY(-15px) rotate(270deg) scale(1.2);
            }
            100% {
                transform: translateY(0px) rotate(360deg) scale(1);
                opacity: 0.1;
            }
        }
        
        /* Sparkle animation for giveaway icons */
        .giveaway-sparkle {
            position: absolute;
            animation: sparkle 3s infinite ease-in-out;
        }
        
        .giveaway-sparkle:nth-child(odd) {
            animation-delay: 0.5s;
        }
        
        .giveaway-sparkle:nth-child(even) {
            animation-delay: 1.5s;
        }
        
        @keyframes sparkle {
            0%, 100% {
                opacity: 0;
                transform: scale(0.5);
            }
            50% {
                opacity: 1;
                transform: scale(1.2);
            }
        }
        
        /* Modal pulse effect */
        .giveaway-modal-pulse {
            animation: giveawayModalPulse 3s ease-in-out infinite;
        }
        
        @keyframes giveawayModalPulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(147, 51, 234, 0.4), 0 0 30px rgba(147, 51, 234, 0.2);
            }
            50% {
                box-shadow: 0 0 25px rgba(147, 51, 234, 0.6), 0 0 50px rgba(147, 51, 234, 0.4);
            }
        }
        
        /* Owner settings dropdown */
        #ownerSettingsDropdown {
            position: fixed !important;
            z-index: 99999 !important;
            background: rgba(31, 41, 55, 0.98) !important;
            backdrop-filter: blur(15px) !important;
            border: 2px solid rgba(147, 51, 234, 0.8) !important;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(147, 51, 234, 0.5) !important;
            transform: translateZ(0) !important;
            will-change: transform !important;
            max-height: 300px !important;
            overflow-y: auto !important;
        }
        
        /* Custom scrollbar for owner dropdown */
        #ownerSettingsDropdown::-webkit-scrollbar {
            width: 8px;
        }
        
        #ownerSettingsDropdown::-webkit-scrollbar-track {
            background: rgba(31, 41, 55, 0.5);
            border-radius: 4px;
        }
        
        #ownerSettingsDropdown::-webkit-scrollbar-thumb {
            background: rgba(147, 51, 234, 0.6);
            border-radius: 4px;
        }
        
        #ownerSettingsDropdown::-webkit-scrollbar-thumb:hover {
            background: rgba(147, 51, 234, 0.8);
        }
        
        /* Custom scrollbar for channel settings modal */
        #channelSettingsModal::-webkit-scrollbar {
            width: 8px;
        }
        
        #channelSettingsModal::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 4px;
        }
        
        #channelSettingsModal::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 4px;
        }
        
        #channelSettingsModal::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
        
        /* Custom scrollbar for user management modal */
        #userManagementModal::-webkit-scrollbar {
            width: 8px;
        }
        
        #userManagementModal::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 4px;
        }
        
        #userManagementModal::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 4px;
        }
        
        #userManagementModal::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
        
        /* Ensure the parent container has proper stacking */
        #connectionStatus {
            position: relative !important;
            z-index: 99998 !important;
        }
        
        /* Force dropdown above everything */
        .owner-dropdown-container {
            position: fixed !important;
            z-index: 100000 !important;
            pointer-events: none !important;
        }
        
        .owner-dropdown-container > * {
            pointer-events: auto !important;
        }
        /* Кастомный скролл - чёрный цвет */
::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

::-webkit-scrollbar-track {
    background: rgba(55, 65, 81, 0.5);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #7c3aed 0%, #ec4899 100%);
    border-radius: 10px;
    border: 2px solid rgba(55, 65, 81, 0.5);
    transition: all 0.3s ease;
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #8b5cf6 0%, #f472b6 100%);
    box-shadow: 0 0 10px rgba(124, 58, 237, 0.5);
}

/* Firefox */
* {
    scrollbar-color: linear-gradient(180deg, #7c3aed 0%, #ec4899 100%) rgba(55, 65, 81, 0.5);
    scrollbar-width: thin;
}
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen">
    <!-- Notification Container -->
    <div id="notifications" class="fixed top-4 right-4 z-50 space-y-2"></div>

    <!-- Twitch Auth Modal -->
    <div id="authModal" class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4">
        <!-- Animated Twitch Background -->
        <div class="twitch-bg">
            <div class="twitch-logo">
                <svg width="120" height="120" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="twitch-logo">
                <svg width="80" height="80" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="twitch-logo">
                <svg width="100" height="100" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="twitch-logo">
                <svg width="90" height="90" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="twitch-logo">
                <svg width="110" height="110" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="twitch-logo">
                <svg width="75" height="75" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="twitch-logo">
                <svg width="95" height="95" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="twitch-logo">
                <svg width="85" height="85" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            
            <!-- Additional decorative elements for auth modal -->
            <div class="twitch-logo" style="top: 5%; right: 5%; animation-duration: 20s; opacity: 0.06;">
                <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
            </div>
            <div class="twitch-logo" style="bottom: 5%; left: 5%; animation-duration: 22s; opacity: 0.06;">
                <svg width="70" height="70" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                </svg>
            </div>
            <div class="twitch-logo" style="bottom: 10%; right: 10%; animation-duration: 26s; opacity: 0.06;">
                <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
            </div>
        </div>
        
        <div class="bg-gray-800 rounded-xl max-w-md w-full p-8 auth-modal-pulse slide-in relative">
            <div class="flex justify-center mb-6">
                <div class="relative">
                    <svg class="w-16 h-16 animate-pulse" viewBox="0 0 24 24" fill="none">
                        <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z" fill="#9146FF"/>
                    </svg>
                    <div class="absolute inset-0 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full opacity-20 animate-ping"></div>
                </div>
            </div>
            <h2 class="text-2xl font-bold text-center mb-4 neon-text bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
                Подключить Twitch аккаунт
            </h2>
            <p class="text-gray-300 mb-6 text-center">
                Для управления розыгрышами нужен доступ к вашему Twitch чату и никнейму.
            </p>
            <button id="twitchAuthBtn" class="w-full bg-gradient-to-r from-[#9146FF] to-[#7d3fd2] hover:from-[#7d3fd2] hover:to-[#6930c3] text-white font-bold py-3 px-4 rounded-lg transition duration-200 transform hover:scale-105 flex items-center justify-center gap-2 shadow-lg hover:shadow-xl">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#ffffff">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
                Подключить через Twitch
            </button>
            <p class="text-sm text-gray-400 mt-4 text-center">
                Мы запросим только необходимые права для проведения розыгрышей.
            </p>
            
            <!-- Additional features info -->
            <div class="mt-6 space-y-2">
                <div class="flex items-center space-x-2 text-sm text-gray-300">
                    <svg class="w-4 h-4 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span>Автоматическое отслеживание участников</span>
                </div>
                <div class="flex items-center space-x-2 text-sm text-gray-300">
                    <svg class="w-4 h-4 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span>Честный выбор победителей</span>
                </div>
                <div class="flex items-center space-x-2 text-sm text-gray-300">
                    <svg class="w-4 h-4 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    <span>Реальный счетчик зрителей</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Dashboard -->
    <div id="dashboard" class="hidden">
        <!-- Dashboard Animated Background -->
        <div class="dashboard-bg">
            <!-- Twitch and streaming icons -->
            <div class="dashboard-icon">
                <svg width="120" height="120" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="dashboard-icon dashboard-pulse">
                <svg width="80" height="80" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="100" height="100" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                </svg>
            </div>
            <div class="dashboard-icon dashboard-pulse">
                <svg width="90" height="90" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="110" height="110" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="75" height="75" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="95" height="95" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="85" height="85" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                </svg>
            </div>
            <div class="dashboard-icon dashboard-pulse">
                <svg width="105" height="105" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="70" height="70" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
                </svg>
            </div>
            
            <!-- More Twitch icons -->
            <div class="dashboard-icon">
                <svg width="65" height="65" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            <div class="dashboard-icon dashboard-pulse">
                <svg width="88" height="88" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="77" height="77" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                </svg>
            </div>
            <div class="dashboard-icon">
                <svg width="93" height="93" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                </svg>
            </div>
            <div class="dashboard-icon dashboard-pulse">
                <svg width="82" height="82" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                </svg>
            </div>
            
            <!-- Streaming elements -->
            <div class="streaming-element" style="top: 12%; left: 25%; animation-delay: -2s;">
                <svg width="45" height="45" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M8 5v14l11-7z"/>
                </svg>
            </div>
            <div class="streaming-element" style="top: 65%; right: 20%; animation-delay: -8s;">
                <svg width="38" height="38" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/>
                </svg>
            </div>
            <div class="streaming-element" style="top: 35%; left: 80%; animation-delay: -5s;">
                <svg width="42" height="42" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
            </div>
            <div class="streaming-element" style="bottom: 45%; left: 15%; animation-delay: -12s;">
                <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
            </div>
            
            <!-- Enhanced floating particles -->
            <div class="particle" style="width: 6px; height: 6px; top: 8%; left: 18%; animation-delay: 0s;"></div>
            <div class="particle" style="width: 4px; height: 4px; top: 25%; left: 65%; animation-delay: -2s;"></div>
            <div class="particle" style="width: 8px; height: 8px; top: 45%; left: 12%; animation-delay: -4s;"></div>
            <div class="particle" style="width: 5px; height: 5px; top: 65%; left: 75%; animation-delay: -6s;"></div>
            <div class="particle" style="width: 7px; height: 7px; top: 18%; left: 45%; animation-delay: -8s;"></div>
            <div class="particle" style="width: 3px; height: 3px; top: 78%; left: 25%; animation-delay: -10s;"></div>
            <div class="particle" style="width: 6px; height: 6px; top: 38%; left: 85%; animation-delay: -12s;"></div>
            <div class="particle" style="width: 4px; height: 4px; top: 58%; left: 8%; animation-delay: -14s;"></div>
            <div class="particle" style="width: 9px; height: 9px; top: 88%; left: 55%; animation-delay: -16s;"></div>
            <div class="particle" style="width: 5px; height: 5px; top: 15%; left: 78%; animation-delay: -18s;"></div>
            <div class="particle" style="width: 7px; height: 7px; top: 72%; left: 38%; animation-delay: -20s;"></div>
            <div class="particle" style="width: 4px; height: 4px; top: 52%; left: 90%; animation-delay: -22s;"></div>
            <div class="particle" style="width: 6px; height: 6px; top: 28%; left: 3%; animation-delay: -24s;"></div>
            <div class="particle" style="width: 8px; height: 8px; top: 85%; left: 68%; animation-delay: -26s;"></div>
            <div class="particle" style="width: 3px; height: 3px; top: 42%; left: 52%; animation-delay: -28s;"></div>
            <div class="particle" style="width: 5px; height: 5px; top: 95%; left: 15%; animation-delay: -30s;"></div>
            <div class="particle" style="width: 7px; height: 7px; top: 2%; left: 88%; animation-delay: -32s;"></div>
            <div class="particle" style="width: 4px; height: 4px; top: 68%; left: 62%; animation-delay: -34s;"></div>
            <div class="particle" style="width: 6px; height: 6px; top: 32%; left: 28%; animation-delay: -36s;"></div>
            <div class="particle" style="width: 8px; height: 8px; top: 82%; left: 92%; animation-delay: -38s;"></div>
        </div>
        
        <div class="twitch-gradient p-1">
            <div class="bg-gray-900 relative overflow-hidden">
                <!-- Main Content Background Animation -->
                <div class="dashboard-bg">
                    <!-- Twitch and streaming icons -->
                    <div class="dashboard-icon">
                        <svg width="120" height="120" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="80" height="80" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="100" height="100" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="90" height="90" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="110" height="110" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="75" height="75" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="95" height="95" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="85" height="85" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="105" height="105" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="70" height="70" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
                        </svg>
                    </div>
                    
                    <!-- More Twitch icons -->
                    <div class="dashboard-icon">
                        <svg width="65" height="65" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="88" height="88" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="77" height="77" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="93" height="93" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="82" height="82" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    
                    <!-- Streaming elements -->
                    <div class="streaming-element" style="top: 12%; left: 25%; animation-delay: -2s;">
                        <svg width="45" height="45" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </div>
                    <div class="streaming-element" style="top: 65%; right: 20%; animation-delay: -8s;">
                        <svg width="38" height="38" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/>
                        </svg>
                    </div>
                    <div class="streaming-element" style="top: 35%; left: 80%; animation-delay: -5s;">
                        <svg width="42" height="42" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        </svg>
                    </div>
                    <div class="streaming-element" style="bottom: 45%; left: 15%; animation-delay: -12s;">
                        <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    
                    <!-- Enhanced floating particles -->
                    <div class="particle" style="width: 6px; height: 6px; top: 8%; left: 18%; animation-delay: 0s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 25%; left: 65%; animation-delay: -2s;"></div>
                    <div class="particle" style="width: 8px; height: 8px; top: 45%; left: 12%; animation-delay: -4s;"></div>
                    <div class="particle" style="width: 5px; height: 5px; top: 65%; left: 75%; animation-delay: -6s;"></div>
                    <div class="particle" style="width: 7px; height: 7px; top: 18%; left: 45%; animation-delay: -8s;"></div>
                    <div class="particle" style="width: 3px; height: 3px; top: 78%; left: 25%; animation-delay: -10s;"></div>
                    <div class="particle" style="width: 6px; height: 6px; top: 38%; left: 85%; animation-delay: -12s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 58%; left: 8%; animation-delay: -14s;"></div>
                    <div class="particle" style="width: 9px; height: 9px; top: 88%; left: 55%; animation-delay: -16s;"></div>
                    <div class="particle" style="width: 5px; height: 5px; top: 15%; left: 78%; animation-delay: -18s;"></div>
                    <div class="particle" style="width: 7px; height: 7px; top: 72%; left: 38%; animation-delay: -20s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 52%; left: 90%; animation-delay: -22s;"></div>
                    <div class="particle" style="width: 6px; height: 6px; top: 28%; left: 3%; animation-delay: -24s;"></div>
                    <div class="particle" style="width: 8px; height: 8px; top: 85%; left: 68%; animation-delay: -26s;"></div>
                    <div class="particle" style="width: 3px; height: 3px; top: 42%; left: 52%; animation-delay: -28s;"></div>
                    <div class="particle" style="width: 5px; height: 5px; top: 95%; left: 15%; animation-delay: -30s;"></div>
                    <div class="particle" style="width: 7px; height: 7px; top: 2%; left: 88%; animation-delay: -32s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 68%; left: 62%; animation-delay: -34s;"></div>
                    <div class="particle" style="width: 6px; height: 6px; top: 32%; left: 28%; animation-delay: -36s;"></div>
                    <div class="particle" style="width: 8px; height: 8px; top: 82%; left: 92%; animation-delay: -38s;"></div>
                </div>
                <!-- Dashboard Animated Background for main content area -->
                <div class="dashboard-bg">
                    <!-- Twitch and streaming icons -->
                    <div class="dashboard-icon">
                        <svg width="120" height="120" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="80" height="80" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="100" height="100" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="90" height="90" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="110" height="110" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="75" height="75" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="95" height="95" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="85" height="85" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="105" height="105" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-4h11v4zm0-5H4V9h11v4zm5 5h-4V9h4v9z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="70" height="70" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/>
                        </svg>
                    </div>
                    
                    <!-- More Twitch icons -->
                    <div class="dashboard-icon">
                        <svg width="65" height="65" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="88" height="88" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="77" height="77" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="93" height="93" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon dashboard-pulse">
                        <svg width="82" height="82" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                        </svg>
                    </div>
                    
                    <!-- Streaming elements -->
                    <div class="streaming-element" style="top: 12%; left: 25%; animation-delay: -2s;">
                        <svg width="45" height="45" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </div>
                    <div class="streaming-element" style="top: 65%; right: 20%; animation-delay: -8s;">
                        <svg width="38" height="38" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/>
                        </svg>
                    </div>
                    <div class="streaming-element" style="top: 35%; left: 80%; animation-delay: -5s;">
                        <svg width="42" height="42" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                        </svg>
                    </div>
                    <div class="streaming-element" style="bottom: 45%; left: 15%; animation-delay: -12s;">
                        <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                    </div>
                    
                    <!-- Enhanced floating particles -->
                    <div class="particle" style="width: 6px; height: 6px; top: 8%; left: 18%; animation-delay: 0s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 25%; left: 65%; animation-delay: -2s;"></div>
                    <div class="particle" style="width: 8px; height: 8px; top: 45%; left: 12%; animation-delay: -4s;"></div>
                    <div class="particle" style="width: 5px; height: 5px; top: 65%; left: 75%; animation-delay: -6s;"></div>
                    <div class="particle" style="width: 7px; height: 7px; top: 18%; left: 45%; animation-delay: -8s;"></div>
                    <div class="particle" style="width: 3px; height: 3px; top: 78%; left: 25%; animation-delay: -10s;"></div>
                    <div class="particle" style="width: 6px; height: 6px; top: 38%; left: 85%; animation-delay: -12s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 58%; left: 8%; animation-delay: -14s;"></div>
                    <div class="particle" style="width: 9px; height: 9px; top: 88%; left: 55%; animation-delay: -16s;"></div>
                    <div class="particle" style="width: 5px; height: 5px; top: 15%; left: 78%; animation-delay: -18s;"></div>
                    <div class="particle" style="width: 7px; height: 7px; top: 72%; left: 38%; animation-delay: -20s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 52%; left: 90%; animation-delay: -22s;"></div>
                    <div class="particle" style="width: 6px; height: 6px; top: 28%; left: 3%; animation-delay: -24s;"></div>
                    <div class="particle" style="width: 8px; height: 8px; top: 85%; left: 68%; animation-delay: -26s;"></div>
                    <div class="particle" style="width: 3px; height: 3px; top: 42%; left: 52%; animation-delay: -28s;"></div>
                    <div class="particle" style="width: 5px; height: 5px; top: 95%; left: 15%; animation-delay: -30s;"></div>
                    <div class="particle" style="width: 7px; height: 7px; top: 2%; left: 88%; animation-delay: -32s;"></div>
                    <div class="particle" style="width: 4px; height: 4px; top: 68%; left: 62%; animation-delay: -34s;"></div>
                    <div class="particle" style="width: 6px; height: 6px; top: 32%; left: 28%; animation-delay: -36s;"></div>
                    <div class="particle" style="width: 8px; height: 8px; top: 82%; left: 92%; animation-delay: -38s;"></div>
                </div>
                
                <!-- Header -->
                <header class="container mx-auto px-4 py-6 flex justify-between items-center relative z-10">
                    <div class="flex items-center space-x-3">
                        <div class="relative">
                            <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="#9146FF" class="drop-shadow-lg filter">
                                <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                            </svg>
                            <div class="absolute inset-0 bg-purple-500 rounded-full blur-xl opacity-50 animate-pulse"></div>
                        </div>
                        <h1 class="text-3xl font-bold bg-gradient-to-r from-purple-400 via-pink-400 to-purple-400 bg-clip-text text-transparent bg-[length:200%_auto] animate-gradient">Twitch Giveaways</h1>
                    </div>
                    <div class="flex items-center space-x-4">
                        <!-- Global Settings Button -->
                        <button id="globalSettingsBtn" class="text-gray-400 hover:text-purple-400 transition-all duration-300 transform hover:scale-110 p-2.5 rounded-lg hover:bg-purple-500/10 border border-transparent hover:border-purple-500/30" title="Настройки">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="settings-gear transition-all duration-300">
                                <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
                                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z"/>
                            </svg>
                        </button>
                        
                        <div id="connectionStatus" class="flex items-center text-sm relative">
                            <div id="streamerAvatar" class="w-10 h-10 rounded-full mr-3 overflow-hidden bg-gradient-to-br from-purple-600 to-pink-600 flex items-center justify-center ring-2 ring-purple-500/50 shadow-lg shadow-purple-500/30">
                                <span class="text-xs text-white font-bold">?</span>
                            </div>
                            <div class="relative">
                                <button id="username" class="font-semibold hover:text-purple-400 transition-colors duration-200 cursor-pointer bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">Подключен</button>
                                
                                <div id="ownerSettingsDropdown" class="bg-gray-800 border border-gray-600 rounded-lg shadow-xl min-w-48 hidden">
                                    <div class="p-2">
                                        <button id="channelSettingsBtn" class="w-full text-left px-3 py-2 hover:bg-gray-700 rounded text-sm flex items-center space-x-2">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <circle cx="12" cy="12" r="3"></circle>
                                                <path d="M12 1v6m0 6v6M5.64 7.05l4.95 4.95m4.95-4.95l-4.95 4.95M1 12h6m6 0h6"></path>
                                            </svg>
                                            <span>Настройки канала</span>
                                        </button>
                                        <button id="userManagementBtn" class="w-full text-left px-3 py-2 hover:bg-gray-700 rounded text-sm flex items-center space-x-2">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                                                <circle cx="9" cy="7" r="4"></circle>
                                                <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                                                <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                                            </svg>
                                            <span>Управление пользователями</span>
                                        </button>
                                        <div class="border-t border-gray-600 my-1"></div>
                                        <div class="px-3 py-1 text-xs text-gray-400">Только для владельца</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="disconnectBtn" class="text-gray-400 hover:text-red-400 transition-all duration-300 transform hover:scale-110 p-2.5 rounded-lg hover:bg-red-500/10 border border-transparent hover:border-red-500/30" title="Отключить аккаунт">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                                <polyline points="16,17 21,12 16,7"></polyline>
                                <line x1="21" y1="12" x2="9" y2="12"></line>
                            </svg>
                        </button>
                    </div>
                </header>

                <!-- Main Content -->
                <div class="container mx-auto px-4 pb-12 flex flex-col lg:flex-row gap-8 min-h-[calc(100vh-120px)] relative z-10">
                    <!-- Chat Column -->
                    <div class="lg:w-1/3 glass-card rounded-2xl overflow-hidden neon-border transition-all duration-300">
                        <div class="bg-gradient-to-r from-purple-900/50 to-pink-900/50 px-4 py-3 border-b border-purple-500/30 flex justify-between items-center backdrop-blur-sm">
                            <h2 class="font-bold text-lg bg-gradient-to-r from-purple-300 to-pink-300 bg-clip-text text-transparent flex items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-purple-400">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                                Чат стрима
                            </h2>
                            <span id="viewerCount" class="bg-gradient-to-r from-purple-600 to-pink-600 text-xs px-3 py-1.5 rounded-full font-semibold shadow-lg shadow-purple-500/50">0 зрителей</span>
                        </div>
                        <div id="chatContainer" class="h-[400px] lg:h-[calc(100vh-220px)] overflow-y-auto p-4 pb-0 bg-gradient-to-b from-gray-900/50 to-gray-800/50">
                            <div class="text-center text-gray-400 py-8 flex flex-col items-center gap-2">
                                <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="text-purple-500/50 animate-pulse">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                                <span>Подключен к чату Twitch. Сообщения появятся здесь.</span>
                            </div>
                        </div>
                        <div class="p-4 border-t border-purple-500/20 bg-gray-800/50 backdrop-blur-sm">
                            
                        </div>
                    </div>

                    <!-- Giveaways Column -->
                    <div class="lg:flex-1">
                        <div class="glass-card rounded-2xl p-6 neon-border mb-6 transition-all duration-300">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="font-bold text-2xl bg-gradient-to-r from-purple-300 via-pink-300 to-purple-300 bg-clip-text text-transparent flex items-center gap-3">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-purple-400">
                                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                                    </svg>
                                    Активные розыгрыши
                                </h2>
                                <button id="newGiveawayBtn" class="gradient-btn text-white px-6 py-3 rounded-xl font-semibold transition-all duration-300 transform hover:scale-105 shadow-lg shadow-purple-500/50 hover:shadow-xl hover:shadow-purple-500/70 flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="12" y1="5" x2="12" y2="19"></line>
                                        <line x1="5" y1="12" x2="19" y2="12"></line>
                                    </svg>
                                    Новый розыгрыш
                                </button>
                            </div>
                            
                            <div id="giveawaysList" class="space-y-4">
                                <!-- Giveaways will be populated here -->
                            </div>
                        </div>

                        <!-- Recent Winners -->
                        <div class="glass-card rounded-2xl p-6 neon-border transition-all duration-300">
                            <div class="flex justify-between items-center mb-6">
                                <h2 class="font-bold text-2xl bg-gradient-to-r from-yellow-300 via-orange-300 to-pink-300 bg-clip-text text-transparent flex items-center gap-3">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-yellow-400">
                                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                                    </svg>
                                    Последние победители
                                </h2>
                                <button id="clearWinnersBtn" class="group relative p-3 bg-gradient-to-r from-gray-700 to-gray-600 hover:from-red-600 hover:to-red-500 rounded-xl transition-all duration-300 transform hover:scale-110 border border-gray-600 hover:border-red-400 shadow-lg hover:shadow-red-500/50" data-translate-title="clearWinnersList" title="Очистить список победителей">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300 group-hover:text-white transition-colors duration-300">
                                        <path d="M3 6h18"></path>
                                        <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                                        <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                                        <line x1="10" y1="11" x2="10" y2="17"></line>
                                        <line x1="14" y1="11" x2="14" y2="17"></line>
                                    </svg>
                                    <div class="absolute -top-12 left-1/2 transform -translate-x-1/2 bg-gray-900 text-white text-xs px-3 py-2 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none whitespace-nowrap shadow-lg border border-gray-700" data-translate="clearHistory">
                                        Очистить историю
                                    </div>
                                </button>
                            </div>
                            <div id="winnersList" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                                <!-- Winners will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- New Giveaway Modal -->
    <div id="newGiveawayModal" class="fixed inset-0 bg-black bg-opacity-80 z-50 flex items-center justify-center p-4 hidden backdrop-blur-sm">
        <div class="glass-card rounded-2xl max-w-md w-full p-6 giveaway-modal-pulse slide-in relative overflow-hidden border-2 border-purple-500/30 shadow-2xl">
            <!-- Animated Background -->
            <div class="giveaway-bg">
                <!-- Twitch Icons -->
                <div class="giveaway-icon">
                    <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="45" height="45" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="55" height="55" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M9 11H7v9h2v-9zm4 0h-2v9h2v-9zm4 0h-2v9h2v-9zm2-7v2H5V4h3.5l1-1h5l1 1H19zm-2 2H7v16h10V6z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="65" height="65" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="40" height="40" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34c-.39-.39-1.02-.39-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="70" height="70" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M2.149 0l-1.612 4.119v16.836h5.731v3.045h3.224l3.045-3.045h4.657l6.269-6.269v-14.686h-19.313zm17.124 13.612l-3.582 3.582h-5.731l-3.045 3.045v-3.045h-3.582v-15.045h15.045v11.463zm-3.582-7.343v6.262h-2.149v-6.262h2.149zm-5.731 0v6.262h-2.149v-6.262h2.149z"/>
                    </svg>
                </div>
                
                <!-- Sparkle Effects -->
                <div class="giveaway-sparkle" style="top: 20%; left: 30%; color: #FFD700;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                </div>
                <div class="giveaway-sparkle" style="top: 70%; right: 20%; color: #FF69B4;">
                    <svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                </div>
                <div class="giveaway-sparkle" style="bottom: 30%; left: 15%; color: #00FFFF;">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                </div>
                <div class="giveaway-sparkle" style="top: 40%; right: 40%; color: #32CD32;">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                </div>
                <div class="giveaway-sparkle" style="bottom: 60%; left: 60%; color: #FF4500;">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                    </svg>
                </div>
            </div>
            
            <div class="flex justify-between items-center mb-4 relative z-10">
                <div class="flex items-center space-x-3">
                    <div class="w-8 h-8 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none">
                            <!-- Кубик Рубика 3D -->
                            <defs>
                                <linearGradient id="redFaceSmall" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#FF6B6B;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#DC143C;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="blueFaceSmall" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#4ECDC4;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#2E8B87;stop-opacity:1" />
                                </linearGradient>
                                <linearGradient id="whiteFaceSmall" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#FFFFFF;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#E8E8E8;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            
                            <!-- Левая грань (красная) -->
                            <polygon points="2,8 2,16 8,18 8,10" fill="url(#redFaceSmall)" stroke="#000" stroke-width="0.5"/>
                            
                            <!-- Верхняя грань (белая) -->
                            <polygon points="2,8 8,10 16,8 10,6" fill="url(#whiteFaceSmall)" stroke="#000" stroke-width="0.5"/>
                            
                            <!-- Правая грань (синяя) -->
                            <polygon points="10,6 16,8 16,16 10,14" fill="url(#blueFaceSmall)" stroke="#000" stroke-width="0.5"/>
                            
                            <!-- Разделительные линии -->
                            <line x1="2" y1="11" x2="8" y2="13" stroke="#000" stroke-width="0.3"/>
                            <line x1="2" y1="13.5" x2="8" y2="15.5" stroke="#000" stroke-width="0.3"/>
                            <line x1="4.7" y1="9" x2="4.7" y2="17" stroke="#000" stroke-width="0.3"/>
                            
                            <line x1="6" y1="7" x2="12" y2="9" stroke="#000" stroke-width="0.3"/>
                            <line x1="8" y1="6.5" x2="14" y2="8.5" stroke="#000" stroke-width="0.3"/>
                            
                            <line x1="10" y1="9" x2="16" y2="11" stroke="#000" stroke-width="0.3"/>
                            <line x1="10" y1="11.5" x2="16" y2="13.5" stroke="#000" stroke-width="0.3"/>
                            <line x1="13" y1="7" x2="13" y2="15" stroke="#000" stroke-width="0.3"/>
                            
                            <!-- Блики для 3D эффекта -->
                            <polygon points="2,8 3,8.5 3,16.5 2,16" fill="rgba(255,255,255,0.3)" stroke="none"/>
                            <polygon points="2,8 3,8.5 9,10.5 8,10" fill="rgba(255,255,255,0.4)" stroke="none"/>
                        </svg>
                    </div>
                    <h2 class="text-xl font-bold bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent" data-translate="newGiveawayTitle">Новый розыгрыш</h2>
                </div>
                <button id="closeGiveawayModal" class="text-gray-400 hover:text-white transition-all duration-200 hover:scale-110 relative z-20">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            
            <div class="space-y-5 relative z-10">
                <div>
                    <label class="block text-sm font-semibold mb-2 text-gray-300" for="giveawayName" data-translate="giveawayName">Название розыгрыша</label>
                    <input type="text" id="giveawayName" class="w-full bg-gray-700/80 border border-gray-600/50 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition-all duration-200 text-gray-100 placeholder-gray-500 backdrop-blur-sm" data-translate-placeholder="giveawayNamePlaceholder" placeholder="Например: Специальный дроп">
                </div>
                
                <div>
                    <label class="block text-sm font-semibold mb-2 text-gray-300" for="keyword" data-translate="keyword">Ключевое слово</label>
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 flex items-center pl-4 pointer-events-none text-purple-400 font-bold text-lg">
                            !
                        </div>
                        <input type="text" id="keyword" class="w-full bg-gray-700/80 border border-gray-600/50 rounded-xl pl-10 pr-4 py-3 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition-all duration-200 text-gray-100 placeholder-gray-500 backdrop-blur-sm" data-translate-placeholder="keywordPlaceholder" placeholder="drop">
                    </div>
                </div>
                
                <div>
                    <label class="block text-sm font-semibold mb-2 text-gray-300" for="winnerCount" data-translate="winnerCount">Количество победителей</label>
                    <select id="winnerCount" class="w-full bg-gray-700/80 border border-gray-600/50 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-purple-500 transition-all duration-200 text-gray-100 backdrop-blur-sm cursor-pointer">
                        <option value="1" data-translate="winner1">1 победитель</option>
                        <option value="3" data-translate="winner3">3 победителя</option>
                        <option value="5" data-translate="winner5">5 победителей</option>
                        <option value="10" data-translate="winner10">10 победителей</option>
                    </select>
                </div>
                
                <div class="flex justify-center space-x-2 pt-2">
                    <button id="fnFilterBtn" class="flex-1 bg-gray-700/80 hover:bg-gray-600 text-gray-300 hover:text-white px-4 py-2 rounded-xl transition-all duration-200 text-sm font-medium backdrop-blur-sm border border-gray-600/50 hover:border-purple-500" data-translate-title="fnFilterTitle" title="Только новые участники (пишут первый раз в чат)">
                        <span class="flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>
                            </svg>
                            <span data-translate="fnFilter">FN</span>
                        </span>
                    </button>
                    <button id="subscribersFilterBtn" class="flex-1 bg-gray-700/80 hover:bg-gray-600 text-gray-300 hover:text-white px-4 py-2 rounded-xl transition-all duration-200 text-sm font-medium backdrop-blur-sm border border-gray-600/50 hover:border-purple-500" data-translate-title="subscribersFilterTitle" title="Только подписчики Twitch">
                        <span class="flex items-center justify-center gap-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
                            </svg>
                            <span data-translate="subscribersFilter">Подписчики</span>
                        </span>
                    </button>
                </div>
                
                <div class="flex justify-center space-x-3 pt-2">
                    <button id="cancelGiveawayBtn" class="bg-gray-700/80 hover:bg-gray-600 text-white px-6 py-3 rounded-xl transition-all duration-200 text-sm font-medium backdrop-blur-sm border border-gray-600/50 hover:border-gray-500" data-translate="cancel">Отмена</button>
                    <button id="createGiveawayBtn" class="gradient-btn text-white px-6 py-3 rounded-xl font-semibold transition-all duration-300 transform hover:scale-105 shadow-lg shadow-purple-500/50 hover:shadow-xl hover:shadow-purple-500/70 relative overflow-hidden text-sm">
                        <span class="relative z-10 flex items-center gap-2" data-translate="startGiveaway">
                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path>
                            </svg>
                            Начать розыгрыш
                        </span>
                        <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent transform -skew-x-12 translate-x-[-100%] transition-transform duration-700 hover:translate-x-[100%]"></div>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Winner Announcement Modal -->
    <div id="winnerModal" class="fixed inset-0 bg-black bg-opacity-80 z-50 flex items-center justify-center p-4 hidden backdrop-blur-sm">
        <div class="glass-card rounded-2xl max-w-4xl w-full overflow-hidden shadow-2xl winner-modal-container border-2 border-purple-500/30">
            <!-- Top Bar with Purple Background -->
            <div class="bg-gradient-to-r from-purple-900 via-purple-800 to-purple-900 px-6 py-5 flex items-center justify-between backdrop-blur-sm relative overflow-hidden">
                <!-- Animated Crown Background -->
                <div class="dashboard-bg">
                    <!-- Crown Icons -->
                    <div class="dashboard-icon">
                        <svg width="80" height="80" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="70" height="70" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="90" height="90" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="65" height="65" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="55" height="55" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="75" height="75" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                </div>
                
                <div class="flex items-center gap-2 relative z-10">
                    <svg class="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
                    </svg>
                    <span class="text-white font-semibold text-lg">Победитель:</span>
                </div>
                <button id="closeWinnerModal" class="text-white hover:text-gray-200 transition-colors relative z-10">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>

            <!-- Main Content Area -->
            <div class="bg-gray-900 p-6 relative overflow-hidden">
                <!-- Animated Background with Crowns -->
                <div class="dashboard-bg">
                    <!-- Crown Icons -->
                    <div class="dashboard-icon">
                        <svg width="100" height="100" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="80" height="80" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="90" height="90" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="70" height="70" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="110" height="110" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="85" height="85" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="95" height="95" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="75" height="75" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                    <div class="dashboard-icon">
                        <svg width="65" height="65" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M21.58 16.09l-1.09-7.66C20.21 6.46 18.52 5 16.53 5H7.47C5.48 5 3.79 6.46 3.51 8.43l-1.09 7.66C2.2 17.63 3.39 19 4.94 19h0c0.68 0 1.32-0.27 1.8-0.75L9 16h6l2.26 2.25c0.48 0.48 1.12 0.75 1.8 0.75h0C20.61 19 21.8 17.63 21.58 16.09z"/>
                        </svg>
                    </div>
                </div>
                
                <!-- Timer in top right -->
                <div class="absolute top-4 right-4 z-10">
                    <div id="winnerTimer" class="flex items-center gap-2 bg-red-900/80 backdrop-blur-sm border border-red-500/50 rounded-lg px-3 py-1.5 shadow-lg shadow-red-500/20">
                        <div class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
                        <span class="text-white text-sm font-mono font-bold">01:00</span>
                    </div>
                </div>

                <!-- Winner Information Section -->
                <div id="winnerNames" class="space-y-6 mb-6 relative z-10">
                    <!-- Winners will be added here -->
                </div>

                <!-- Messages Section -->
                <div class="mt-6 relative z-10">
                    <div class="flex items-center gap-2 mb-3">
                        <h3 class="text-gray-300 text-sm font-medium">Последние сообщения от победителя:</h3>
                        <div id="winnerMessageCount" class="flex items-center gap-1.5 bg-gray-800/80 backdrop-blur-sm border border-orange-500/50 rounded-lg px-2.5 py-1 shadow-lg shadow-orange-500/10">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="#F97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                            </svg>
                            <span class="text-orange-400 text-xs font-bold">0</span>
                        </div>
                    </div>
                    <div id="winnerChatContainer" class="bg-gray-800/90 backdrop-blur-sm rounded-lg p-4 min-h-[200px] max-h-[300px] overflow-y-auto border border-gray-700/50">
                        <div class="text-center text-gray-400 py-8">
                            Ожидание новых сообщений...
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex gap-3 mt-6 justify-center relative z-10">
                    <button id="rerollWinnerBtn" class="bg-orange-600 hover:bg-orange-500 text-white px-6 py-2 rounded-lg transition transform hover:scale-105 shadow-lg shadow-orange-500/30">
                         Перевыбрать
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Winner Messages Modal -->
    <div id="winnerMessagesModal" class="fixed inset-0 bg-black bg-opacity-80 hidden items-center justify-center p-4" style="z-index: 60;">
        <div class="bg-gray-800 rounded-xl w-full max-w-3xl max-h-[80vh] overflow-hidden neon-border">
            <div class="flex items-center justify-between border-b border-gray-700 px-6 py-4">
                <h3 id="winnerMessagesTitle" class="text-xl font-bold text-white">Сообщения пользователя</h3>
                <button id="closeWinnerMessagesModal" class="text-gray-400 hover:text-white transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            <div id="winnerMessagesContent" class="p-6 space-y-3 overflow-y-auto max-h-[60vh] text-gray-100">
                <div class="text-center text-gray-400 py-8">
                    Сообщений не найдено
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Floating Button -->
    <button id="mobileActionBtn" class="lg:hidden floating-btn bg-purple-700 text-white rounded-full w-14 h-14 flex items-center justify-center shadow-lg">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
    </button>

    <!-- Mobile Menu -->
    <div id="mobileMenu" class="fixed inset-0 bg-black bg-opacity-80 z-40 hidden">
        <div class="absolute bottom-0 left-0 right-0 bg-gray-800 rounded-t-xl p-6">
            <button id="closeMobileMenu" class="absolute top-4 right-4 text-gray-400">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
            <div class="space-y-4">
                <button id="mobileNewGiveawayBtn" class="w-full bg-purple-700 hover:bg-purple-600 text-white px-4 py-3 rounded-lg transition">Новый розыгрыш</button>
                <button id="mobileDisconnectBtn" class="w-full bg-gray-700 hover:bg-red-600 text-gray-300 hover:text-white px-4 py-3 rounded-lg transition-all duration-300 flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16,17 21,12 16,7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                    Отключить аккаунт
                </button>
                <div id="mobileUsername" class="text-center text-gray-400 mt-2">Подключен как: by_CTPAX</div>
            </div>
        </div>
    </div>

    
    <div id="channelSettingsModal" class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4 hidden">
        <div class="bg-gray-800 rounded-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto p-6 neon-border relative">
            <!-- Animated Background -->
            <div class="giveaway-bg">
                <!-- Settings Icons -->
                <div class="giveaway-icon">
                    <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="45" height="45" viewBox="0 0 24 24" fill="currentColor">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M12 1v6m0 6v6M5.64 7.05l4.95 4.95m4.95-4.95l-4.95 4.95M1 12h6m6 0h6"></path>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="55" height="55" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M3 17v2h6v-2H3zM3 5v2h10V5H3zm10 16v-2h8v-2h-8v-2h-2v6h2zM7 9v2H3v2h4v2h2V9H7zm14 4v-2H11v2h10zm-6-4h2V7h4V5h-4V3h-2v6z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.82,11.69,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
                    </svg>
                </div>
            </div>
            
            <div class="flex justify-between items-center mb-6 relative z-10">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-gradient-to-r from-purple-600 to-pink-600 rounded-full flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M12 1v6m0 6v6M5.64 7.05l4.95 4.95m4.95-4.95l-4.95 4.95M1 12h6m6 0h6"></path>
                        </svg>
                    </div>
                    <div>
                        <h2 class="text-2xl font-bold bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent" data-translate="channelSettingsTitle">Настройки канала</h2>
                        <p class="text-sm text-gray-400" data-translate="channelSettingsSubtitle">Специальные настройки для владельца by_CTPAX</p>
                    </div>
                </div>
                <button id="closeChannelSettingsModal" class="text-gray-400 hover:text-white transition-all duration-200 hover:scale-110 relative z-20">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            
            <!-- Settings Content -->
            <div class="space-y-6 relative z-10">
                <!-- General Settings -->
                <div class="bg-gray-700 rounded-xl p-6">
                    <h3 class="text-xl font-bold mb-4 flex items-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="12" cy="12" r="3"></circle>
                            <path d="M12 1v6m0 6v6M5.64 7.05l4.95 4.95m4.95-4.95l-4.95 4.95M1 12h6m6 0h6"></path>
                        </svg>
                        <span data-translate="generalSettings">Общие настройки</span>
                    </h3>
                    
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <div>
                                <label class="text-sm font-medium" data-translate="autoAnnounceWinners">Автоматические объявления побед</label>
                                <p class="text-xs text-gray-400" data-translate="autoAnnounceWinnersDesc">Автоматически объявлять победителей в чате</p>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="autoAnnounce" class="sr-only peer" checked>
                                <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                            </label>
                        </div>
                        
                        <div class="flex items-center justify-between">
                            <div>
                                <label class="text-sm font-medium" data-translate="soundNotifications">Звуковые уведомления</label>
                                <p class="text-xs text-gray-400" data-translate="soundNotificationsDesc">Воспроизводить звук при новых участниках</p>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="soundNotifications" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                            </label>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2" data-translate="responseTimeout">Таймер ожидания ответа (секунды)</label>
                            <input type="number" id="responseTimeout" min="30" max="300" value="60" class="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500">
                        </div>
                    </div>
                </div>
                
                <!-- Moderation Settings -->
                <div class="bg-gray-700 rounded-xl p-6">
                    <h3 class="text-xl font-bold mb-4 flex items-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                        </svg>
                        <span data-translate="moderationSettings">Настройки модерации</span>
                    </h3>
                    
                    <div class="space-y-4">
                        <div class="flex items-center justify-between">
                            <div>
                                <label class="text-sm font-medium" data-translate="autoModeration">Автомодерация</label>
                                <p class="text-xs text-gray-400" data-translate="autoModerationDesc">Автоматически модерировать подозрительные сообщения</p>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="autoModeration" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                            </label>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2" data-translate="timeoutDuration">Длительность тайм-аута (минуты)</label>
                            <select id="timeoutDuration" class="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500">
                                <option value="1">1 минута</option>
                                <option value="5">5 минут</option>
                                <option value="10" selected>10 минут</option>
                                <option value="30">30 минут</option>
                                <option value="60">1 час</option>
                            </select>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2" data-translate="bannedWords">Запрещенные слова (через запятую)</label>
                            <textarea id="bannedWords" placeholder="слово1, слово2, слово3" rows="3" class="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"></textarea>
                        </div>
                    </div>
                </div>
                
                <!-- Giveaway Settings -->
                <div class="bg-gray-700 rounded-xl p-6">
                    <h3 class="text-xl font-bold mb-4 flex items-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                        </svg>
                        <span data-translate="giveawaySettings">Настройки розыгрышей</span>
                    </h3>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium mb-2" data-translate="maxParticipants">Максимальное количество участников</label>
                            <input type="number" id="maxParticipants" min="1" max="10000" value="1000" class="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500">
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium mb-2" data-translate="minFollowDays">Минимальное время подписки (дни)</label>
                            <input type="number" id="minFollowDays" min="0" max="365" value="0" class="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-purple-500">
                            <p class="text-xs text-gray-400 mt-1" data-translate="minFollowDaysDesc">0 = без ограничений</p>
                        </div>
                        
                        <div class="flex items-center justify-between">
                            <div>
                                <label class="text-sm font-medium" data-translate="followersOnly">Только подписчики</label>
                                <p class="text-xs text-gray-400" data-translate="followersOnlyDesc">Разрешить участие только подписчикам</p>
                            </div>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="followersOnly" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Statistics & Data -->
                <div class="bg-gray-700 rounded-xl p-6">
                    <h3 class="text-xl font-bold mb-4 flex items-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M18 20V10"></path>
                            <path d="M12 20V4"></path>
                            <path d="M6 20v-6"></path>
                        </svg>
                        <span data-translate="statisticsAndData">Статистика и данные</span>
                    </h3>
                    
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        <div class="bg-gray-600 rounded-lg p-4 text-center">
                            <div class="text-2xl font-bold text-purple-400" id="totalGiveaways">0</div>
                            <div class="text-sm text-gray-400" data-translate="totalGiveaways">Всего розыгрышей</div>
                        </div>
                        <div class="bg-gray-600 rounded-lg p-4 text-center">
                            <div class="text-2xl font-bold text-green-400" id="totalWinners">0</div>
                            <div class="text-sm text-gray-400" data-translate="totalWinners">Всего победителей</div>
                        </div>
                        <div class="bg-gray-600 rounded-lg p-4 text-center">
                            <div class="text-2xl font-bold text-blue-400" id="totalParticipants">0</div>
                            <div class="text-sm text-gray-400" data-translate="totalParticipants">Всего участников</div>
                        </div>
                    </div>
                    
                    <div class="space-y-3">
                        <button id="exportDataBtn" class="w-full bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg transition-all duration-200 flex items-center justify-center space-x-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7,10 12,15 17,10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                            <span data-translate="exportData">Экспорт данных</span>
                        </button>
                        
                        <button id="clearAllDataBtn" class="w-full bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg transition-all duration-200 flex items-center justify-center space-x-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 6h18"></path>
                                <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                                <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                                <line x1="10" y1="11" x2="10" y2="17"></line>
                                <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                            <span data-translate="clearAllData">Очистить все данные</span>
                        </button>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="flex space-x-3">
                    <button id="saveChannelSettings" class="flex-1 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white px-6 py-3 rounded-lg transition-all duration-200 transform hover:scale-105 shadow-lg hover:shadow-xl relative overflow-hidden">
                        <span class="relative z-10" data-translate="saveChannelSettings">Сохранить настройки</span>
                        <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent transform -skew-x-12 translate-x-[-100%] transition-transform duration-700 hover:translate-x-[100%]"></div>
                    </button>
                    <button id="resetChannelSettings" class="bg-gray-600 hover:bg-gray-500 text-white px-6 py-3 rounded-lg transition-all duration-200" data-translate="resetChannelSettings">
                        Сброс
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Global Settings Modal (for all users) -->
    <div id="globalSettingsModal" class="fixed inset-0 bg-black bg-opacity-95 z-50 flex items-center justify-center p-4 hidden">
    <div class="bg-gradient-to-b from-gray-800 to-gray-900 rounded-2xl max-w-5xl w-full max-h-[90vh] overflow-y-auto p-8 neon-border relative shadow-2xl">
        
        <!-- Header с градиентом -->
        <div class="flex justify-between items-center mb-8 relative z-10 pb-6 border-b border-purple-500/30">
            <div class="flex items-center space-x-4">
                <div class="w-14 h-14 bg-gradient-to-r from-purple-600 to-pink-600 rounded-xl flex items-center justify-center shadow-lg">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="white">
                        <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/>
                    </svg>
                </div>
                <div>
                    <h2 class="text-3xl font-bold bg-gradient-to-r from-purple-400 via-pink-400 to-red-400 bg-clip-text text-transparent" data-translate="settingsTitle">⚙️ Настройки</h2>
                    <p class="text-sm text-gray-400 mt-1" data-translate="personalizeExperience">Персонализируйте ваш опыт</p>
                </div>
            </div>
            <button id="closeGlobalSettingsModal" class="text-gray-400 hover:text-white hover:bg-gray-700/50 p-2 rounded-lg transition-all duration-200 hover:scale-110 relative z-20">
                <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        
        <!-- Settings Content с сеткой -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 relative z-10">
            
            <!-- Interface Settings -->
            <div class="bg-gray-700/50 backdrop-blur-sm rounded-xl p-6 border border-purple-500/20 hover:border-purple-500/40 transition-all duration-300">
                <h3 class="text-lg font-bold mb-5 flex items-center space-x-2 text-purple-300">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM15 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2h-2zM5 13a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5z"/>
                    </svg>
                    <span>🎨 Интерфейс</span>
                </h3>
                
                <div class="space-y-4">
                    <!-- Checkboxes -->
                    <div class="flex items-center justify-between p-3 bg-gray-600/30 rounded-lg hover:bg-gray-600/50 transition-all">
                        <div>
                            <label class="text-sm font-medium">Скрыть ники участников</label>
                            <p class="text-xs text-gray-400 mt-1">Показывать *** вместо ников</p>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="hideUsernames" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                    
                    <div class="flex items-center justify-between p-3 bg-gray-600/30 rounded-lg hover:bg-gray-600/50 transition-all">
                        <div>
                            <label class="text-sm font-medium">Скрыть аватарки</label>
                            <p class="text-xs text-gray-400 mt-1">Показывать инициалы</p>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="hideAvatars" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                </div>
            </div>
            
            <!-- Language Settings -->
            <div class="bg-gray-700/50 backdrop-blur-sm rounded-xl p-6 border border-purple-500/20 hover:border-purple-500/40 transition-all duration-300">
                <h3 class="text-lg font-bold mb-5 flex items-center space-x-2 text-purple-300">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M5 20h14v-2H5v2zm0-4h14v-2H5v2zm0-4h14v-2H5v2zm0-4h14V8H5v2zm0-4h14V4H5v2z"/>
                    </svg>
                    
                    <span>🌎 Язык</span>
                </h3>
                
                <div class="flex flex-col space-y-3">
                    <button id="langEN" class="language-btn w-full px-4 py-3 rounded-lg border-2 border-gray-600 text-gray-300 hover:text-white hover:border-blue-400 bg-gray-600/30 hover:bg-gray-600/50 transition-all duration-200 flex items-center justify-start space-x-3 whitespace-nowrap">
            <svg class="w-5 h-4 flex-shrink-0" viewBox="0 0 513 342">
                <rect width="513" height="342" fill="#B22234"/>
                <g fill="#fff">
                    <rect width="513" height="26.31" y="0"/>
                    <rect width="513" height="26.31" y="52.62"/>
                    <rect width="513" height="26.31" y="105.24"/>
                    <rect width="513" height="26.31" y="157.86"/>
                    <rect width="513" height="26.31" y="210.48"/>
                    <rect width="513" height="26.31" y="263.1"/>
                    <rect width="513" height="26.31" y="315.72"/>
                </g>
                <rect width="256.5" height="184.14" fill="#3C3B6E"/>
            </svg>
            <span class="flex-1 text-left">English</span>
        </button>
        
        <!-- Russian -->
        <button id="langRU" class="language-btn w-full px-4 py-3 rounded-lg border-2 border-purple-500 bg-purple-600/50 text-white transition-all duration-200 flex items-center justify-start space-x-3 whitespace-nowrap">
            <svg class="w-5 h-4 flex-shrink-0" viewBox="0 0 900 600">
                <rect width="900" height="200" fill="#fff"/>
                <rect width="900" height="200" y="200" fill="#0039A6"/>
                <rect width="900" height="200" y="400" fill="#D52B1E"/>
            </svg>
            <span class="flex-1 text-left">Русский</span>
        </button>
        
        <!-- Ukrainian -->
        <button id="langUA" class="language-btn w-full px-4 py-3 rounded-lg border-2 border-gray-600 text-gray-300 hover:text-white hover:border-yellow-400 bg-gray-600/30 hover:bg-gray-600/50 transition-all duration-200 flex items-center justify-start space-x-3 whitespace-nowrap">
            <svg class="w-5 h-4 flex-shrink-0" viewBox="0 0 1200 800">
                <rect width="1200" height="400" fill="#0057B7"/>
                <rect width="1200" height="400" y="400" fill="#FFD700"/>
            </svg>
            <span class="flex-1 text-left">Українська</span>
        </button>
    </div>
</div>
            
            <!-- Privacy Settings -->
            <div class="bg-gray-700/50 backdrop-blur-sm rounded-xl p-6 border border-purple-500/20 hover:border-purple-500/40 transition-all duration-300 lg:col-span-2">
                <h3 class="text-lg font-bold mb-5 flex items-center space-x-2 text-purple-300">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                        <path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd"/>
                    </svg>
                    <span>⚠️ Конфиденциальность</span>
                </h3>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="flex items-center justify-between p-3 bg-gray-600/30 rounded-lg hover:bg-gray-600/50 transition-all">
                        <div>
                            <label class="text-sm font-medium">Скрыть мой ник</label>
                            <p class="text-xs text-gray-400 mt-1">В списках участников</p>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="hideMyUsername" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                    
                    <div class="flex items-center justify-between p-3 bg-gray-600/30 rounded-lg hover:bg-gray-600/50 transition-all">
                        <div>
                            <label class="text-sm font-medium">Отключить статистику</label>
                            <p class="text-xs text-gray-400 mt-1">Не сохранять участия</p>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="disableStatistics" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                    
                </div>
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="flex space-x-3 mt-8 pt-6 border-t border-purple-500/30 relative z-10">
            <button id="saveGlobalSettings" class="flex-1 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white px-6 py-3 rounded-lg transition-all duration-200 transform hover:scale-105 shadow-lg hover:shadow-xl relative overflow-hidden font-medium">
                <span class="relative z-10">💾 Сохранить</span>
                <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent transform -skew-x-12 translate-x-[-100%] transition-transform duration-700 hover:translate-x-[100%]"></div>
            </button>
            <button id="resetGlobalSettings" class="bg-gray-600 hover:bg-gray-500 text-white px-6 py-3 rounded-lg transition-all duration-200 font-medium">
                ↻ Сброс
            </button>
        </div>
    </div>
</div>
    </div>

    
    <div id="userManagementModal" class="fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4 hidden">
        <div class="bg-gray-800 rounded-xl max-w-7xl w-full max-h-[95vh] overflow-y-auto p-6 neon-border relative">
            <!-- Animated Background -->
            <div class="giveaway-bg">
                <!-- User Management Icons -->
                <div class="giveaway-icon">
                    <svg width="60" height="60" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 4c0-1.11.89-2 2-2s2 .89 2 2-.89 2-2 2-2-.89-2-2zm4 18v-6h2.5l-2.54-7.63A1.5 1.5 0 0 0 18.5 7h-1c-.83 0-1.5.67-1.5 1.5v6c0 .83.67 1.5 1.5 1.5H19v4h1z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="45" height="45" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="55" height="55" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.93 0 3.5 1.57 3.5 3.5S13.93 13 12 13s-3.5-1.57-3.5-3.5S10.07 6 12 6zm7 13H5v-.23c0-.62.28-1.2.76-1.58C7.47 15.82 9.64 15 12 15s4.53.82 6.24 2.19c.48.38.76.97.76 1.58V19z"/>
                    </svg>
                </div>
                <div class="giveaway-icon">
                    <svg width="50" height="50" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                    </svg>
                </div>
            </div>
            
            <div class="flex justify-between items-center mb-6 relative z-10">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-gradient-to-r from-blue-600 to-purple-600 rounded-full flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                    </div>
                    <div>
                        <h2 class="text-2xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">Управление пользователями</h2>
                        <p class="text-sm text-gray-400">Администрирование пользователей и стримеров</p>
                    </div>
                </div>
                <div class="hidden md:flex flex-col items-end bg-gray-700/40 border border-purple-500/30 rounded-lg px-4 py-2 shadow-inner">
                    <span class="text-xs uppercase tracking-wide text-gray-400" data-translate="adminIpLabel">Ваш IP</span>
                    <span id="adminCurrentIp" class="font-mono text-sm text-purple-200 mt-1">—</span>
                </div>
                <button id="closeUserManagementModal" class="text-gray-400 hover:text-white transition-all duration-200 hover:scale-110 relative z-20">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
            
            <!-- Tab Navigation -->
            <div class="flex space-x-1 bg-gray-700 rounded-lg p-1 mb-6 relative z-10">
                <button id="usersTab" class="flex-1 px-4 py-2 rounded-lg transition-all duration-200 bg-blue-600 text-white">
                    <div class="flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <span>Пользователи</span>
                    </div>
                </button>
                <button id="streamersTab" class="flex-1 px-4 py-2 rounded-lg transition-all duration-200 text-gray-300 hover:text-white hover:bg-gray-600">
                    <div class="flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="23 7 16 12 23 17 23 7"></polygon>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                        </svg>
                        <span>Стримеры</span>
                    </div>
                </button>
                <button id="notificationsTab" class="flex-1 px-4 py-2 rounded-lg transition-all duration-200 text-gray-300 hover:text-white hover:bg-gray-600">
                    <div class="flex items-center justify-center space-x-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                            <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
                        </svg>
                        <span>Уведомления</span>
                    </div>
                </button>
            </div>
            
            <!-- Users Tab Content -->
            <div id="usersContent" class="space-y-6 relative z-10">
                <!-- Search and Filters -->
                <div class="bg-gray-700 rounded-xl p-4">
                    <div class="flex flex-col md:flex-row gap-4">
                        <div class="flex-1">
                            <input type="text" id="userSearch" placeholder="🔍 Поиск по логину или ID..." class="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <button id="refreshUserIPsBtn" class="px-4 py-2 bg-purple-600 hover:bg-purple-500 text-white rounded-lg transition-all flex items-center gap-2 font-medium whitespace-nowrap">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="23 4 23 10 17 10"></polyline>
                                <polyline points="1 20 1 14 7 14"></polyline>
                                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                            </svg>
                            <span>Обновить данные</span>
                        </button>
                        <div class="flex gap-2">
                            <select id="userSortBy" class="bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="date">По дате входа</option>
                                <option value="login">По логину</option>
                                <option value="status">По статусу</option>
                            </select>
                            <select id="userFilterStatus" class="bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">Все статусы</option>
                                <option value="verified">Подтверждённые</option>
                                <option value="blocked">Заблокированные</option>
                                <option value="unverified">Неподтверждённые</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Users Table -->
                <div class="bg-gray-700 rounded-xl overflow-hidden">
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead class="bg-gray-600">
                                <tr>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Аватар</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Twitch логин</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">ID</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Дата входа</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">IP</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Статус</th>
                                    <th class="px-4 py-3 text-center text-sm font-medium text-gray-300">Действия</th>
                                </tr>
                            </thead>
                            <tbody id="usersTableBody" class="divide-y divide-gray-600">
                                <!-- Users will be populated here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Empty State -->
                    <div id="usersEmptyState" class="text-center py-8 text-gray-400 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-4 opacity-50">
                            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                            <circle cx="9" cy="7" r="4"></circle>
                            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                        </svg>
                        <p>Пользователи не найдены</p>
                    </div>
                </div>
            </div>
            
            <!-- Streamers Tab Content -->
            <div id="streamersContent" class="space-y-6 relative z-10 hidden">
                <!-- Streamers Stats -->
                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                    <div class="bg-gray-700 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-green-400" id="totalStreamers">0</div>
                        <div class="text-sm text-gray-400">Всего стримеров</div>
                    </div>
                    <div class="bg-gray-700 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-blue-400" id="activeStreamers">0</div>
                        <div class="text-sm text-gray-400">Стримят сейчас</div>
                    </div>
                    <div class="bg-gray-700 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-purple-400" id="totalStreamerGiveaways">0</div>
                        <div class="text-sm text-gray-400">Подписчиков</div>
                    </div>
                    <div class="bg-gray-700 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-orange-400" id="onlineStreamers">0</div>
                        <div class="text-sm text-gray-400">Средний онлайн</div>
                    </div>
                </div>
                
                <!-- Streamers Search -->
                <div class="bg-gray-700 rounded-xl p-4">
                    <div class="flex flex-col md:flex-row gap-4">
                        <div class="flex-1">
                            <input type="text" id="streamerSearch" placeholder="🔍 Поиск стримеров..." class="w-full bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div class="flex gap-2">
                            <select id="streamerSortBy" class="bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="status">По статусу</option>
                                <option value="followers">По подписчикам</option>
                                <option value="lastStream">По последнему стриму</option>
                                <option value="login">По логину</option>
                            </select>
                            <select id="streamerFilterActivity" class="bg-gray-600 border border-gray-500 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">Все</option>
                                <option value="streaming">🔴 Стримят сейчас</option>
                                <option value="offline">⚫ Не стримят</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Streamers Table -->
                <div class="bg-gray-700 rounded-xl overflow-hidden">
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead class="bg-gray-600">
                                <tr>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Стример</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Подписчики</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Последний стрим</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Средний онлайн</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Статус</th>
                                </tr>
                            </thead>
                            <tbody id="streamersTableBody" class="divide-y divide-gray-600">
                                <!-- Streamers will be populated here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Empty State -->
                    <div id="streamersEmptyState" class="text-center py-8 text-gray-400 hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="mx-auto mb-4 opacity-50">
                            <polygon points="23 7 16 12 23 17 23 7"></polygon>
                            <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                        </svg>
                        <p>Стримеры не найдены</p>
                    </div>
                </div>
            </div>
            
            <!-- Notifications Tab Content -->
            <div id="notificationsContent" class="space-y-6 relative z-10 hidden">
                <!-- Authorization Log -->
                <div class="bg-gray-700 rounded-xl p-6">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold flex items-center space-x-2">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14,2 14,8 20,8"></polyline>
                                <line x1="16" y1="13" x2="8" y2="13"></line>
                                <line x1="16" y1="17" x2="8" y2="17"></line>
                                <polyline points="10,9 9,9 8,9"></polyline>
                            </svg>
                            <span>Лог авторизаций</span>
                        </h3>
                        <div class="flex space-x-2">
                            <input type="date" id="logStartDate" class="bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <input type="date" id="logEndDate" class="bg-gray-600 border border-gray-500 rounded px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <button id="exportLogBtn" class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded text-sm transition-all duration-200">
                                📥 Экспорт
                            </button>
                        </div>
                    </div>
                    
                    <!-- Log Table -->
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead class="bg-gray-600">
                                <tr>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Дата</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Пользователь</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">Действие</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">IP адрес</th>
                                    <th class="px-4 py-3 text-left text-sm font-medium text-gray-300">User Agent</th>
                                </tr>
                            </thead>
                            <tbody id="authLogTableBody" class="divide-y divide-gray-600">
                                <!-- Log entries will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Server configuration (определяем ПЕРВЫМ, чтобы использовать в Twitch OAuth)
        // Автоматическое определение URL сервера - ВСЕГДА используем текущий URL
        const SERVER_URL = window.location.origin;
        const USE_SERVER = true; // Включить использование сервера
        
        // Twitch OAuth Configuration
        const TWITCH_CLIENT_ID = '95oaw6ivk75yzuwbjveaav3823a8bd';
        const TWITCH_SCOPES = ['chat:read', 'user:read:email', 'moderator:manage:banned_users', 'moderator:manage:chat_messages', 'moderator:read:chat_messages'];
        
        // Функция для получения redirect URI
        function getTwitchRedirectURI() {
            // ВСЕГДА используем текущий URL страницы для redirect URI
            // Это гарантирует правильную работу на любом хостинге
            const currentOrigin = window.location.origin;
            
            // Убираем trailing slash если есть, и добавляем один
            const baseUrl = currentOrigin.replace(/\/$/, '');
            const redirectURI = `${baseUrl}/`;
            
            console.log('[Twitch OAuth] Текущий origin:', currentOrigin);
            console.log('[Twitch OAuth] Redirect URI:', redirectURI);
            
            return redirectURI;
        }
        
        // Функция для получения auth URL
        function getTwitchAuthURL() {
            const redirectURI = getTwitchRedirectURI();
            return `https://id.twitch.tv/oauth2/authorize?client_id=${TWITCH_CLIENT_ID}&redirect_uri=${encodeURIComponent(redirectURI)}&response_type=token&scope=${TWITCH_SCOPES.join('+')}`;
        }
        
        // Twitch Auth URL будет генерироваться динамически при каждом клике
        // Это гарантирует использование актуального redirect URI
        function getCurrentTwitchAuthURL() {
            return getTwitchAuthURL();
        }

        // Twitch WebSocket Chat Connection
        let twitchWebSocket = null;
        let twitchChannel = null;

        // DOM Elements
        const authModal = document.getElementById('authModal');
        const twitchAuthBtn = document.getElementById('twitchAuthBtn');
        const dashboard = document.getElementById('dashboard');
        const usernameDisplay = document.getElementById('username');
        const streamerAvatar = document.getElementById('streamerAvatar');
        const disconnectBtn = document.getElementById('disconnectBtn');
        const chatContainer = document.getElementById('chatContainer');
        const viewerCount = document.getElementById('viewerCount');
        const newGiveawayBtn = document.getElementById('newGiveawayBtn');
        const giveawaysList = document.getElementById('giveawaysList');
        const winnersList = document.getElementById('winnersList');
        const newGiveawayModal = document.getElementById('newGiveawayModal');
        const closeGiveawayModal = document.getElementById('closeGiveawayModal');
        const cancelGiveawayBtn = document.getElementById('cancelGiveawayBtn');
        const createGiveawayBtn = document.getElementById('createGiveawayBtn');
        const winnerModal = document.getElementById('winnerModal');
        const winnerNames = document.getElementById('winnerNames');
        const closeWinnerModal = document.getElementById('closeWinnerModal');
        const rerollWinnerBtn = document.getElementById('rerollWinnerBtn');
        const winnerChatContainer = document.getElementById('winnerChatContainer');
        const winnerStatus = document.getElementById('winnerStatus');
        const winnerTimerDisplay = document.getElementById('winnerTimer');
        const winnerMessagesModal = document.getElementById('winnerMessagesModal');
        const winnerMessagesContent = document.getElementById('winnerMessagesContent');
        const winnerMessagesTitle = document.getElementById('winnerMessagesTitle');
        const closeWinnerMessagesModalBtn = document.getElementById('closeWinnerMessagesModal');
        const mobileActionBtn = document.getElementById('mobileActionBtn');
        const mobileMenu = document.getElementById('mobileMenu');
        const closeMobileMenu = document.getElementById('closeMobileMenu');
        const mobileNewGiveawayBtn = document.getElementById('mobileNewGiveawayBtn');
        const mobileDisconnectBtn = document.getElementById('mobileDisconnectBtn');
        const mobileUsername = document.getElementById('mobileUsername');
        const notificationsContainer = document.getElementById('notifications');
        const adminCurrentIpElement = document.getElementById('adminCurrentIp');

        // Utility function to escape HTML
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Utility function to format message text (preserve line breaks, escape HTML)
        function formatMessageText(text) {
            if (!text) return '';
            return escapeHtml(text).replace(/\n/g, '<br>');
        }
        
        // Логирование для отладки (при загрузке страницы)
        console.log('=== Twitch OAuth Configuration ===');
        console.log('SERVER_URL:', SERVER_URL);
        console.log('USE_SERVER:', USE_SERVER);
        console.log('Current URL:', window.location.href);
        console.log('Twitch Redirect URI:', getTwitchRedirectURI());
        console.log('===================================');
        
        // State
        let isAuthenticated = false;
        let currentUsername = '';
        let activeGiveaways = [];
        let recentWinners = [];
        let chatMessages = [];
        let userChatHistory = {};
        let userChatHistoryMeta = {};
        let accessToken = null;
        let fnFilterActive = false;
        let subscribersFilterActive = false;
        let currentUserId = null;
        let currentUserRealIP = null;
        let giveawayParticipants = {}; // Хранит участников для каждого розыгрыша
        let currentGiveawayForReroll = null; // Для функции перевыбора
        let currentWinners = []; // Текущие победители
        let winnerTimer = null; // Таймер для победителя
        let winnerTimeLeft = 60; // Время в секундах (1 минута)
        let winnerHasResponded = false; // Отвечал ли победитель
        const userIdCache = {};
        
        const storedVisitorIp = localStorage.getItem('visitor_real_ip');
        if (storedVisitorIp) {
            currentUserRealIP = storedVisitorIp;
        }
        
        function getChatHistoryStorageKey() {
            if (!twitchChannel) return null;
            return `by_CTPAX_chat_history_${twitchChannel}`;
        }
        
        function saveChatHistory() {
            try {
                const storageKey = getChatHistoryStorageKey();
                if (!storageKey) return;
                
                const serializable = {};
                Object.entries(userChatHistory).forEach(([username, messages]) => {
                    serializable[username] = messages.map(entry => ({
                        message: entry.message,
                        timestamp: entry.timestamp instanceof Date ? entry.timestamp.toISOString() : entry.timestamp,
                        color: entry.color,
                        userId: entry.userId || null,
                        messageId: entry.messageId || null
                    }));
                });
                
                localStorage.setItem(storageKey, JSON.stringify(serializable));
            } catch (error) {
                console.error('Ошибка сохранения истории сообщений:', error);
            }
        }
        
        function loadChatHistory() {
            try {
                const storageKey = getChatHistoryStorageKey();
                if (!storageKey) return;
                
                const stored = localStorage.getItem(storageKey);
                if (!stored) return;
                
                const parsed = JSON.parse(stored);
                
                // Merge with existing history instead of replacing
                // This ensures we don't lose any data that was added after initial load
                Object.entries(parsed).forEach(([username, messages]) => {
                    const storedMessages = Array.isArray(messages) ? messages.map(entry => ({
                        message: entry.message,
                        timestamp: entry.timestamp ? new Date(entry.timestamp) : new Date(),
                        color: entry.color || '#9146FF',
                        userId: entry.userId || null,
                        messageId: entry.messageId || null
                    })) : [];
                    
                    if (!userChatHistory[username]) {
                        userChatHistory[username] = [];
                    }
                    
                    // Merge stored messages, avoiding duplicates
                    const existingIds = new Set(userChatHistory[username].filter(entry => entry.messageId).map(entry => entry.messageId));
                    const existingMessages = new Set(userChatHistory[username].map(entry => {
                        const ts = entry.timestamp instanceof Date ? entry.timestamp.getTime() : new Date(entry.timestamp).getTime();
                        return `${entry.message}_${ts}`;
                    }));
                    
                    storedMessages.forEach(entry => {
                        const ts = entry.timestamp instanceof Date ? entry.timestamp.getTime() : new Date(entry.timestamp).getTime();
                        const messageKey = `${entry.message}_${ts}`;
                        
                        if ((!entry.messageId || !existingIds.has(entry.messageId)) && !existingMessages.has(messageKey)) {
                            userChatHistory[username].push(entry);
                            if (entry.messageId) {
                                existingIds.add(entry.messageId);
                            }
                            existingMessages.add(messageKey);
                        }
                    });
                    
                    // Sort by timestamp
                    userChatHistory[username].sort((a, b) => {
                        const timeA = a.timestamp instanceof Date ? a.timestamp.getTime() : new Date(a.timestamp).getTime();
                        const timeB = b.timestamp instanceof Date ? b.timestamp.getTime() : new Date(b.timestamp).getTime();
                        return timeA - timeB;
                    });
                    
                    if (userChatHistory[username].length > 0) {
                        const lower = username.toLowerCase();
                        const knownUserId = userChatHistory[username].find(entry => entry.userId)?.userId;
                        if (knownUserId) {
                            userIdCache[lower] = knownUserId;
                        }
                    }
                });
            } catch (error) {
                console.error('Ошибка загрузки истории сообщений:', error);
                // Don't clear existing history on error
            }
        }
        
        function getUserIdentityByUsername(username) {
            if (!username) return { userId: null };
            const lower = username.toLowerCase();
            if (userIdCache[lower]) {
                return { userId: userIdCache[lower] };
            }
            
            for (const participants of Object.values(giveawayParticipants)) {
                if (!Array.isArray(participants)) continue;
                const match = participants.find(entry => {
                    if (typeof entry === 'string') {
                        return entry.toLowerCase() === lower;
                    }
                    return entry && entry.username && entry.username.toLowerCase() === lower && entry.userId;
                });
                if (match) {
                    const userId = typeof match === 'string' ? null : match.userId || null;
                    if (userId) {
                        userIdCache[lower] = userId;
                        return { userId };
                    }
                }
            }
            
            const existingWinner = recentWinners.find(entry => entry.username && entry.username.toLowerCase() === lower && entry.userId);
            if (existingWinner && existingWinner.userId) {
                userIdCache[lower] = existingWinner.userId;
                return { userId: existingWinner.userId };
            }
            
            if (userChatHistory[username]) {
                const historyEntry = userChatHistory[username].find(entry => entry.userId);
                if (historyEntry && historyEntry.userId) {
                    userIdCache[lower] = historyEntry.userId;
                    return { userId: historyEntry.userId };
                }
            }
            
            return { userId: null };
        }
        
        async function ensureUserIdForUsername(username) {
            if (!username) return null;
            const lower = username.toLowerCase();
            if (userIdCache[lower]) return userIdCache[lower];
            if (!accessToken) return null;
            
            try {
                const response = await fetch(`https://api.twitch.tv/helix/users?login=${encodeURIComponent(lower)}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });
                
                if (!response.ok) {
                    console.warn('Не удалось получить userId по нику:', username, response.status);
                    return null;
                }
                
                const data = await response.json();
                if (data.data && data.data.length > 0) {
                    const user = data.data[0];
                    userIdCache[lower] = user.id;
                    return user.id;
                }
            } catch (error) {
                console.error('Ошибка получения userId по нику:', error);
            }
            return null;
        }
        
        async function fetchTwitchChatHistoryForUser(username, userId = null, maxPages = null) {
            if (!accessToken || !currentUserId) {
                throw new Error('Недостаточно прав для загрузки истории чата');
            }
            
            const lower = username.toLowerCase();
            let resolvedUserId = userId || userIdCache[lower];
            if (!resolvedUserId) {
                resolvedUserId = await ensureUserIdForUsername(username);
            }
            
            if (resolvedUserId) {
                userIdCache[lower] = resolvedUserId;
            }
            
            let cursor = null;
            let page = 0;
            const collected = [];
            
            // Загружаем все страницы без ограничений, если maxPages не указан
            // или до тех пор, пока API не вернет пустой результат
            // Это загружает ВСЕ сообщения пользователя за ВСЕ время на канале
            console.log(`Начало загрузки истории чата для ${username}${maxPages ? ` (макс. ${maxPages} страниц)` : ' (все страницы - за все время)'}`);
            
            while (maxPages === null || page < maxPages) {
                const params = new URLSearchParams({
                    broadcaster_id: currentUserId,
                    moderator_id: currentUserId,
                    first: '100'
                });
                
                if (resolvedUserId) {
                    params.append('user_id', resolvedUserId);
                } else {
                    params.append('user_login', lower);
                }
                
                if (cursor) {
                    params.append('after', cursor);
                }
                
                const response = await fetch(`https://api.twitch.tv/helix/moderation/chat?${params.toString()}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });
                
                if (response.status === 401 || response.status === 403) {
                    throw new Error('Недостаточно прав для чтения архива чата. Убедитесь, что вы модератор и выдали доступ к модерации.');
                }
                
                if (!response.ok) {
                    throw new Error(`Ошибка загрузки архива чата: ${response.status}`);
                }
                
                const data = await response.json();
                const batch = Array.isArray(data.data) ? data.data.map(entry => ({
                    message: entry.message && entry.message.text ? entry.message.text : '',
                    timestamp: entry.sent_at ? new Date(entry.sent_at) : new Date(),
                    color: entry.message && Array.isArray(entry.message.fragments) && entry.message.fragments.length > 0 && entry.message.fragments[0].color ? entry.message.fragments[0].color : '#9146FF',
                    userId: entry.user_id || resolvedUserId || null,
                    messageId: entry.message_id || null
                })) : [];
                
                collected.push(...batch);
                
                if (!resolvedUserId && batch.length > 0) {
                    const userIdFromBatch = batch.find(entry => entry.userId)?.userId;
                    if (userIdFromBatch) {
                        resolvedUserId = userIdFromBatch;
                        userIdCache[lower] = userIdFromBatch;
                    }
                }
                
                // Проверяем, есть ли еще данные для загрузки
                if (!data.pagination || !data.pagination.cursor) {
                    // Нет пагинации - значит все данные загружены
                    break;
                }
                
                // Если batch пустой, но есть пагинация - это странно, но продолжаем
                if (batch.length === 0) {
                    console.warn(`Пустой batch на странице ${page + 1} для пользователя ${username}`);
                    break;
                }
                
                cursor = data.pagination.cursor;
                page += 1;
                
                // Защита от бесконечного цикла (на всякий случай)
                if (page > 10000) {
                    console.warn(`Достигнут лимит страниц (10000) для пользователя ${username}. Загружено ${collected.length} сообщений.`);
                    break;
                }
                
                await new Promise(resolve => setTimeout(resolve, 350));
            }
            
            console.log(`Загрузка завершена для ${username}. Всего загружено: ${collected.length} сообщений за ${page} страниц`);
            return collected;
        }
        
        function mergeChatHistoryEntries(username, newEntries) {
            if (!username) return;
            
            // Всегда обновляем метаданные, даже если новых записей нет
            const lower = username.toLowerCase();
            
            if (!Array.isArray(newEntries) || newEntries.length === 0) {
                // Нет новых записей, но помечаем как загруженное
                userChatHistoryMeta[lower] = { ...(userChatHistoryMeta[lower] || {}), twitchFetched: true, fetchedAt: new Date() };
                saveChatHistory();
                return;
            }
            
            if (!userChatHistory[username]) {
                userChatHistory[username] = [];
            }
            
            const history = userChatHistory[username];
            const existingIds = new Set(history.filter(entry => entry.messageId).map(entry => entry.messageId));
            
            let addedCount = 0;
            newEntries.forEach(entry => {
                if (entry.messageId && existingIds.has(entry.messageId)) {
                    return;
                }
                history.push(entry);
                addedCount++;
            });
            
            if (addedCount > 0) {
                history.sort((a, b) => {
                    const timeA = a.timestamp instanceof Date ? a.timestamp.getTime() : new Date(a.timestamp).getTime();
                    const timeB = b.timestamp instanceof Date ? b.timestamp.getTime() : new Date(b.timestamp).getTime();
                    return timeA - timeB;
                });
            }
            
            userChatHistory[username] = history;
            userChatHistoryMeta[lower] = { ...(userChatHistoryMeta[lower] || {}), twitchFetched: true, fetchedAt: new Date(), totalFetched: (userChatHistoryMeta[lower]?.totalFetched || 0) + newEntries.length };
            saveChatHistory();
            
            console.log(`Загружено ${newEntries.length} сообщений для ${username}, добавлено ${addedCount} новых. Всего: ${history.length}`);
        }
        
        function renderWinnerMessages(username, locale) {
            if (!winnerMessagesContent) return;
            const history = userChatHistory[username] || [];
            
            winnerMessagesContent.innerHTML = '';
            
            if (history.length === 0) {
                const emptyState = document.createElement('div');
                emptyState.className = 'text-center text-gray-400 py-8';
                emptyState.textContent = t('noMessagesYet') || 'Сообщений не найдено';
                winnerMessagesContent.appendChild(emptyState);
                return;
            }
            
            history.forEach(entry => {
                const messageElement = document.createElement('div');
                messageElement.className = 'bg-gray-700 bg-opacity-70 border border-gray-600 rounded-lg p-3';
                const timestamp = entry.timestamp instanceof Date ? entry.timestamp : new Date(entry.timestamp);
                const timeText = timestamp.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' });
                const color = entry.color || '#9146FF';
                
                messageElement.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <span class="font-medium" style="color: ${color}">${username}</span>
                        <span class="text-xs text-gray-400">${timeText}</span>
                    </div>
                    <p class="text-gray-100 break-words">${entry.message}</p>
                `;
                
                winnerMessagesContent.appendChild(messageElement);
            });
        }
        
        // Global settings (for all users)
        let globalSettings = {
            hideUsernames: false,
            hideAvatars: false,
            language: 'ru',
            hideMyUsername: false,
            disableStatistics: false,
            registrationDate: '2025-07-06'
        };
        let currentUILanguage = globalSettings.language || 'ru';

        // Language translations
        const translations = {
            ru: {
                // Header
                title: 'Twitch Giveaways',
                settings: 'Настройки',
                disconnect: 'Отключить аккаунт',
                
                // Chat
                chatTitle: 'Чат стрима',
                viewers: 'зрителей',
                viewer: 'зритель',
                viewersPlural: 'зрителя',
                offline: 'Офлайн',
                
                // Giveaways
                activeGiveaways: 'Активные розыгрыши',
                newGiveaway: 'Новый розыгрыш',
                noActiveGiveaways: 'Нет активных розыгрышей',
                command: 'Команда',
                winners: 'Победителей',
                participants: 'участников',
                active: 'Активен',
                completed: 'Завершен',
                selectWinner: 'Выбрать победителя',
                end: 'Завершить',
                delete: 'Удалить',
                created: 'Создан',
                
                // Recent winners
                recentWinners: 'Последние победители',
                noWinners: 'Пока нет победителей',
                clearHistory: 'Очистить историю',
                
                // Modals
                newGiveawayTitle: 'Новый розыгрыш',
                giveawayName: 'Название розыгрыша',
                keyword: 'Ключевое слово',
                winnerCount: 'Количество победителей',
                cancel: 'Отмена',
                startGiveaway: '🎊 Начать розыгрыш',
                
                // Winner announcement
                winnersAnnouncement: 'Победители розыгрыша!',
                reroll: 'Перевыбрать',
                close: 'Закрыть',
                winnerChat: 'Чат победителя',
                waitingForWinner: 'Ожидание сообщений от победителя...',
                followButton: 'Подписка',
                viewMessages: 'Открыть на Twitch',
                messagesFrom: 'Сообщения пользователя',
                noMessagesYet: 'Сообщений не найдено',
                loadingMessages: 'Загрузка сообщений из архива...',
                chatHistoryUnavailable: 'Не удалось получить сообщения из архива Twitch',
                
                // Settings modal
                settingsTitle: 'Настройки',
                interfaceSettings: '🎨 Интерфейс',
                privacySettings: '⚠️ Конфиденциальность',
                otherSettings: '🧾 Прочее',
                hideUsernames: 'Скрыть ники участников',
                hideUsernamesDesc: 'Показывать ******* вместо настоящих ников',
                hideAvatars: 'Скрыть аватарки',
                hideAvatarsDesc: 'Показывать только инициалы пользователей',
                language: 'Язык интерфейса',
                hideMyUsername: 'Скрыть мой Twitch логин в списках участников',
                hideMyUsernameDesc: 'Другие пользователи не увидят ваш ник в розыгрышах',
                disableStatistics: 'Отключить статистику по участию',
                disableStatisticsDesc: 'Не сохранять данные о ваших участиях в розыгрышах',
                clearGiveawayHistory: 'Очистить историю розыгрышей',
                registrationDate: 'Дата регистрации на сайте',
                deleteAccount: 'Удалить аккаунт с сайта',
                reportBug: 'Сообщить об ошибке / предложить идею',
                saveSettings: 'Сохранить настройки',
                reset: 'Сброс',
                adminIpLabel: 'Ваш IP (админ)',
                adminIpUnknown: 'не удалось определить',
                
                // Notifications
                connected: 'Подключен к чату!',
                connectionLost: 'Соединение с чатом потеряно',
                chatError: 'Ошибка подключения к чату',
                settingsSaved: 'Настройки сохранены!',
                languageChanged: 'Язык изменен',
                dataCleared: 'Данные очищены',
                
                // Time
                justNow: 'только что',
                minuteAgo: 'минуту назад',
                minutesAgo: 'минут назад',
                hourAgo: 'час назад',
                hoursAgo: 'часов назад',
                dayAgo: 'день назад',
                daysAgo: 'дней назад',
                
                // Channel Settings Modal
                channelSettingsTitle: 'Настройки канала',
                channelSettingsSubtitle: 'Специальные настройки для владельца by_CTPAX',
                generalSettings: 'Общие настройки',
                autoAnnounceWinners: 'Автоматические объявления побед',
                autoAnnounceWinnersDesc: 'Автоматически объявлять победителей в чате',
                soundNotifications: 'Звуковые уведомления',
                soundNotificationsDesc: 'Воспроизводить звук при новых участниках',
                responseTimeout: 'Таймер ожидания ответа (секунды)',
                moderationSettings: 'Настройки модерации',
                autoModeration: 'Автомодерация',
                autoModerationDesc: 'Автоматически модерировать подозрительные сообщения',
                timeoutDuration: 'Длительность тайм-аута (минуты)',
                bannedWords: 'Запрещенные слова (через запятую)',
                giveawaySettings: 'Настройки розыгрышей',
                maxParticipants: 'Максимальное количество участников',
                minFollowDays: 'Минимальное время подписки (дни)',
                minFollowDaysDesc: '0 = без ограничений',
                followersOnly: 'Только подписчики',
                followersOnlyDesc: 'Разрешить участие только подписчикам',
                statisticsAndData: 'Статистика и данные',
                totalGiveaways: 'Всего розыгрышей',
                totalWinners: 'Всего победителей',
                totalParticipants: 'Всего участников',
                exportData: 'Экспорт данных',
                clearAllData: 'Очистить все данные',
                saveChannelSettings: 'Сохранить настройки',
                resetChannelSettings: 'Сброс',
                clearWinnersList: 'Очистить список победителей',
                
                // New Giveaway Modal
                giveawayNamePlaceholder: 'Например: Специальный дроп',
                keywordPlaceholder: 'drop',
                winner1: '1 победитель',
                winner3: '3 победителя',
                winner5: '5 победителей',
                winner10: '10 победителей',
                fnFilter: 'FN',
                fnFilterTitle: 'Только новые участники (пишут первый раз в чат)',
                subscribersFilter: 'Подписчики',
                subscribersFilterTitle: 'Только подписчики Twitch',
                
                // Global Settings
                personalizeExperience: 'Персонализируйте ваш опыт'
            },
            en: {
                // Header
                title: 'Twitch Giveaways',
                settings: 'Settings',
                disconnect: 'Disconnect account',
                
                // Chat
                chatTitle: 'Stream chat',
                viewers: 'viewers',
                viewer: 'viewer',
                viewersPlural: 'viewers',
                offline: 'Offline',
                
                // Giveaways
                activeGiveaways: 'Active giveaways',
                newGiveaway: 'New giveaway',
                noActiveGiveaways: 'No active giveaways',
                command: 'Command',
                winners: 'Winners',
                participants: 'participants',
                active: 'Active',
                completed: 'Completed',
                selectWinner: 'Select winner',
                end: 'End',
                delete: 'Delete',
                created: 'Created',
                
                // Recent winners
                recentWinners: 'Recent winners',
                noWinners: 'No winners yet',
                clearHistory: 'Clear history',
                
                // Modals
                newGiveawayTitle: 'New giveaway',
                giveawayName: 'Giveaway name',
                keyword: 'Keyword',
                winnerCount: 'Number of winners',
                cancel: 'Cancel',
                startGiveaway: '🎊 Start giveaway',
                
                // Winner announcement
                winnersAnnouncement: 'Giveaway winners!',
                reroll: '🎲 Reroll',
                close: 'Close',
                winnerChat: 'Winner chat',
                waitingForWinner: 'Waiting for winner messages...',
                followButton: 'Follow',
                viewMessages: 'Open on Twitch',
                messagesFrom: 'Messages from',
                noMessagesYet: 'No messages found',
                loadingMessages: 'Loading chat archive...',
                chatHistoryUnavailable: 'Unable to retrieve Twitch chat archive',
                
                // Settings modal
                settingsTitle: 'Settings',
                interfaceSettings: '🎨 Interface',
                privacySettings: '⚠️ Privacy',
                otherSettings: '🧾 Other',
                hideUsernames: 'Hide participant nicknames',
                hideUsernamesDesc: 'Show ******* instead of real nicknames',
                hideAvatars: 'Hide avatars',
                hideAvatarsDesc: 'Show only user initials',
                language: 'Interface language',
                hideMyUsername: 'Hide my Twitch login in participant lists',
                hideMyUsernameDesc: 'Other users will not see your nickname in giveaways',
                disableStatistics: 'Disable participation statistics',
                disableStatisticsDesc: 'Do not save data about your giveaway participation',
                clearGiveawayHistory: 'Clear giveaway history',
                registrationDate: 'Site registration date',
                deleteAccount: 'Delete account from site',
                reportBug: 'Report bug / suggest idea',
                saveSettings: 'Save settings',
                reset: 'Reset',
                adminIpLabel: 'Admin IP',
                adminIpUnknown: 'not detected',
                
                // Notifications
                connected: 'Connected to chat!',
                connectionLost: 'Chat connection lost',
                chatError: 'Chat connection error',
                settingsSaved: 'Settings saved!',
                languageChanged: 'Language changed',
                dataCleared: 'Data cleared',
                
                // Time
                justNow: 'just now',
                minuteAgo: 'a minute ago',
                minutesAgo: 'minutes ago',
                hourAgo: 'an hour ago',
                hoursAgo: 'hours ago',
                dayAgo: 'a day ago',
                daysAgo: 'days ago',
                
                // Channel Settings Modal
                channelSettingsTitle: 'Channel Settings',
                channelSettingsSubtitle: 'Special settings for owner by_CTPAX',
                generalSettings: 'General Settings',
                autoAnnounceWinners: 'Auto Announce Winners',
                autoAnnounceWinnersDesc: 'Automatically announce winners in chat',
                soundNotifications: 'Sound Notifications',
                soundNotificationsDesc: 'Play sound on new participants',
                responseTimeout: 'Response Timeout (seconds)',
                moderationSettings: 'Moderation Settings',
                autoModeration: 'Auto Moderation',
                autoModerationDesc: 'Automatically moderate suspicious messages',
                timeoutDuration: 'Timeout Duration (minutes)',
                bannedWords: 'Banned Words (comma separated)',
                giveawaySettings: 'Giveaway Settings',
                maxParticipants: 'Maximum Participants',
                minFollowDays: 'Minimum Follow Time (days)',
                minFollowDaysDesc: '0 = no restrictions',
                followersOnly: 'Followers Only',
                followersOnlyDesc: 'Allow participation only for followers',
                statisticsAndData: 'Statistics & Data',
                totalGiveaways: 'Total Giveaways',
                totalWinners: 'Total Winners',
                totalParticipants: 'Total Participants',
                exportData: 'Export Data',
                clearAllData: 'Clear All Data',
                saveChannelSettings: 'Save Settings',
                resetChannelSettings: 'Reset',
                clearWinnersList: 'Clear Winners List',
                
                // New Giveaway Modal
                giveawayNamePlaceholder: 'e.g.: Special Drop',
                keywordPlaceholder: 'drop',
                winner1: '1 winner',
                winner3: '3 winners',
                winner5: '5 winners',
                winner10: '10 winners',
                fnFilter: 'FN',
                fnFilterTitle: 'Only new participants (first time in chat)',
                subscribersFilter: 'Subscribers',
                subscribersFilterTitle: 'Twitch subscribers only',
                
                // Global Settings
                personalizeExperience: 'Personalize your experience'
            },
            ua: {
                // Header
                title: 'Twitch Розіграш',
                settings: 'Налаштування',
                disconnect: 'Відключити аккаунт',
                
                // Chat
                chatTitle: 'Чат стріму',
                viewers: 'глядачів',
                viewer: 'глядач',
                viewersPlural: 'глядача',
                offline: 'Офлайн',
                
                // Giveaways
                activeGiveaways: 'Активні розіграші',
                newGiveaway: 'Новий розіграш',
                noActiveGiveaways: 'Немає активних розіграшів',
                command: 'Команда',
                winners: 'Переможців',
                participants: 'учасників',
                active: 'Активний',
                completed: 'Завершено',
                selectWinner: 'Обрати переможця',
                end: 'Завершити',
                delete: 'Видалити',
                created: 'Створено',
                
                // Recent winners
                recentWinners: 'Останні переможці',
                noWinners: 'Поки немає переможців',
                clearHistory: 'Очистити історію',
                
                // Modals
                newGiveawayTitle: 'Новий розіграш',
                giveawayName: 'Назва розіграшу',
                keyword: 'Ключове слово',
                winnerCount: 'Кількість переможців',
                cancel: 'Скасувати',
                startGiveaway: '🎊 Почати розіграш',
                
                // Winner announcement
                winnersAnnouncement: 'Переможці розіграшу!',
                reroll: '🎲 Перевибрати',
                close: 'Закрити',
                winnerChat: 'Чат переможця',
                waitingForWinner: 'Очікування повідомлень від переможця...',
                followButton: 'Підписка',
                viewMessages: 'Відкрити на Twitch',
                messagesFrom: 'Повідомлення від',
                noMessagesYet: 'Повідомлень не знайдено',
                loadingMessages: 'Завантаження архіву повідомлень...',
                chatHistoryUnavailable: 'Не вдалося отримати архів повідомлень Twitch',
                
                // Settings modal
                settingsTitle: 'Налаштування',
                interfaceSettings: '🎨 Інтерфейс',
                privacySettings: '⚠️ Конфіденційність',
                otherSettings: '🧾 Інше',
                hideUsernames: 'Приховати ніки учасників',
                hideUsernamesDesc: 'Показувати ******* замість справжніх ніків',
                hideAvatars: 'Приховати аватарки',
                hideAvatarsDesc: 'Показувати тільки ініціали користувачів',
                language: 'Мова інтерфейсу',
                hideMyUsername: 'Приховати мій Twitch логін у списках учасників',
                hideMyUsernameDesc: 'Інші користувачі не побачать ваш нік у розіграшах',
                disableStatistics: 'Вимкнути статистику участі',
                disableStatisticsDesc: 'Не зберігати дані про ваші участі в розіграшах',
                clearGiveawayHistory: 'Очистити історію розіграшів',
                registrationDate: 'Дата реєстрації на сайті',
                deleteAccount: 'Видалити аккаунт з сайту',
                reportBug: 'Повідомити про помилку / запропонувати ідею',
                saveSettings: 'Зберегти налаштування',
                reset: 'Скинути',
                adminIpLabel: 'Ваш IP (адмін)',
                adminIpUnknown: 'не вдалося визначити',
                
                // Notifications
                connected: 'Підключено до чату!',
                connectionLost: 'З\'єднання з чатом втрачено',
                chatError: 'Помилка підключення до чату',
                settingsSaved: 'Налаштування збережено!',
                languageChanged: 'Мову змінено',
                dataCleared: 'Дані очищено',
                
                // Time
                justNow: 'щойно',
                minuteAgo: 'хвилину тому',
                minutesAgo: 'хвилин тому',
                hourAgo: 'годину тому',
                hoursAgo: 'годин тому',
                dayAgo: 'день тому',
                daysAgo: 'днів тому',
                
                // Channel Settings Modal
                channelSettingsTitle: 'Налаштування каналу',
                channelSettingsSubtitle: 'Спеціальні налаштування для власника by_CTPAX',
                generalSettings: 'Загальні налаштування',
                autoAnnounceWinners: 'Автоматичні оголошення переможців',
                autoAnnounceWinnersDesc: 'Автоматично оголошувати переможців у чаті',
                soundNotifications: 'Звукові сповіщення',
                soundNotificationsDesc: 'Відтворювати звук при нових учасниках',
                responseTimeout: 'Таймер очікування відповіді (секунди)',
                moderationSettings: 'Налаштування модерації',
                autoModeration: 'Автомодерація',
                autoModerationDesc: 'Автоматично модерувати підозрілі повідомлення',
                timeoutDuration: 'Тривалість тайм-ауту (хвилини)',
                bannedWords: 'Заборонені слова (через кому)',
                giveawaySettings: 'Налаштування розіграшів',
                maxParticipants: 'Максимальна кількість учасників',
                minFollowDays: 'Мінімальний час підписки (дні)',
                minFollowDaysDesc: '0 = без обмежень',
                followersOnly: 'Тільки підписники',
                followersOnlyDesc: 'Дозволити участь тільки підписникам',
                statisticsAndData: 'Статистика та дані',
                totalGiveaways: 'Всього розіграшів',
                totalWinners: 'Всього переможців',
                totalParticipants: 'Всього учасників',
                exportData: 'Експорт даних',
                clearAllData: 'Очистити всі дані',
                saveChannelSettings: 'Зберегти налаштування',
                resetChannelSettings: 'Скинути',
                clearWinnersList: 'Очистити список переможців',
                
                // New Giveaway Modal
                giveawayNamePlaceholder: 'Наприклад: Спеціальний дроп',
                keywordPlaceholder: 'drop',
                winner1: '1 переможець',
                winner3: '3 переможці',
                winner5: '5 переможців',
                winner10: '10 переможців',
                fnFilter: 'FN',
                fnFilterTitle: 'Тільки нові учасники (пишуть перший раз у чат)',
                subscribersFilter: 'Підписники',
                subscribersFilterTitle: 'Тільки підписники Twitch',
                
                // Global Settings
                personalizeExperience: 'Персоналізуйте ваш досвід'
            }
        };
        
        const translationIndex = {};
        const translationLanguages = Object.keys(translations);
        
        function buildTranslationIndex() {
            translationLanguages.forEach(lang => {
                translationIndex[lang] = translationIndex[lang] || {};
                const dictionary = translations[lang];
                Object.entries(dictionary).forEach(([key, value]) => {
                    if (typeof value !== 'string') return;
                    const normalized = normalizeTextValue(value);
                    if (!normalized) return;
                    if (!translationIndex[lang][normalized]) {
                        translationIndex[lang][normalized] = [];
                    }
                    if (!translationIndex[lang][normalized].includes(key)) {
                        translationIndex[lang][normalized].push(key);
                    }
                });
            });
        }
        
        function normalizeTextValue(text) {
            if (!text) return '';
            return text.replace(/\s+/g, ' ').trim();
        }
        
        function findTranslationKeyByText(text, currentLang) {
            const normalized = normalizeTextValue(text);
            if (!normalized) return null;
            
            const languagesToCheck = currentLang ? [currentLang, ...translationLanguages.filter(l => l !== currentLang)] : translationLanguages;
            for (const lang of languagesToCheck) {
                const possibleKeys = translationIndex[lang]?.[normalized];
                if (possibleKeys && possibleKeys.length > 0) {
                    return possibleKeys[0];
                }
            }
            return null;
        }
        
        function shouldSkipTranslationNode(node) {
            if (!node || !node.parentElement) return true;
            const skipSelectors = '#chatContainer, #winnerChatContainer, .chat-message, .winner-chat-message, [data-no-translate], .viewer-name, .message-text';
            if (node.parentElement.closest(skipSelectors)) return true;
            const parentTag = node.parentElement.tagName;
            if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'CODE', 'PRE', 'TEXTAREA'].includes(parentTag)) return true;
            if (/^\s*$/.test(node.textContent)) return true;
            if (!/[A-Za-zА-Яа-яЁёЇїІіЄєҐґ]/.test(node.textContent)) return true;
            return false;
        }
        
        function translateAllTextNodes(targetLang) {
            if (!translations[targetLang]) return;
            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT, null, false);
            while (walker.nextNode()) {
                const node = walker.currentNode;
                if (shouldSkipTranslationNode(node)) continue;
                
                const originalText = node.textContent;
                const key = node._i18nKey || findTranslationKeyByText(originalText, currentUILanguage);
                
                if (!key) continue;
                
                const newValue = translations[targetLang][key] || translations.ru[key];
                if (!newValue) continue;
                
                const leadingSpaces = originalText.match(/^\s*/)?.[0] || '';
                const trailingSpaces = originalText.match(/\s*$/)?.[0] || '';
                
                node.textContent = `${leadingSpaces}${newValue}${trailingSpaces}`;
                node._i18nKey = key;
            }
        }
        
        function translateElementAttributes(targetLang) {
            document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                const key = el.getAttribute('data-translate-placeholder');
                if (translations[targetLang][key]) {
                    el.setAttribute('placeholder', translations[targetLang][key]);
                }
            });
            
            document.querySelectorAll('[data-translate-title]').forEach(el => {
                const key = el.getAttribute('data-translate-title');
                if (translations[targetLang][key]) {
                    el.setAttribute('title', translations[targetLang][key]);
                }
            });
            
            // Обновляем опции select с data-translate
            document.querySelectorAll('select option[data-translate]').forEach(option => {
                const key = option.getAttribute('data-translate');
                if (translations[targetLang] && translations[targetLang][key]) {
                    option.textContent = translations[targetLang][key];
                }
            });
            
            // Обновляем элементы внутри span с data-translate (например, в кнопках)
            document.querySelectorAll('span[data-translate]').forEach(span => {
                const key = span.getAttribute('data-translate');
                if (translations[targetLang] && translations[targetLang][key]) {
                    // Сохраняем SVG и другие дочерние элементы, обновляем только текст
                    const svgElements = span.querySelectorAll('svg');
                    const textContent = translations[targetLang][key];
                    if (svgElements.length > 0) {
                        // Если есть SVG, заменяем только текстовые узлы
                        span.childNodes.forEach(node => {
                            if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                                node.textContent = textContent;
                            }
                        });
                    } else {
                        span.textContent = textContent;
                    }
                }
            });
        }
        
        buildTranslationIndex();

        // Get translation function
        function t(key) {
            const lang = globalSettings.language || 'ru';
            return translations[lang] && translations[lang][key] ? translations[lang][key] : translations.ru[key] || key;
        }
        
        function updateAdminIpDisplay(ip = null) {
            if (!adminCurrentIpElement) return;
            const value = (ip || currentUserRealIP || '').toString().trim();
            adminCurrentIpElement.textContent = value ? value : (t('adminIpUnknown') || '—');
        }
        updateAdminIpDisplay();
        
        // Apply language to interface
        function applyLanguageToInterface() {
    try {
        const lang = globalSettings.language || 'ru';
        currentUILanguage = lang;
        updateLanguageButtons(lang);
        
        // 1. ГЛАВНАЯ СТРАНИЦА
        const titleElement = document.querySelector('h1');
        if (titleElement) {
            titleElement.innerHTML = `<span class="bg-gradient-to-r from-purple-400 to-pink-500 bg-clip-text text-transparent">${t('title')}</span>`;
        }

        const settingsBtn = document.getElementById('globalSettingsBtn');
        if (settingsBtn) settingsBtn.title = t('settings');

        const disconnectBtn = document.getElementById('disconnectBtn');
        if (disconnectBtn) disconnectBtn.title = t('disconnect');

        // 2. ОКНА И МОДАЛИ
        // Обновляем ВСЕ модальные окна
        document.querySelectorAll('[id$="Modal"]').forEach(modal => {
            updateModalLanguage(modal);
        });

        // 3. КНОПКИ И ЭЛЕМЕНТЫ
        updateStaticTextElements();
        updateFormLabels();
        translateElementAttributes(lang);
        
        // Обновляем все элементы с data-translate
        document.querySelectorAll('[data-translate]').forEach(el => {
            const key = el.getAttribute('data-translate');
            if (key) {
                const translatedText = t(key);
                // Если элемент содержит SVG или другие дочерние элементы, обновляем только текстовые узлы
                if (el.querySelector('svg') || el.children.length > 0) {
                    el.childNodes.forEach(node => {
                        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
                            node.textContent = translatedText;
                        }
                    });
                } else {
                    el.textContent = translatedText;
                }
            }
        });
        
        translateAllTextNodes(lang);
        updateAdminIpDisplay();
        const adminIpLabelEl = document.querySelector('[data-translate="adminIpLabel"]');
        if (adminIpLabelEl) {
            adminIpLabelEl.textContent = t('adminIpLabel');
        }
        // 2. ОКНА И МОДАЛИ
document.querySelectorAll('[id$="Modal"]').forEach(modal => {
    updateModalLanguage(modal);
});

// 3. КНОПКИ И ЭЛЕМЕНТЫ
updateStaticTextElements();
updateFormLabels();

// НОВАЯ функция для обновления ВСЕХ элементов
function updateAllPageElements() {
    const lang = globalSettings.language || 'ru';
    
    // Обновляем ТОЛЬКО элементы, помеченные как переводимые
    document.querySelectorAll('[data-translate]').forEach(el => {
        const key = el.getAttribute('data-translate');
        if (key) {
            el.textContent = t(key);
        }
    });
    
    // Никаких замен текста по всему документу —
    // чат, ники и пользовательский контент остаются нетронутыми.
}

console.log(`✅ Язык изменен везде на: ${lang}`);
        


        console.log(`✅ Язык изменен везде на: ${lang}`);
    } catch (error) {
        console.error('❌ Ошибка применения языка:', error);
    }
}
function updateAllPageText() {
    const lang = globalSettings.language || 'ru';
    document.querySelectorAll('*').forEach(el => {
        if (
            el.children.length === 0 &&
            el.textContent.trim().length > 0 &&
            !el.closest('#chatContainer, #winnerChatContainer, .chat-message, #username, .viewer-name, .message-text, [data-no-translate]')
        ) {
            const text = el.textContent.trim();
            const translatedText = findTranslation(text);
            if (translatedText !== text && translatedText !== '') {
                el.textContent = translatedText;
            }
        }
    });
}

// НОВАЯ: Обновляет язык во всех модальных окнах
function updateModalLanguage(modal) {
    if (!modal) return;
    
    // Обновляем все заголовки в модале
    modal.querySelectorAll('h2, h3, h4').forEach(heading => {
        const text = heading.textContent.trim();
        const translatedText = findTranslation(text);
        if (translatedText !== text) {
            heading.textContent = translatedText;
        }
    });
    
    // Обновляем все лейблы
    modal.querySelectorAll('label').forEach(label => {
        const text = label.textContent.trim();
        const translatedText = findTranslation(text);
        if (translatedText !== text) {
            label.textContent = translatedText;
        }
    });
    
    // Обновляем все плейсхолдеры
    modal.querySelectorAll('[placeholder]').forEach(el => {
        const placeholder = el.getAttribute('placeholder');
        const translatedPlaceholder = findTranslation(placeholder);
        if (translatedPlaceholder !== placeholder) {
            el.setAttribute('placeholder', translatedPlaceholder);
        }
    });
    
    // Обновляем все текстовые кнопки
    modal.querySelectorAll('button').forEach(btn => {
        if (btn.textContent.trim()) {
            const text = btn.textContent.trim();
            const translatedText = findTranslation(text);
            if (translatedText !== text) {
                btn.textContent = translatedText;
            }
        }
    });
}

// НОВАЯ: Ищет перевод по русскому тексту
function findTranslation(text) {
    const lang = globalSettings.language || 'ru';
    
    // Словарь соответствия текста и ключей переводов
    const textToKey = {
        // Создание розыгрыша
        'Создать розыгрыш': 'newGiveaway',
        'Название розыгрыша': 'giveawayName',
        'Призовой фонд': 'prizePool',
        'Количество победителей': 'winnersCount',
        'Создать': 'create',
        'Отмена': 'cancel',
        
        // Окна
        'Активные розыгрыши': 'activeGiveaways',
        'Последние победители': 'recentWinners',
        
        // Кнопки
        'Сохранить': 'save',
        'Закрыть': 'close',
        'Удалить': 'delete',
        'Подтвердить': 'confirm',
        
        // По умолчанию
        'Create Giveaway': 'newGiveaway',
        'Active Giveaways': 'activeGiveaways',
        'Recent Winners': 'recentWinners',
    };
    
    const key = textToKey[text.trim()];
    return key ? t(key) : text;
}

// НОВАЯ: Обновляет ВСЕ текстовые элементы на странице
function updateAllPageText() {
    const lang = globalSettings.language || 'ru';
    
    // Ищем все элементы с текстом и пытаемся их перевести
    document.querySelectorAll('*').forEach(el => {
        if (el.children.length === 0 && el.textContent.trim().length > 0) {
            // Это элемент без дочерних узлов (листовой узел)
            const text = el.textContent.trim();
            const translatedText = findTranslation(text);
            
            if (translatedText !== text && translatedText !== '') {
                el.textContent = translatedText;
            }
        }
    });
}

// НОВАЯ функция для обновления ВСЕХ элементов
function updateAllPageElements() {
    const lang = globalSettings.language || 'ru';
    
    
    // Обновляем ВСЕ элементы по дата-атрибутам
    document.querySelectorAll('[data-translate]').forEach(el => {
        const key = el.getAttribute('data-translate');
        if (key) {
            el.textContent = t(key);
        }
    });
    
    // Обновляем ВСЕ текстовые узлы (более агрессивный подход)
    const walker = document.createTreeWalker(
        document.body,
        NodeFilter.SHOW_TEXT,
        null,
        false
    );
    
    const knownStrings = {
        'Чат': t('chatTitle'),
        'Chat': t('chatTitle'),
        'стріму': t('chatTitle'),
        'Активные розыгрыши': t('activeGiveaways'),
        'Active Giveaways': t('activeGiveaways'),
        'Активні розіграші': t('activeGiveaways'),
        'Последние победители': t('recentWinners'),
        'Recent Winners': t('recentWinners'),
        'Останні переможці': t('recentWinners'),
    };
    
    Object.entries(knownStrings).forEach(([oldText, newText]) => {
        document.querySelectorAll('*').forEach(el => {
            if (el.childNodes.length > 0) {
                el.childNodes.forEach(node => {
                    if (node.nodeType === Node.TEXT_NODE && node.textContent.includes(oldText)) {
                        node.textContent = node.textContent.replace(oldText, newText);
                    }
                });
            }
        });
    });
}

        // Update static text elements
        function updateStaticTextElements() {
            // Settings modal sections - используем правильный поиск по содержимому
            const allSpans = document.querySelectorAll('#globalSettingsModal span');
            
            allSpans.forEach(span => {
                const text = span.textContent.trim();
                if (text.includes('🎨')) {
                    span.textContent = t('interfaceSettings');
                } else if (text.includes('⚠️')) {
                    span.textContent = t('privacySettings');
                } else if (text.includes('🧾')) {
                    span.textContent = t('otherSettings');
                }
            });

            // Update labels and descriptions
            updateFormLabels();
        }

        // Update form labels
        function updateFormLabels() {
            try {
                // Settings form elements - используем более безопасный поиск
                const settingsModal = document.getElementById('globalSettingsModal');
                if (!settingsModal) return;

                // Обновляем чекбоксы и их описания
                const checkboxContainers = settingsModal.querySelectorAll('.flex.items-center.justify-between');
                checkboxContainers.forEach(container => {
                    const checkbox = container.querySelector('input[type="checkbox"]');
                    const label = container.querySelector('label');
                    const desc = container.querySelector('.text-xs.text-gray-400');
                    
                    if (checkbox && label) {
                        const checkboxId = checkbox.id;
                        switch(checkboxId) {
                            case 'hideUsernames':
                                label.textContent = t('hideUsernames');
                                if (desc) desc.textContent = t('hideUsernamesDesc');
                                break;
                            case 'hideAvatars':
                                label.textContent = t('hideAvatars');
                                if (desc) desc.textContent = t('hideAvatarsDesc');
                                break;
                            case 'hideMyUsername':
                                label.textContent = t('hideMyUsername');
                                if (desc) desc.textContent = t('hideMyUsernameDesc');
                                break;
                            case 'disableStatistics':
                                label.textContent = t('disableStatistics');
                                if (desc) desc.textContent = t('disableStatisticsDesc');
                                break;
                        }
                    }
                });

                // Обновляем кнопки
                const saveBtn = document.getElementById('saveGlobalSettings');
                if (saveBtn) {
                    const span = saveBtn.querySelector('span');
                    if (span) span.textContent = t('saveSettings');
                }

                const resetBtn = document.getElementById('resetGlobalSettings');
                if (resetBtn) resetBtn.textContent = t('reset');

                const clearHistoryBtn = document.getElementById('clearGiveawayHistory');
                if (clearHistoryBtn) {
                    const span = clearHistoryBtn.querySelector('span');
                    if (span) span.textContent = t('clearGiveawayHistory');
                }

                const deleteAccountBtn = document.getElementById('deleteAccountBtn');
                if (deleteAccountBtn) {
                    const span = deleteAccountBtn.querySelector('span');
                    if (span) span.textContent = t('deleteAccount');
                }

                const reportBugBtn = document.getElementById('reportBugBtn');
                if (reportBugBtn) {
                    const span = reportBugBtn.querySelector('span');
                    if (span) span.textContent = t('reportBug');
                }

                // Обновляем селектор языка
                const langLabel = settingsModal.querySelector('label[for="language"]');
                if (langLabel) langLabel.textContent = t('language');

                // Обновляем дату регистрации
                const allLabels = settingsModal.querySelectorAll('label');
                allLabels.forEach(label => {
                    if (label.textContent.includes('регистрации') || label.textContent.includes('registration') || label.textContent.includes('реєстрації')) {
                        label.textContent = t('registrationDate');
                    }
                });

            } catch (error) {
                console.error('Ошибка обновления форм:', error);
            }
        }
        
       
        let channelSettings = {
            autoAnnounce: true,
            soundNotifications: false,
            responseTimeout: 60,
            autoModeration: false,
            timeoutDuration: 10,
            bannedWords: [],
            maxParticipants: 1000,
            minFollowDays: 0,
            followersOnly: false
        };
        
        // Check if current user is by_CTPAX
        let isby_CTPAX = false;
        
        function updateOwnerIpInSystem(newIp) {
            if (!isby_CTPAX || !newIp) return;
            const ownerLogin = (currentUsername || '').toLowerCase();
            let changed = false;
            
            registeredUsers = registeredUsers.map(user => {
                const isOwner = user.userType === 'owner' || (ownerLogin && user.login && user.login.toLowerCase() === ownerLogin);
                if (isOwner && user.ipAddress !== newIp) {
                    user.ipAddress = newIp;
                    changed = true;
                }
                return user;
            });
            
            authorizationLog = authorizationLog.map(entry => {
                const entryLogin = (entry.username || '').toLowerCase();
                if (entry.userId === 'by_CTPAX_owner' || (ownerLogin && entryLogin === ownerLogin)) {
                    entry.ipAddress = newIp;
                }
                return entry;
            });
            
            if (changed) {
                saveUserManagementData();
            }
        }
        
        // User management data
        let registeredUsers = [];
        let registeredStreamers = [];
        let authorizationLog = [];
        let notificationSettings = {
            newStreamerNotifications: true,
            emailReports: false,
            discordNotifications: false,
            reportEmail: '',
            discordWebhook: ''
        };
        
        // User management UI settings
        let userManagementSettings = {
            // Users tab
            userSearch: '',
            userSortBy: 'date',
            userFilterStatus: 'all',
            // Streamers tab  
            streamerSearch: '',
            streamerSortBy: 'activity',
            streamerFilterActivity: 'all',
            // Notifications tab
            logStartDate: '',
            logEndDate: '',
            // Active tab
            activeTab: 'users'
        };

        // Notification System
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `px-4 py-3 rounded-lg text-white font-medium ${type === 'success' ? 'success-message' : type === 'error' ? 'error-message' : 'bg-blue-600'} slide-in`;
            notification.textContent = message;
            
            notificationsContainer.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 4000);
        }

        // Флаги для предотвращения повторных вызовов
        let isFetchingUserInfo = false;
        let cachedIP = null;
        let isFetchingIP = false;
        let hasRegisteredAuth = false; // Флаг для регистрации при авторизации
        
        // Check for OAuth token in URL hash
        function checkAuth() {
            // Предотвращаем повторные вызовы
            if (isFetchingUserInfo || isAuthenticated) {
                return;
            }
            
            const hash = window.location.hash.substring(1);
            const params = new URLSearchParams(hash);
            const token = params.get('access_token');
            
            if (token) {
                // Store token and remove from URL
                localStorage.setItem('twitch_access_token', token);
                
                // Если мы на порту 5500 (локальная разработка с Live Server), редиректим на правильный порт
                // Но только для localhost, не для продакшена
                if (USE_SERVER && window.location.host.includes(':5500') && window.location.hostname === 'localhost') {
                    console.log('Редиректим с порта 5500 на 3000...');
                    window.location.href = `http://localhost:3000/#access_token=${token}`;
                    return;
                }
                
                // Для продакшена или правильного порта - обрабатываем токен здесь
                // Очищаем hash, но сохраняем остальной URL
                const currentUrl = window.location.href.split('#')[0];
                window.history.replaceState(null, '', currentUrl);
                
                console.log('Токен получен, загружаем информацию о пользователе...');
                console.log('Текущий URL:', window.location.href);
                console.log('SERVER_URL:', SERVER_URL);
                
                // Get user info
                fetchUserInfo(token);
            } else {
                // Check for stored token
                const storedToken = localStorage.getItem('twitch_access_token');
                if (storedToken) {
                    fetchUserInfo(storedToken);
                } else {
                    // Show auth modal
                    authModal.classList.remove('hidden');
                }
            }
        }

        // Fetch user info from Twitch API
async function fetchUserInfo(token) {
    // Предотвращаем повторные вызовы
    if (isFetchingUserInfo) {
        console.log('fetchUserInfo уже выполняется, пропускаем');
        return;
    }
    
    if (isAuthenticated) {
        console.log('Пользователь уже авторизован, пропускаем');
        return;
    }
    
    isFetchingUserInfo = true;
    
    try {
        const response = await fetch('https://api.twitch.tv/helix/users', {
            headers: {
                'Authorization': `Bearer ${token}`,
                'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
            }
        });
        
        if (!response.ok) {
            throw new Error('Failed to fetch user info');
        }
        
        const data = await response.json();
        
        if (data.data && data.data.length > 0) {
            const user = data.data[0];
            currentUsername = user.display_name;
            twitchChannel = user.login; // Имя канала в нижнем регистре
            accessToken = token;
            currentUserId = user.id;
            if (currentUsername) {
                userIdCache[currentUsername.toLowerCase()] = user.id;
            }
            if (twitchChannel) {
                userIdCache[twitchChannel.toLowerCase()] = user.id;
            }
            
            // Check if user is by_CTPAX
            isby_CTPAX = checkIfby_CTPAX(user.login);
            // Mute logs for non-owner sessions
if (!isby_CTPAX) {
    console.log = () => {};
    console.info = () => {};
    console.warn = () => {};
    // If you want absolutely nothing in console, also uncomment:
    // console.error = () => {};
}
            
            // Устанавливаем флаг авторизации ДО всех асинхронных операций
            isAuthenticated = true;
            
            // Hide auth modal and show dashboard
            console.log('Скрываем модальное окно авторизации и показываем дашборд');
            if (authModal) {
                authModal.classList.add('hidden');
                console.log('Модальное окно авторизации скрыто');
            } else {
                console.error('Элемент authModal не найден!');
            }
            if (dashboard) {
                dashboard.classList.remove('hidden');
                console.log('Дашборд показан');
            } else {
                console.error('Элемент dashboard не найден!');
            }
            
            // Очищаем кэш, если там локальный IP
            const savedIP = localStorage.getItem('visitor_real_ip');
            if (savedIP && (savedIP === '127.0.0.1' || savedIP === '::1' || 
                savedIP.startsWith('192.168.') || savedIP.startsWith('10.') ||
                (savedIP.startsWith('172.') && parseInt(savedIP.split('.')[1]) >= 16 && 
                 parseInt(savedIP.split('.')[1]) <= 31))) {
                // Очищаем локальный IP из кэша
                cachedIP = null;
                localStorage.removeItem('visitor_real_ip');
                console.log('Очищен локальный IP из кэша:', savedIP);
            }
            
            // Получаем IP только один раз при авторизации
            if (!cachedIP && !hasRegisteredAuth) {
                hasRegisteredAuth = true; // Устанавливаем флаг сразу
                console.log('Получение публичного IP адреса...');
                fetchVisitorIP().then(async ip => {
                    if (ip && ip !== '127.0.0.1' && ip !== '::1' && 
                        !ip.startsWith('192.168.') && !ip.startsWith('10.') &&
                        !(ip.startsWith('172.') && parseInt(ip.split('.')[1]) >= 16 && 
                          parseInt(ip.split('.')[1]) <= 31)) {
                        localStorage.setItem('visitor_real_ip', ip);
                        currentUserRealIP = ip;
                        cachedIP = ip; // Обновляем кэш
                        updateAdminIpDisplay(ip);
                        if (typeof isby_CTPAX !== 'undefined' && isby_CTPAX) {
                            updateOwnerIpInSystem(ip);
                        }
                        // Регистрируем посетителя на сервере (только один раз при авторизации)
                        if (currentUsername && twitchChannel) {
                            await registerVisitor(currentUsername, currentUserId, twitchChannel, 'auth').catch(err => {
                                console.warn('Не удалось зарегистрировать посетителя:', err);
                            });
                        }
                    } else {
                        console.warn('Получен локальный IP, пропускаем:', ip);
                        updateAdminIpDisplay();
                    }
                }).catch(err => {
                    console.warn('Ошибка получения IP (не критично):', err);
                    updateAdminIpDisplay();
                });
            } else {
                // Если IP уже есть и он публичный, просто обновляем отображение
                if (cachedIP && cachedIP !== '127.0.0.1' && cachedIP !== '::1' && 
                    !cachedIP.startsWith('192.168.') && !cachedIP.startsWith('10.') &&
                    !(cachedIP.startsWith('172.') && parseInt(cachedIP.split('.')[1]) >= 16 && 
                      parseInt(cachedIP.split('.')[1]) <= 31)) {
                    updateAdminIpDisplay(cachedIP);
                    if (typeof isby_CTPAX !== 'undefined' && isby_CTPAX) {
                        updateOwnerIpInSystem(cachedIP);
                    }
                } else {
                    // Если сервер отключен, пытаемся получить IP из localStorage
                    const savedIP = localStorage.getItem('visitor_real_ip');
                    if (savedIP && savedIP !== '127.0.0.1' && savedIP !== '::1' && 
                        !savedIP.startsWith('192.168.') && !savedIP.startsWith('10.') &&
                        !(savedIP.startsWith('172.') && parseInt(savedIP.split('.')[1]) >= 16 && 
                          parseInt(savedIP.split('.')[1]) <= 31)) {
                        currentUserRealIP = savedIP;
                        updateAdminIpDisplay(savedIP);
                        if (typeof isby_CTPAX !== 'undefined' && isby_CTPAX) {
                            updateOwnerIpInSystem(savedIP);
                        }
                    } else {
                        updateAdminIpDisplay();
                    }
                }
            }
            
            // Update UI
            usernameDisplay.textContent = currentUsername;
            mobileUsername.textContent = `Подключен как: ${currentUsername}`;
            updateConnectionStatus(true);
            
            // Show by_CTPAX indicator if applicable
            if (isby_CTPAX) {
                usernameDisplay.innerHTML = `${currentUsername} <span class="text-xs bg-gradient-to-r from-purple-600 to-pink-600 text-white font-bold px-2 py-1 rounded-full ml-2 shadow-lg shadow-purple-500/50">ВЛАДЕЛЕЦ</span>`;
                
                // Load settings first, then initialize data with longer delay
                setTimeout(() => {
                    // Убираем консольное сообщение для безопасности
                    loadChannelSettings();
                    initializeUserManagementData();
                }, 500);
            }
            
            if (isby_CTPAX && currentUserRealIP) {
                updateOwnerIpInSystem(currentUserRealIP);
            }
            
            // Load streamer avatar
            loadStreamerAvatar(user.profile_image_url, currentUsername);
            
            // Show success notification
            showNotification(`Добро пожаловать, ${currentUsername}!`, 'success');
            
            // Получаем полную информацию о пользователе через Twitch API
            // Это нужно сделать асинхронно, чтобы получить все данные
            (async () => {
                try {
                    // Получаем информацию о подписчиках (если это стример)
                    let followerCount = 0;
                    if (user.broadcaster_type && user.broadcaster_type !== '') {
                        try {
                            const followResponse = await fetch(`https://api.twitch.tv/helix/channels/followers?broadcaster_id=${currentUserId}&first=1`, {
                                headers: {
                                    'Authorization': `Bearer ${token}`,
                                    'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                                }
                            });
                            if (followResponse.ok) {
                                const followData = await followResponse.json();
                                followerCount = followData.total || 0;
                            }
                        } catch (err) {
                            console.warn('Не удалось получить количество подписчиков:', err);
                        }
                    }
                    
                    // Добавляем текущего пользователя в систему с полными данными
                    await addUserToSystem(currentUsername, {
                        id: currentUserId,
                        login: user.login || currentUsername.toLowerCase(),
                        displayName: user.display_name || currentUsername,
                        avatarUrl: user.profile_image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(currentUsername)}&background=9146FF&color=fff&size=50`,
                        joinDate: user.created_at ? new Date(user.created_at) : new Date(),
                        lastSeen: new Date(),
                        ipAddress: currentUserRealIP || null,
                        userType: isby_CTPAX ? 'owner' : (user.broadcaster_type && user.broadcaster_type !== '' ? 'streamer' : 'viewer'),
                        status: 'verified',
                        followerCount: followerCount,
                        giveawayCount: 0
                    });
                } catch (error) {
                    console.error('Ошибка при добавлении пользователя в систему:', error);
                    // Fallback: добавляем с базовыми данными
                    await addUserToSystem(currentUsername, {
                        id: currentUserId || Date.now().toString(),
                        login: user.login || currentUsername.toLowerCase(),
                        displayName: user.display_name || currentUsername,
                        avatarUrl: user.profile_image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(currentUsername)}&background=9146FF&color=fff&size=50`,
                        joinDate: new Date(),
                        lastSeen: new Date(),
                        ipAddress: currentUserRealIP || null,
                        userType: isby_CTPAX ? 'owner' : 'viewer',
                        status: 'verified',
                        followerCount: 0,
                        giveawayCount: 0
                    });
                }
            })();
            
            // Initialize demo data
            initializeDemoData();
            
            // Connect to real Twitch chat
            connectToTwitchChat();
        } else {
            throw new Error('No user data received');
        }
    } catch (error) {
        console.error('Error fetching user info:', error);
        showNotification('Ошибка при получении данных пользователя', 'error');
        localStorage.removeItem('twitch_access_token');
        authModal.classList.remove('hidden');
        dashboard.classList.add('hidden');
    } finally {
        isFetchingUserInfo = false;
    }
}

        // Load saved data from localStorage
        function loadSavedData() {
            try {
                // Load recent winners
                const savedWinners = localStorage.getItem(`by_CTPAX_winners_${twitchChannel}`);
                if (savedWinners) {
                    recentWinners = JSON.parse(savedWinners);
                    
                    // Convert time strings back to Date objects for existing winners
                    recentWinners.forEach(winner => {
                        if (winner.time && typeof winner.time === 'string' && winner.time !== 'только что') {
                            try {
                                winner.time = new Date(winner.time);
                            } catch (e) {
                                winner.time = new Date(); // Fallback to current date
                            }
                        } else if (!winner.time || winner.time === 'только что') {
                            winner.time = new Date(); // Set current date for old entries
                        }
                    });
                    
                    console.log('Загружены сохраненные победители:', recentWinners.length);
                }
                
                // Load active giveaways
                const savedGiveaways = localStorage.getItem(`by_CTPAX_giveaways_${twitchChannel}`);
                if (savedGiveaways) {
                    activeGiveaways = JSON.parse(savedGiveaways);
                    
                    // Convert startTime strings back to Date objects
                    activeGiveaways.forEach(giveaway => {
                        if (giveaway.startTime && typeof giveaway.startTime === 'string') {
                            try {
                                giveaway.startTime = new Date(giveaway.startTime);
                            } catch (e) {
                                giveaway.startTime = new Date(); // Fallback to current date
                            }
                        }
                    });
                    
                    console.log('Загружены сохраненные розыгрыши:', activeGiveaways.length);
                }
                
                // Load giveaway participants
                const savedParticipants = localStorage.getItem(`by_CTPAX_participants_${twitchChannel}`);
                if (savedParticipants) {
                    giveawayParticipants = JSON.parse(savedParticipants);
                    console.log('Загружены сохраненные участники');
                }
                
                loadChatHistory();
                
                showNotification('Данные загружены из памяти', 'success');
            } catch (error) {
                console.error('Ошибка загрузки сохраненных данных:', error);
                // Reset to empty if error
                recentWinners = [];
                activeGiveaways = [];
                giveawayParticipants = {};
            }
        }

        // Debounce для saveData
        let saveDataTimeout = null;
        let lastSaveDataTime = 0;
        const SAVE_DATA_DEBOUNCE = 2000; // Минимум 2 секунды между сохранениями на сервер
        
        // Save data to localStorage
        function saveData() {
            if (!twitchChannel) return;
            
            try {
                // Save recent winners
                localStorage.setItem(`by_CTPAX_winners_${twitchChannel}`, JSON.stringify(recentWinners));
                
                // Save active giveaways
                localStorage.setItem(`by_CTPAX_giveaways_${twitchChannel}`, JSON.stringify(activeGiveaways));
                
                // Save giveaway participants
                localStorage.setItem(`by_CTPAX_participants_${twitchChannel}`, JSON.stringify(giveawayParticipants));
                
                saveChatHistory();
                
                console.log('Данные сохранены в localStorage');
                
                // Отправляем на сервер с debounce (не блокируем работу при ошибке)
                if (USE_SERVER) {
                    const now = Date.now();
                    if (now - lastSaveDataTime < SAVE_DATA_DEBOUNCE) {
                        // Отменяем предыдущий таймер и устанавливаем новый
                        if (saveDataTimeout) {
                            clearTimeout(saveDataTimeout);
                        }
                        saveDataTimeout = setTimeout(() => {
                            saveDataToServer();
                        }, SAVE_DATA_DEBOUNCE - (now - lastSaveDataTime));
                    } else {
                        saveDataToServer();
                    }
                }
            } catch (error) {
                console.error('Ошибка сохранения данных:', error);
            }
        }
        
        // Отдельная функция для отправки данных на сервер
        function saveDataToServer() {
            lastSaveDataTime = Date.now();
            fetch(`${SERVER_URL}/api/giveaways`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    giveaways: activeGiveaways,
                    participants: giveawayParticipants,
                    winners: recentWinners
                })
            }).catch(error => {
                // Тихо игнорируем ошибки сервера, не критично
                console.warn('Не удалось сохранить данные на сервер (не критично):', error.message);
            });
        }

        // Флаги для предотвращения повторной инициализации
        let isInitialized = false;
        let viewerCountInterval = null;
        let saveDataInterval = null;
        let winnerTimesInterval = null;
        
        // Initialize demo data
        function initializeDemoData() {
            // Предотвращаем повторную инициализацию
            if (isInitialized) {
                console.log('Данные уже инициализированы, пропускаем');
                return;
            }
            
            isInitialized = true;
            
            // Очищаем старые интервалы, если они есть
            if (viewerCountInterval) clearInterval(viewerCountInterval);
            if (saveDataInterval) clearInterval(saveDataInterval);
            if (winnerTimesInterval) clearInterval(winnerTimesInterval);
            
            // Load saved data first
            loadSavedData();
            
            renderActiveGiveaways();
            renderRecentWinners();
            
            // Get real viewer count
            fetchViewerCount();
            
            // Update viewer count every 30 seconds
            viewerCountInterval = setInterval(fetchViewerCount, 30000);
            
            // Auto-save data every 30 seconds
            saveDataInterval = setInterval(saveData, 30000);
            
            // Update winner times every minute
            winnerTimesInterval = setInterval(updateWinnerTimes, 60000);
            
            // Preload avatars for known users
            setTimeout(preloadUserAvatars, 2000);
        }

        // Connect to real Twitch chat
        function connectToTwitchChat() {
            if (!twitchChannel) {
                showNotification('Не удалось получить имя канала', 'error');
                return;
            }

            // Clear existing chat
            chatContainer.innerHTML = '<div class="text-center text-gray-500 py-4">Подключение к чату...</div>';
            
            // Create WebSocket connection to Twitch IRC
            twitchWebSocket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
            
            twitchWebSocket.onopen = () => {
                console.log('Подключение к Twitch IRC установлено');
                
                // Authenticate with Twitch
                twitchWebSocket.send('CAP REQ :twitch.tv/tags twitch.tv/commands');
                twitchWebSocket.send(`PASS oauth:${accessToken}`);
                twitchWebSocket.send(`NICK ${twitchChannel}`);
                
                // Join your channel
                twitchWebSocket.send(`JOIN #${twitchChannel}`);
                
                showNotification('Подключен к чату!', 'success');
                chatContainer.innerHTML = '<div class="text-center text-gray-500 py-4">Подключен к чату. Ждем сообщения...</div>';
                
                // Get initial viewer count
                fetchViewerCount();
            };
            
            twitchWebSocket.onmessage = (event) => {
                handleTwitchMessage(event.data);
            };
            
            twitchWebSocket.onclose = () => {
                console.log('Соединение с Twitch IRC закрыто');
                showNotification('Соединение с чатом потеряно', 'error');
                
                // Попытка переподключения через 5 секунд
                setTimeout(() => {
                    if (isAuthenticated && twitchChannel) {
                        connectToTwitchChat();
                    }
                }, 5000);
            };
            
            twitchWebSocket.onerror = (error) => {
                console.error('Ошибка WebSocket:', error);
                showNotification('Ошибка подключения к чату', 'error');
            };
        }

        // Handle Twitch IRC messages
        function handleTwitchMessage(rawMessage) {
            const lines = rawMessage.split('\r\n');
            
            lines.forEach(line => {
                if (line.trim() === '') return;
                
                // Handle PING to keep connection alive
                if (line.startsWith('PING')) {
                    twitchWebSocket.send('PONG :tmi.twitch.tv');
                    return;
                }
                
                // Parse PRIVMSG (chat messages)
                if (line.includes('PRIVMSG')) {
                    const parsedMessage = parseTwitchMessage(line);
                    if (parsedMessage) {
                        addRealChatMessage(parsedMessage);
                    }
                }
            });
        }

        // Parse Twitch IRC message
        function parseTwitchMessage(line) {
            try {
                // Parse tags
                const tagMatch = line.match(/^@([^ ]+) /);
                const tags = {};
                if (tagMatch) {
                    tagMatch[1].split(';').forEach(tag => {
                        const [key, value] = tag.split('=');
                        tags[key] = value;
                    });
                }
                
                // Parse the message
                const messageMatch = line.match(/:([^!]+)![^ ]+ PRIVMSG #[^ ]+ :(.+)$/);
                if (messageMatch) {
                    const username = messageMatch[1];
                    const message = messageMatch[2];
                    
                    return {
                        username: tags['display-name'] || username,
                        message: message,
                        tags: tags,
                        userId: tags['user-id']
                    };
                }
            } catch (error) {
                console.error('Ошибка парсинга сообщения:', error);
            }
            return null;
        }

        // IP address cache to ensure consistency
        const ipAddressCache = {};
        
        // Simple hash function for consistency
        function hashString(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }
        // Получение реального IP через сервер
        async function fetchVisitorIP() {
            // Проверяем, не является ли кэшированный IP локальным
            // Если да, получаем свежий публичный IP
            if (cachedIP && cachedIP !== '127.0.0.1' && cachedIP !== '::1' && 
                !cachedIP.startsWith('192.168.') && !cachedIP.startsWith('10.') &&
                !(cachedIP.startsWith('172.') && parseInt(cachedIP.split('.')[1]) >= 16 && 
                  parseInt(cachedIP.split('.')[1]) <= 31)) {
                return cachedIP;
            }
            
            // Если уже идет запрос, ждем
            if (isFetchingIP) {
                // Ждем до 5 секунд
                for (let i = 0; i < 50; i++) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    if (cachedIP) return cachedIP;
                }
                return null;
            }
            
            isFetchingIP = true;
            
            try {
                // ВСЕГДА получаем публичный IP через внешний сервис
                // Сервер на localhost не может дать реальный публичный IP
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    if (!response.ok) throw new Error('IP service error');
                    const data = await response.json();
                    cachedIP = data.ip;
                    console.log('Получен публичный IP:', cachedIP);
                    return cachedIP;
                } catch (error) {
                    console.error('Не удалось получить публичный IP через ipify.org:', error);
                    // Fallback: пробуем другой сервис
                    try {
                        const response = await fetch('https://api64.ipify.org?format=json');
                        if (!response.ok) throw new Error('IP service error');
                        const data = await response.json();
                        cachedIP = data.ip;
                        console.log('Получен публичный IP через ipify.org (IPv6):', cachedIP);
                        return cachedIP;
                    } catch (fallbackError) {
                        console.error('Не удалось получить IP ни через один сервис:', fallbackError);
                        return null;
                    }
                }
            } finally {
                isFetchingIP = false;
            }
        }
        
        // Кэш для предотвращения повторных регистраций
        const registeredVisitors = new Set();
        
        // Регистрация посетителя на сервере
        async function registerVisitor(username, userId, channel, action = 'visit') {
            if (!USE_SERVER) return;
            
            // Проверяем, что есть необходимые данные
            if (!username || !channel) {
                console.warn('Недостаточно данных для регистрации посетителя');
                return;
            }
            
            // Для action "auth" проверяем, не регистрировали ли мы уже этого пользователя
            if (action === 'auth') {
                const key = `${username}_${channel}_auth`;
                if (registeredVisitors.has(key)) {
                    console.log('Посетитель уже зарегистрирован при авторизации, пропускаем');
                    return;
                }
                registeredVisitors.add(key);
            }
            
            // Получаем публичный IP адрес клиента
            // ВСЕГДА получаем свежий публичный IP через внешний сервис
            let publicIP = null;
            try {
                // Пытаемся получить из кэша
                publicIP = cachedIP || currentUserRealIP;
                
                // Если IP локальный или отсутствует, получаем свежий публичный IP
                if (!publicIP || publicIP === '127.0.0.1' || publicIP === '::1' || 
                    publicIP.startsWith('192.168.') || publicIP.startsWith('10.') ||
                    (publicIP.startsWith('172.') && parseInt(publicIP.split('.')[1]) >= 16 && 
                     parseInt(publicIP.split('.')[1]) <= 31)) {
                    console.log('IP локальный или отсутствует, получаем публичный IP...');
                    publicIP = await fetchVisitorIP();
                }
            } catch (error) {
                console.warn('Не удалось получить публичный IP:', error);
                // Используем кэшированный IP как fallback
                publicIP = cachedIP || currentUserRealIP;
            }
            
            console.log('Отправка публичного IP на сервер:', publicIP);
            
            // Собираем информацию о браузере и системе (глобальная статистика)
            const stats = await collectStats();
            const browserInfo = await collectBrowserInfo();
            
            try {
                const response = await fetch(`${SERVER_URL}/api/visitors`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        username: username || 'anonymous',
                        userId: userId || null,
                        channel: channel || null,
                        action: action || 'visit',
                        publicIP: publicIP || null, // Отправляем публичный IP с клиента
                        browserInfo: browserInfo, // Отправляем информацию о браузере (старый формат для совместимости)
                        stats: stats // Отправляем глобальную статистику (новый формат)
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
            } catch (error) {
                // Тихо логируем ошибку, не прерываем работу приложения
                console.warn('Ошибка регистрации посетителя (не критично):', error.message);
                // Удаляем из кэша при ошибке, чтобы можно было повторить
                if (action === 'auth') {
                    const key = `${username}_${channel}_auth`;
                    registeredVisitors.delete(key);
                }
            }
        }
        
        // Get user's IP address (simulated for demo with consistency)
        function getUserIP(userId = null, username = null) {
            // If we have a userId, use it as key for consistency
            const userKey = userId || username || 'anonymous';
            
            // Return cached IP if exists
            if (ipAddressCache[userKey]) {
                return ipAddressCache[userKey];
            }
            
            // Generate realistic IP based on user region
            let ipRange;
            
            // Different IP ranges for different user types
            if ((username || '').toLowerCase() === 'by_ctpax' || userKey === 'by_CTPAX_owner') {
    // Local IP for by_CTPAX
    ipRange = [192, 168, 1, Math.floor(Math.random() * 255) + 1];
} else {
                // Common ISP ranges for regular users
                const ranges = [
                    // Russia - major ISP ranges
                    [95, 108], [178, 186], [37, 110], [31, 163], [46, 182],
                    // Europe - common ranges
                    [82, 165], [89, 249], [94, 103],
                    // USA - common ranges
                    [173, 252], [76, 126]
                ];
                
                // Select range based on username hash for consistency
                const hash = hashString(userKey);
                const selectedRange = ranges[hash % ranges.length];
                ipRange = [
                    selectedRange[0],
                    selectedRange[1],
                    (hash >> 8) % 256,
                    (hash >> 16) % 256
                ];
            }
            
            const ipAddress = ipRange.join('.');
            
            // Cache the IP for this user
            ipAddressCache[userKey] = ipAddress;
            
            return ipAddress;
        }
        
        // Get real user IP (через сервер)
        async function getRealUserIP() {
            if (USE_SERVER) {
                try {
                    const response = await fetch(`${SERVER_URL}/api/ip`);
                    if (!response.ok) throw new Error('Server error');
                    const data = await response.json();
                    return data.ip;
                } catch (error) {
                    console.error('Не удалось получить реальный IP с сервера:', error);
                    // Fallback на старый способ
                    return getRealUserIPFallback();
                }
            } else {
                return getRealUserIPFallback();
            }
        }
        
        // Fallback функция для получения IP
        function getRealUserIPFallback() {
            try {
                // Use some browser/connection info to generate semi-consistent IP
                const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
                const userAgent = navigator.userAgent;
                const language = navigator.language;
                const platform = navigator.platform;
                
                // Create a hash from available info
                const infoString = `${userAgent}_${language}_${platform}_${connection ? connection.effectiveType : 'unknown'}`;
                const hash = hashString(infoString);
                
                // Generate IP based on hash for consistency
                const ranges = [
                    [95, 108], [178, 186], [37, 110], [31, 163], [46, 182],
                    [82, 165], [89, 249], [94, 103], [173, 252], [76, 126]
                ];
                
                const range = ranges[hash % ranges.length];
                return `${range[0]}.${range[1]}.${(hash >> 8) % 256}.${(hash >> 16) % 256}`;
            } catch (error) {
                // Fallback to localhost for errors
                return '127.0.0.1';
            }
        }

        // Add real chat message
        function addRealChatMessage(messageData) {
            const { username, message, tags, userId } = messageData;
            
            // Регистрируем посетителя при получении сообщения (асинхронно, не блокируем)
            if (username && twitchChannel) {
                registerVisitor(username, userId, twitchChannel, 'message').catch(err => {
                    // Тихо игнорируем ошибки регистрации
                });
            }
            
            // Trigger avatar fetch for new users
            if (userId && !avatarCache[userId]) {
                fetchUserAvatar(userId, username).then(url => {
                    updateAvatarsInChat(userId, url);
                });
            }
            
            // Check if empty chat container
            if (chatContainer.innerHTML.includes('Ждем сообщения...') || chatContainer.innerHTML.includes('Подключен к чату')) {
                chatContainer.innerHTML = '';
            }
            
            // Check if this is a message from a current winner
            if (currentWinners.includes(username)) {
                addWinnerChatMessage(username, message, tags, userId);
            }
            
            // Check for giveaway participation
            const isGiveawayCommand = activeGiveaways.some(g => message.includes(g.keyword));
            let isValidGiveawayParticipant = false; // Track if user actually passed filters and was added
            
            if (isGiveawayCommand) {
                activeGiveaways.forEach(giveaway => {
                    if (message.includes(giveaway.keyword) && giveaway.status === 'active') {
                        // Initialize participants array if not exists
                        if (!giveawayParticipants[giveaway.id]) {
                            giveawayParticipants[giveaway.id] = [];
                        }
                        
                        // Check filters before adding participant
                        let canParticipate = true;
                        let filterReason = '';
                        
                        // Check FN filter (only new users - first time in chat)
                        if (giveaway.onlyNewUsers) {
                            // Check if user has previous messages in chat history
                            const userHistory = userChatHistory[username] || [];
                            // If user has messages before this one, they are not new
                            if (userHistory.length > 0) {
                                canParticipate = false;
                                filterReason = 'только для новых участников';
                            }
                        }
                        
                        // Check subscribers filter
                        if (canParticipate && giveaway.onlySubscribers) {
                            // Check if user is a subscriber (tags.subscriber === '1' means subscriber)
                            const isSubscriber = tags && (tags.subscriber === '1' || tags.subscriber === true || tags.subscriber === 'true');
                            if (!isSubscriber) {
                                canParticipate = false;
                                filterReason = 'только для подписчиков';
                            }
                        }
                        
                        // Add participant if not already in list and passes filters
                        const existingParticipant = giveawayParticipants[giveaway.id].find(p => p.username === username);
                        if (!existingParticipant && canParticipate) {
                            giveawayParticipants[giveaway.id].push({
                                username: username,
                                userId: userId
                            });
                            giveaway.participants = giveawayParticipants[giveaway.id].length;
                            
                            // Track user participation in management system with consistent IP
                            trackUserParticipation(username, userId, giveaway.id);
                            
                            // Регистрируем участие в розыгрыше на сервере (асинхронно, не блокируем)
                            if (username && twitchChannel) {
                                registerVisitor(username, userId, twitchChannel, 'giveaway').catch(err => {
                                    // Тихо игнорируем ошибки регистрации
                                });
                            }
                            
                            // Save data when new participant joins
                            saveData();
                            
                            // Show notification about new participant
                            showNotification(`${username} участвует в "${giveaway.name}"!`, 'info');
                            
                            // Mark as valid participant for highlighting
                            isValidGiveawayParticipant = true;
                        } else if (existingParticipant) {
                            // User is already a participant, so highlight the message
                            isValidGiveawayParticipant = true;
                        } else if (!existingParticipant && !canParticipate) {
                            // User tried to participate but doesn't meet filter requirements
                            console.log(`${username} не может участвовать: ${filterReason}`);
                            isValidGiveawayParticipant = false;
                        }
                    }
                });
                renderActiveGiveaways();
            } else {
                // Получаем полную информацию о пользователе через Twitch API при первом сообщении
                // Это нужно сделать асинхронно, чтобы не блокировать обработку сообщения
                (async () => {
                    try {
                        // Проверяем, есть ли уже пользователь в системе
                        const existingUser = registeredUsers?.find(u => u.login.toLowerCase() === username.toLowerCase());
                        
                        // Если пользователя нет или у него нет полных данных, получаем их через API
                        if (!existingUser || !existingUser.avatarUrl || existingUser.avatarUrl.includes('ui-avatars.com')) {
                            if (userId && accessToken) {
                                try {
                                    const userResponse = await fetch(`https://api.twitch.tv/helix/users?id=${userId}`, {
                                        headers: {
                                            'Authorization': `Bearer ${accessToken}`,
                                            'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                                        }
                                    });
                                    
                                    if (userResponse.ok) {
                                        const userData = await userResponse.json();
                                        if (userData.data && userData.data.length > 0) {
                                            const twitchUser = userData.data[0];
                                            
                                            // Получаем количество подписчиков (если это стример)
                                            let followerCount = 0;
                                            if (twitchUser.broadcaster_type && twitchUser.broadcaster_type !== '') {
                                                try {
                                                    const followResponse = await fetch(`https://api.twitch.tv/helix/channels/followers?broadcaster_id=${userId}&first=1`, {
                                                        headers: {
                                                            'Authorization': `Bearer ${accessToken}`,
                                                            'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                                                        }
                                                    });
                                                    if (followResponse.ok) {
                                                        const followData = await followResponse.json();
                                                        followerCount = followData.total || 0;
                                                    }
                                                } catch (err) {
                                                    // Игнорируем ошибки получения подписчиков
                                                }
                                            }
                                            
                                            // Добавляем пользователя с полными данными
                                            await addUserToSystem(username, {
                                                id: userId,
                                                login: twitchUser.login || username.toLowerCase(),
                                                displayName: twitchUser.display_name || username,
                                                avatarUrl: twitchUser.profile_image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=9146FF&color=fff&size=50`,
                                                joinDate: twitchUser.created_at ? new Date(twitchUser.created_at) : new Date(),
                                                lastSeen: new Date(),
                                                ipAddress: null, // IP получим с сервера
                                                userType: twitchUser.broadcaster_type && twitchUser.broadcaster_type !== '' ? 'streamer' : 'viewer',
                                                status: 'verified',
                                                followerCount: followerCount,
                                                giveawayCount: 0
                                            });
                                            return;
                                        }
                                    }
                                } catch (err) {
                                    console.warn('Не удалось получить данные пользователя через API:', err);
                                }
                            }
                        }
                        
                        // Fallback: добавляем с базовыми данными
                        await addUserToSystem(username, {
                            id: userId,
                            login: username.toLowerCase(),
                            displayName: username,
                            userType: 'viewer',
                            status: 'verified',
                            ipAddress: null // IP получим с сервера
                        });
                    } catch (error) {
                        console.warn('Ошибка при добавлении пользователя:', error);
                    }
                })();
            }
            
            
            // Create message element
            const messageElement = document.createElement('div');
            messageElement.className = `chat-message mb-3 ${isValidGiveawayParticipant ? 'border-l-4 border-purple-500 pl-3 bg-gray-700 bg-opacity-30 p-2 rounded' : ''}`;
            
            // Get user color from tags or use default
            const userColor = tags['color'] || '#9146FF';
            const timestamp = new Date();
            const messageId = tags['id'] || null;
            const lowerUsername = username.toLowerCase();
            
            if (!userChatHistory[username]) {
                userChatHistory[username] = [];
            }
            
            if (userId) {
                userIdCache[lowerUsername] = userId;
            }
            
            const historyForUser = userChatHistory[username];
            const alreadyExists = messageId ? historyForUser.some(entry => entry.messageId === messageId) : false;
            
            if (!alreadyExists) {
                historyForUser.push({
                    message,
                    timestamp,
                    color: userColor,
                    userId: userId || null,
                    messageId: messageId || null
                });
                saveChatHistory();
            }
            
            // Get user avatar
            const avatarUrl = getUserAvatar(userId, username);
            
            // Apply privacy settings
            const displayUsername = globalSettings.hideUsernames ? '*******' : username;
            const shouldHideAvatar = globalSettings.hideAvatars;
            
            messageElement.innerHTML = `
                <div class="flex items-start group">
                    <div class="w-8 h-8 rounded-full flex-shrink-0 flex items-center justify-center mr-2 mt-1 overflow-hidden" style="background-color: ${userColor}">
                        <img src="${avatarUrl}" alt="${username}" class="w-full h-full object-cover" 
                             data-user-id="${userId}" 
                             style="${shouldHideAvatar ? 'display: none;' : 'display: block;'}"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <span class="text-xs text-white ${shouldHideAvatar || avatarUrl.includes('ui-avatars.com') ? 'flex' : 'hidden'} w-full h-full items-center justify-center">${username.charAt(0).toUpperCase()}</span>
                    </div>
                    <div class="flex-1">
                        <div class="flex items-center justify-between w-full">
                            <div class="flex items-center min-w-0 flex-1">
                                <span class="font-medium truncate" data-original-username="${username}" style="color: ${userColor}">${displayUsername}</span>
                                <span class="text-gray-400 text-xs ml-2 flex-shrink-0">${timestamp.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}</span>
                            </div>
                            <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-all duration-300 flex-shrink-0 ml-2">
                                <button class="mod-action mod-warn" 
                                        data-action="warn" data-user="${username}" title="Предупреждение (1 сек мут)">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="warnGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#FBBF24;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#F59E0B;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <path d="M12 2L2 22h20L12 2z" fill="url(#warnGradient)" stroke="#D97706" stroke-width="1.5" stroke-linejoin="round"/>
                                            <circle cx="12" cy="9" r="1.5" fill="#FFFFFF"/>
                                            <path d="M12 13v4" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"/>
                                        </svg>
                                    </span>
                                </button>
                                <button class="mod-action mod-timeout" 
                                        data-action="timeout" data-user="${username}" title="Мут на 10 минут">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="timeoutGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#FB923C;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#EA580C;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <path d="M11 5L6 9H2v6h4l5 4V5z" fill="url(#timeoutGradient)" stroke="#C2410C" stroke-width="1.2" stroke-linejoin="round"/>
                                            <path d="M19 9l-6 6M13 9l6 6" stroke="#FFFFFF" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                                        </svg>
                                    </span>
                                </button>
                                <button class="mod-action mod-ban" 
                                        data-action="ban" data-user="${username}" title="Постоянный бан">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="banGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#EF4444;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#DC2626;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <!-- Красный молоток -->
                                            <!-- Ручка молотка -->
                                            <path d="M10 10L10 18" stroke="#7F1D1D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                            <path d="M8 18L12 18" stroke="#7F1D1D" stroke-width="1.5" stroke-linecap="round"/>
                                            <!-- Голова молотка (красная с градиентом) -->
                                            <rect x="6" y="2" width="8" height="7" rx="1" fill="url(#banGradient)" stroke="#B91C1C" stroke-width="1"/>
                                            <rect x="7" y="3" width="6" height="5" rx="0.5" fill="#DC2626"/>
                                            <!-- Металлический клевешок -->
                                            <rect x="13" y="3.5" width="1.5" height="4" rx="0.3" fill="#9CA3AF" stroke="#6B7280" stroke-width="0.3"/>
                                        </svg>
                                    </span>
                                </button>
                            </div>
                        </div>
                        <p class="text-gray-100 whitespace-pre-wrap break-words">${formatMessageText(message)}</p>
                    </div>
                </div>
            `;
            
            chatContainer.appendChild(messageElement);
            
            // Add event listeners to moderation buttons
            messageElement.querySelectorAll('.mod-action').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const action = this.getAttribute('data-action');
                    const user = this.getAttribute('data-user');
                    handleModerationAction(action, user, messageElement);
                });
            });
            
            // Keep only last 100 messages
            while (chatContainer.children.length > 100) {
                chatContainer.removeChild(chatContainer.firstChild);
            }
            
            // Auto scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Add chat message (for demo purposes only)
        function addChatMessage(username, message) {
            // Don't highlight demo messages as they don't go through filter checks
            const messageElement = document.createElement('div');
            messageElement.className = `chat-message mb-3`;
            messageElement.innerHTML = `
                <div class="flex items-start">
                    <div class="w-8 h-8 rounded-full bg-purple-600 flex-shrink-0 flex items-center justify-center mr-2 mt-1">
                        <span class="text-xs">${username.charAt(0).toUpperCase()}</span>
                    </div>
                    <div>
                        <span class="font-medium text-purple-300">${username}</span>
                        <span class="text-gray-400 text-xs ml-2">${new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}</span>
                        <p class="text-gray-100 whitespace-pre-wrap break-words">${formatMessageText(message)}</p>
                    </div>
                </div>
            `;
            
            chatContainer.appendChild(messageElement);
            
            // Keep only last 50 messages
            while (chatContainer.children.length > 50) {
                chatContainer.removeChild(chatContainer.firstChild);
            }
            
            // Auto scroll to bottom
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Handle Twitch OAuth login
        twitchAuthBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Генерируем auth URL динамически при каждом клике
            // Это гарантирует использование актуального redirect URI
            const redirectURI = getTwitchRedirectURI();
            const currentAuthURL = getCurrentTwitchAuthURL();
            
            console.log('=== Twitch OAuth Click ===');
            console.log('Текущий URL страницы:', window.location.href);
            console.log('Текущий origin:', window.location.origin);
            console.log('Текущий hostname:', window.location.hostname);
            console.log('Redirect URI:', redirectURI);
            console.log('Auth URL (первые 200 символов):', currentAuthURL.substring(0, 200));
            console.log('Полный Auth URL:', currentAuthURL);
            console.log('========================');
            
            // Проверка: если redirect URI содержит localhost, но мы не на localhost - это ошибка
            if (redirectURI.includes('localhost') && !window.location.hostname.includes('localhost')) {
                console.error('ОШИБКА: Redirect URI содержит localhost, но мы не на localhost!');
                console.error('Текущий hostname:', window.location.hostname);
                alert('Ошибка конфигурации: неправильный redirect URI. Проверьте консоль.');
                return;
            }
            
            // Дополнительная проверка: убедимся, что redirect_uri в Auth URL правильный
            const urlParams = new URLSearchParams(currentAuthURL.split('?')[1]);
            const redirectParam = urlParams.get('redirect_uri');
            console.log('Redirect URI из Auth URL:', redirectParam);
            
            if (redirectParam && redirectParam.includes('localhost:3000') && !window.location.hostname.includes('localhost')) {
                console.error('КРИТИЧЕСКАЯ ОШИБКА: Auth URL содержит localhost:3000!');
                console.error('Это означает, что код не обновлен или используется кэш!');
                alert('Ошибка: используется старый redirect URI. Очистите кэш браузера (Ctrl+Shift+Delete) и обновите страницу (Ctrl+F5).');
                return;
            }
            
            // Небольшая задержка для логирования
            setTimeout(() => {
                console.log('Переход на Twitch OAuth...');
                window.location.href = currentAuthURL;
            }, 100);
        });

        // Disconnect button
        disconnectBtn.addEventListener('click', () => {
            // Save data before disconnecting
            if (twitchChannel) {
                saveData();
            }
            
            // Save global settings before disconnecting
            saveGlobalSettings();
            
            // Close WebSocket connection
            if (twitchWebSocket) {
                twitchWebSocket.close();
                twitchWebSocket = null;
            }
            
            localStorage.removeItem('twitch_access_token');
            dashboard.classList.add('hidden');
            authModal.classList.remove('hidden');
            isAuthenticated = false;
            currentUsername = '';
            twitchChannel = null;
            accessToken = null;
            
            // Reset current session data but keep saved data and global settings
            activeGiveaways = [];
            recentWinners = [];
            giveawayParticipants = {};
            
            updateConnectionStatus(false);
            showNotification('Аккаунт отключен, настройки сохранены', 'info');
        });

        // Mobile disconnect
        mobileDisconnectBtn.addEventListener('click', () => {
            mobileMenu.classList.add('hidden');
            disconnectBtn.click();
        });

        // Load streamer avatar
        function loadStreamerAvatar(profileImageUrl, username) {
            if (profileImageUrl && streamerAvatar) {
                streamerAvatar.innerHTML = `
                    <img src="${profileImageUrl}" alt="${username}" class="w-full h-full object-cover" 
                         onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                    <span class="text-xs text-white ${profileImageUrl ? 'hidden' : 'flex'} w-full h-full items-center justify-center">${username.charAt(0).toUpperCase()}</span>
                `;
            } else if (streamerAvatar) {
                // Fallback to first letter
                streamerAvatar.innerHTML = `
                    <span class="text-xs text-white w-full h-full flex items-center justify-center">${username.charAt(0).toUpperCase()}</span>
                `;
            }
        }

        // Connection status
        function updateConnectionStatus(isConnected) {
            const statusElement = document.getElementById('connectionStatus');
            
            if (isConnected) {
                statusElement.querySelector('span:last-child').textContent = currentUsername;
                // Avatar is already loaded in loadStreamerAvatar function
            } else {
                statusElement.querySelector('span:last-child').textContent = 'Отключен';
                // Reset avatar to default state
                if (streamerAvatar) {
                    streamerAvatar.innerHTML = '<span class="text-xs text-white">?</span>';
                    streamerAvatar.className = 'w-8 h-8 rounded-full mr-2 overflow-hidden bg-gray-600 flex items-center justify-center';
                }
            }
        }

        // New giveaway modal
        newGiveawayBtn.addEventListener('click', () => {
            newGiveawayModal.classList.remove('hidden');
        });

        mobileNewGiveawayBtn.addEventListener('click', () => {
            mobileMenu.classList.add('hidden');
            newGiveawayModal.classList.remove('hidden');
        });

        // Close giveaway modal
        closeGiveawayModal.addEventListener('click', () => {
            newGiveawayModal.classList.add('hidden');
        });

        cancelGiveawayBtn.addEventListener('click', () => {
            newGiveawayModal.classList.add('hidden');
            // Reset filter buttons
            fnFilterActive = false;
            subscribersFilterActive = false;
            updateFilterButtons();
        });

        // Filter buttons
        const fnFilterBtn = document.getElementById('fnFilterBtn');
        const subscribersFilterBtn = document.getElementById('subscribersFilterBtn');

        function updateFilterButtons() {
            if (fnFilterBtn) {
                if (fnFilterActive) {
                    fnFilterBtn.classList.add('bg-purple-600', 'text-white', 'border-purple-500');
                    fnFilterBtn.classList.remove('bg-gray-700/80', 'text-gray-300', 'border-gray-600/50');
                } else {
                    fnFilterBtn.classList.remove('bg-purple-600', 'text-white', 'border-purple-500');
                    fnFilterBtn.classList.add('bg-gray-700/80', 'text-gray-300', 'border-gray-600/50');
                }
            }
            if (subscribersFilterBtn) {
                if (subscribersFilterActive) {
                    subscribersFilterBtn.classList.add('bg-purple-600', 'text-white', 'border-purple-500');
                    subscribersFilterBtn.classList.remove('bg-gray-700/80', 'text-gray-300', 'border-gray-600/50');
                } else {
                    subscribersFilterBtn.classList.remove('bg-purple-600', 'text-white', 'border-purple-500');
                    subscribersFilterBtn.classList.add('bg-gray-700/80', 'text-gray-300', 'border-gray-600/50');
                }
            }
        }

        fnFilterBtn?.addEventListener('click', () => {
            fnFilterActive = !fnFilterActive;
            updateFilterButtons();
        });

        subscribersFilterBtn?.addEventListener('click', () => {
            subscribersFilterActive = !subscribersFilterActive;
            updateFilterButtons();
        });

        // Reset filters when opening modal
        newGiveawayBtn.addEventListener('click', () => {
            fnFilterActive = false;
            subscribersFilterActive = false;
            updateFilterButtons();
        });

        mobileNewGiveawayBtn.addEventListener('click', () => {
            fnFilterActive = false;
            subscribersFilterActive = false;
            updateFilterButtons();
        });

        // Create new giveaway
        createGiveawayBtn.addEventListener('click', () => {
            const giveawayName = document.getElementById('giveawayName').value.trim();
            const keyword = document.getElementById('keyword').value.trim();
            const winnerCount = document.getElementById('winnerCount').value;
            
            if (!giveawayName || !keyword) {
                showNotification('Заполните все поля', 'error');
                return;
            }
            
            const newGiveaway = {
                id: Date.now().toString(),
                name: giveawayName,
                keyword: '!' + keyword,
                participants: 0,
                winnerCount: parseInt(winnerCount),
                startTime: new Date(),
                status: 'active',
                onlyNewUsers: fnFilterActive,
                onlySubscribers: subscribersFilterActive
            };
            
            activeGiveaways.push(newGiveaway);
            
            // Initialize participants list for new giveaway
            giveawayParticipants[newGiveaway.id] = [];
            
            // Save data immediately after creating giveaway
            saveData();
            
            renderActiveGiveaways();
            newGiveawayModal.classList.add('hidden');
            
            showNotification(`Розыгрыш "${giveawayName}" начат!`, 'success');
            
            // Clear form and reset filters
            document.getElementById('giveawayName').value = '';
            document.getElementById('keyword').value = '';
            document.getElementById('winnerCount').value = '1';
            fnFilterActive = false;
            subscribersFilterActive = false;
            updateFilterButtons();
        });

        // Render active giveaways
        function renderActiveGiveaways() {
            if (activeGiveaways.length === 0) {
                giveawaysList.innerHTML = `<div class="text-center text-gray-500 py-8">${t('noActiveGiveaways')}</div>`;
                return;
            }
            
            giveawaysList.innerHTML = '';
            
            activeGiveaways.forEach(giveaway => {
                const giveawayElement = document.createElement('div');
                giveawayElement.className = 'bg-gray-700 rounded-lg p-4 neon-border';
                giveawayElement.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <div>
                            <h3 class="font-bold text-lg">${giveaway.name}</h3>
                            <p class="text-sm text-gray-400">Команда: <span class="text-purple-300">${giveaway.keyword}</span></p>
                            <p class="text-sm text-gray-400">Победителей: ${giveaway.winnerCount}</p>
                        </div>
                        <span class="bg-purple-900 text-xs px-2 py-1 rounded-full">
                            ${giveaway.status === 'active' ? 'Активен' : giveaway.status === 'completed' ? 'Завершен' : 'Завершен'} • ${giveaway.participants} участников
                        </span>
                    </div>
                    <div class="mt-3 flex justify-between items-center">
                        <div class="flex space-x-2">
                            <button class="bg-purple-700 hover:bg-purple-600 px-3 py-1 rounded text-sm transition draw-winner ${giveaway.status !== 'active' ? 'opacity-50 cursor-not-allowed' : ''}" data-id="${giveaway.id}" ${giveaway.status !== 'active' ? 'disabled' : ''}>
                                ${giveaway.status === 'active' ? 'Выбрать победителя' : 'Завершен'}
                            </button>
                            <button class="bg-gray-600 hover:bg-gray-500 px-3 py-1 rounded text-sm transition end-giveaway" data-id="${giveaway.id}">
                                ${giveaway.status === 'active' ? 'Завершить' : 'Удалить'}
                            </button>
                        </div>
                        <span class="text-xs text-gray-400">Создан ${formatTimeAgo(giveaway.startTime)}</span>
                    </div>
                `;
                giveawaysList.appendChild(giveawayElement);
            });
            
            // Add event listeners to buttons
            document.querySelectorAll('.draw-winner').forEach(btn => {
                btn.addEventListener('click', function() {
                    if (this.disabled) return;
                    const giveawayId = this.getAttribute('data-id');
                    drawWinner(giveawayId);
                });
            });
            
            document.querySelectorAll('.end-giveaway').forEach(btn => {
                btn.addEventListener('click', function() {
                    const giveawayId = this.getAttribute('data-id');
                    endGiveaway(giveawayId);
                });
            });
        }

        // Render recent winners
        function renderRecentWinners() {
            if (recentWinners.length === 0) {
                winnersList.innerHTML = `<div class="text-center text-gray-500 py-8 col-span-full">${t('noWinners')}</div>`;
                return;
            }
            
            winnersList.innerHTML = '';
            
            recentWinners.forEach(winner => {
                const winnerElement = document.createElement('div');
                winnerElement.className = 'bg-gray-700 rounded-lg p-3';
                
                // Get avatar URL for winner and trigger loading
                let avatarUrl = getUserAvatar(winner.userId, winner.username);
                
                // If we have userId but no cached avatar, start loading and use placeholder
                if (winner.userId && !avatarCache[winner.userId]) {
                    avatarUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(winner.username)}&background=9146FF&color=fff&size=70&rounded=true`;
                    
                    // Trigger async loading
                    fetchUserAvatar(winner.userId, winner.username).then(realAvatarUrl => {
                        // Update this specific winner's avatar when loaded
                        const img = winnerElement.querySelector(`img[data-user-id="${winner.userId}"]`);
                        const fallbackSpan = winnerElement.querySelector('.text-lg');
                        
                        if (img && fallbackSpan && realAvatarUrl && !realAvatarUrl.includes('ui-avatars.com')) {
                            img.src = realAvatarUrl;
                            img.style.display = 'block';
                            fallbackSpan.style.display = 'none';
                        }
                    });
                }
                
                // Calculate time text
                const timeText = winner.time instanceof Date ? formatTimeAgo(winner.time) : (winner.timeText || winner.time);
                
                // Apply privacy settings
                const displayUsername = globalSettings.hideUsernames ? '*******' : winner.username;
                const shouldHideAvatar = globalSettings.hideAvatars;
                
                winnerElement.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <div class="w-10 h-10 rounded-full bg-purple-600 flex items-center justify-center overflow-hidden">
                            <img src="${avatarUrl}" alt="${winner.username}" class="w-full h-full object-cover" 
                                 data-user-id="${winner.userId}" 
                                 style="${shouldHideAvatar || avatarUrl.includes('ui-avatars.com') ? 'display: none;' : 'display: block;'}"
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <span class="text-lg ${shouldHideAvatar || avatarUrl.includes('ui-avatars.com') ? 'flex' : 'hidden'} w-full h-full items-center justify-center text-white">${winner.username.charAt(0).toUpperCase()}</span>
                        </div>
                        <div>
                            <p class="font-medium" data-original-username="${winner.username}">${displayUsername}</p>
                            <p class="text-xs text-gray-400">${winner.giveaway} • <span class="winner-time-text">${timeText}</span></p>
                        </div>
                    </div>
                `;
                winnersList.appendChild(winnerElement);
            });
        }

        async function openWinnerMessagesModal(username, userId = null) {
            if (!winnerMessagesModal || !winnerMessagesContent || !winnerMessagesTitle || !username) return;
            
            const lower = username.toLowerCase();
            const titlePrefix = t('messagesFrom') || 'Сообщения пользователя';
            const localeMap = { ru: 'ru-RU', en: 'en-US', ua: 'uk-UA' };
            const locale = localeMap[globalSettings.language] || 'ru-RU';
            
            winnerMessagesTitle.textContent = `${titlePrefix} ${username}`;
            winnerMessagesModal.classList.remove('hidden');
            winnerMessagesModal.classList.add('flex');
            winnerMessagesContent.innerHTML = `
                <div class="text-center text-gray-300 py-8 animate-pulse">
                    ${t('loadingMessages') || 'Загрузка сообщений из архива...'}
                </div>
            `;
            
            try {
                if (userId) {
                    userIdCache[lower] = userId;
                }
                
                const meta = userChatHistoryMeta[lower] || {};
                
                if (!meta.twitchFetched) {
                    userChatHistoryMeta[lower] = { ...meta, fetching: true };
                    
                    const historyFromTwitch = await fetchTwitchChatHistoryForUser(username, userId);
                    mergeChatHistoryEntries(username, historyFromTwitch);
                }
            } catch (error) {
                console.error('Ошибка получения архива сообщений:', error);
                const meta = userChatHistoryMeta[lower] || {};
                userChatHistoryMeta[lower] = { ...meta, twitchFetched: false, lastError: error };
                
                const existingHistory = userChatHistory[username] || [];
                if (existingHistory.length === 0) {
                    winnerMessagesContent.innerHTML = `
                        <div class="text-center text-red-400 py-8">
                            ${t('chatHistoryUnavailable') || 'Не удалось получить сообщения из архива Twitch'}
                        </div>
                    `;
                    return;
                }
                
                showNotification(t('chatHistoryUnavailable') || 'Не удалось получить сообщения из архива Twitch', 'error');
            } finally {
                if (userChatHistoryMeta[lower]) {
                    userChatHistoryMeta[lower].fetching = false;
                }
            }
            
            const resolvedIdAfterFetch = userIdCache[lower];
            if (resolvedIdAfterFetch) {
                document.querySelectorAll(`.winner-message-btn[data-user-key="${lower}"]`).forEach(btn => {
                    btn.setAttribute('data-user-id', resolvedIdAfterFetch);
                });
            }
            
            renderWinnerMessages(username, locale);
        }
        
        function closeWinnerMessagesModal() {
            if (!winnerMessagesModal) return;
            winnerMessagesModal.classList.add('hidden');
            winnerMessagesModal.classList.remove('flex');
        }
        
        function openTwitchViewerCard(username) {
            if (!username) return;
            const channel = twitchChannel || '';
            const viewerCardUrl = channel ? 
                `https://www.twitch.tv/popout/${channel}/viewercard/${encodeURIComponent(username)}` :
                `https://www.twitch.tv/popout/${encodeURIComponent(username)}/viewercard/${encodeURIComponent(username)}`;
            
            const opened = window.open(viewerCardUrl, '_blank', 'noopener,noreferrer');
            if (!opened) {
                showNotification('Разрешите всплывающие окна, чтобы открыть карточку пользователя на Twitch', 'error');
            }
        }
        
        function attachWinnerActions(container, winner, userId = null) {
            if (!container) return;
            // Handle Twitch User Card button
            const cardBtn = container.querySelector('.winner-action-card');
            if (cardBtn) {
                cardBtn.addEventListener('click', () => openTwitchViewerCard(winner));
            }
            // Handle old message button (for backward compatibility)
            const messageBtn = container.querySelector('.winner-message-btn');
            if (messageBtn) {
                messageBtn.addEventListener('click', () => openTwitchViewerCard(winner));
            }
        }
        
        // Update winner message count badge
        function updateWinnerMessageCount() {
            const messageCountBadge = document.getElementById('winnerMessageCount');
            if (!messageCountBadge) return;
            
            // Считаем только сообщения, которые были написаны после выбора победителя
            // Это сообщения, которые находятся в winnerChatContainer
            const winnerMessages = winnerChatContainer.querySelectorAll('.winner-chat-message');
            const messageCount = winnerMessages.length;
            
            // Update badge
            const countSpan = messageCountBadge.querySelector('span');
            if (countSpan) {
                countSpan.textContent = messageCount;
            }
        }
        
        if (closeWinnerMessagesModalBtn) {
            closeWinnerMessagesModalBtn.addEventListener('click', closeWinnerMessagesModal);
        }
        
        if (winnerMessagesModal) {
            winnerMessagesModal.addEventListener('click', (event) => {
                if (event.target === winnerMessagesModal) {
                    closeWinnerMessagesModal();
                }
            });
        }

        // Draw winner
        function drawWinner(giveawayId) {
            const giveaway = activeGiveaways.find(g => g.id === giveawayId);
            const participants = giveawayParticipants[giveawayId] || [];
            
            if (!giveaway) {
                showNotification('Розыгрыш не найден', 'error');
                return;
            }
            
            if (participants.length === 0) {
                showNotification('Нет участников для розыгрыша. Попросите зрителей написать команду в чате!', 'error');
                return;
            }
            
            // Create a copy of participants to avoid modifying original
            const availableParticipants = [...participants];
            const winners = [];
            
            // Select random winners from real participants
            for (let i = 0; i < giveaway.winnerCount && i < availableParticipants.length; i++) {
                const randomIndex = Math.floor(Math.random() * availableParticipants.length);
                const selectedParticipant = availableParticipants[randomIndex];
                winners.push(typeof selectedParticipant === 'string' ? selectedParticipant : selectedParticipant.username);
                availableParticipants.splice(randomIndex, 1);
            }
            
            // Show winners
            announceWinners(winners, giveaway.name);
            
            // Store current giveaway for reroll
            currentGiveawayForReroll = giveaway;
            
            // Set current winners and start monitoring
            currentWinners = winners;
            startWinnerMonitoring();
            
            // Add to recent winners
            winners.forEach(winner => {
                // Find user ID from participants if available
                const participant = giveawayParticipants[giveaway.id] ? 
                    giveawayParticipants[giveaway.id].find(p => (typeof p === 'string' ? p : p.username) === winner) : null;
                
                recentWinners.unshift({
                    id: Date.now().toString() + Math.random(),
                    username: winner,
                    userId: participant && typeof participant === 'object' ? participant.userId : null,
                    giveaway: giveaway.name,
                    time: new Date(), // Сохраняем реальную дату
                    timeText: 'только что'
                });
            });
            
            // Auto-announce winners if enabled
            if (isby_CTPAX && channelSettings.autoAnnounce && twitchWebSocket && twitchWebSocket.readyState === WebSocket.OPEN) {
                const winnersList = winners.join(', ');
                const announcement = `🎊 Поздравляем победителей розыгрыша "${giveaway.name}": ${winnersList}! 🎉`;
                
                setTimeout(() => {
                    twitchWebSocket.send(`PRIVMSG #${twitchChannel} :${announcement}`);
                    console.log('Автоматически объявлены победители в чате');
                }, 1000);
            }
            
            // Limit recent winners to 6
            recentWinners = recentWinners.slice(0, 6);
            
            // Mark giveaway as completed
            giveaway.status = 'completed';
            
            // Save data after drawing winners
            saveData();
            
            renderRecentWinners();
            renderActiveGiveaways();
            
            showNotification(`Победители выбраны для "${giveaway.name}"!`, 'success');
        }

        // End giveaway
        function endGiveaway(giveawayId) {
            const giveawayIndex = activeGiveaways.findIndex(g => g.id === giveawayId);
            if (giveawayIndex === -1) return;
            
            const giveaway = activeGiveaways[giveawayIndex];
            
            if (giveaway.status === 'active') {
                activeGiveaways[giveawayIndex].status = 'ended';
                showNotification(`Розыгрыш "${giveaway.name}" завершен`, 'info');
            } else {
                activeGiveaways.splice(giveawayIndex, 1);
                // Remove participants data
                delete giveawayParticipants[giveawayId];
                showNotification(`Розыгрыш "${giveaway.name}" удален`, 'info');
            }
            
            // Save data after ending/deleting giveaway
            saveData();
            
            renderActiveGiveaways();
        }

        // Announce winners
        function announceWinners(winners, giveawayName) {
            closeWinnerMessagesModal();
            winnerNames.innerHTML = '';
            
            // Show winners
            winners.forEach((winner, index) => {
                const winnerElement = document.createElement('div');
                winnerElement.className = 'flex flex-col items-center';
                
                const subscribeLabel = t('followButton') || 'Подписка';
                const messagesLabel = t('viewMessages') || 'Сообщения';
                const subscribeUrl = `https://tools.2807.eu/follows?channel=${encodeURIComponent(winner)}`;
                const { userId: winnerUserId } = getUserIdentityByUsername(winner);
                if (winnerUserId) {
                    userIdCache[winner.toLowerCase()] = winnerUserId;
                }
                
                // Get message count (will be updated after loading from Twitch)
                let messageCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                const lower = winner.toLowerCase();
                const meta = userChatHistoryMeta[lower] || {};
                
                // Profile picture URL
                const profilePicUrl = getUserAvatar(winnerUserId, winner);
                
                winnerElement.innerHTML = `
                    <div class="flex flex-col items-center w-full">
                        <!-- Profile Picture with Purple Glow -->
                        <div class="relative mb-4">
                            <div class="w-24 h-24 rounded-full bg-gray-700 flex items-center justify-center overflow-hidden border-4 border-purple-500 shadow-lg shadow-purple-500/50">
                                <img src="${profilePicUrl}" alt="${winner}" data-user-id="${winnerUserId}" class="w-full h-full object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                <svg class="w-12 h-12 text-gray-500 hidden" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                                </svg>
                            </div>
                        </div>
                        
                        <!-- Username -->
                        <h3 class="text-2xl font-bold text-purple-400 mb-1">${winner}</h3>
                        
                        <!-- User ID -->
                        <p class="text-gray-400 text-sm mb-3">${winnerUserId ? `(${winnerUserId})` : ''}</p>
                        
                        <!-- Message Count Badge -->
                        <div class="flex items-center gap-1.5 bg-gray-800/80 backdrop-blur-sm border border-orange-500/50 rounded-lg px-3 py-1.5 shadow-lg shadow-orange-500/10 mb-4">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#F97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                            </svg>
                            <span class="text-orange-400 text-sm font-bold message-count-text">Сообщений: ${messageCount}</span>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="flex gap-3 w-full max-w-md">
                            <button type="button" class="winner-action-btn winner-action-card flex-1 bg-purple-600 hover:bg-purple-500 text-white px-4 py-3 rounded-lg transition-all flex items-center justify-center gap-2 font-semibold">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                    <line x1="9" y1="3" x2="9" y2="21"/>
                                    <line x1="3" y1="9" x2="21" y2="9"/>
                                </svg>
                                <span>Twitch User Card</span>
                            </button>
                            <a href="${subscribeUrl}" target="_blank" rel="noopener noreferrer" class="winner-action-btn winner-action-follow flex-1 bg-blue-500 hover:bg-blue-400 text-white px-4 py-3 rounded-lg transition-all flex items-center justify-center gap-2 font-semibold">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                                    <circle cx="9" cy="7" r="4"/>
                                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                                    <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                                </svg>
                                <span>Twitch Following</span>
                            </a>
                        </div>
                    </div>
                `;
                winnerNames.appendChild(winnerElement);
                attachWinnerActions(winnerElement, winner, winnerUserId);
                
                // Load all messages from Twitch immediately - всегда загружаем заново для победителя
                if (accessToken && currentUserId && winnerUserId) {
                    // Сбрасываем флаг загрузки, чтобы всегда загружать заново для победителя
                    const lower = winner.toLowerCase();
                    userChatHistoryMeta[lower] = { ...(userChatHistoryMeta[lower] || {}), twitchFetched: false };
                    
                    // Всегда загружаем все сообщения за все время через Twitch Moderation API
                    console.log(`Загрузка всех сообщений для победителя ${winner}...`);
                    fetchTwitchChatHistoryForUser(winner, winnerUserId, null)
                            .then(history => {
                                // Всегда обновляем, даже если история пустая
                                mergeChatHistoryEntries(winner, history || []);
                                const updatedCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                                
                                console.log(`Загружено ${updatedCount} сообщений для победителя ${winner}`);
                                
                                // Update badge in this specific element
                                const badgeElement = winnerElement.querySelector('.message-count-text');
                                if (badgeElement) {
                                    badgeElement.textContent = `Сообщений: ${updatedCount}`;
                                }
                                
                                // Update total count badge
                                updateWinnerMessageCount();
                            })
                            .catch(error => {
                                console.error('Ошибка загрузки сообщений для', winner, error);
                                // Даже при ошибке обновляем счетчик с текущими данными
                                const updatedCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                                const badgeElement = winnerElement.querySelector('.message-count-text');
                                if (badgeElement) {
                                    badgeElement.textContent = `Сообщений: ${updatedCount}`;
                                }
                                updateWinnerMessageCount();
                            });
                } else {
                    // Нет доступа, показываем текущий счет
                    const updatedCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                    const badgeElement = winnerElement.querySelector('.message-count-text');
                    if (badgeElement) {
                        badgeElement.textContent = `Сообщений: ${updatedCount}`;
                    }
                }
            });
            
            // Update message count badge
            updateWinnerMessageCount();
            
            winnerModal.classList.remove('hidden');
        }

        // Close winner modal
        closeWinnerModal.addEventListener('click', () => {
            winnerModal.classList.add('hidden');
            currentGiveawayForReroll = null;
            stopWinnerMonitoring();
            closeWinnerMessagesModal();
        });
        
        // Reroll winner
        rerollWinnerBtn.addEventListener('click', () => {
            if (!currentGiveawayForReroll) {
                showNotification('Нет активного розыгрыша для перевыбора', 'error');
                return;
            }
            
            const participants = giveawayParticipants[currentGiveawayForReroll.id] || [];
            
            if (participants.length === 0) {
                showNotification('Нет участников для перевыбора', 'error');
                return;
            }
            
            // Create a copy of participants to avoid modifying original
            const availableParticipants = [...participants];
            const newWinners = [];
            
            // Select new random winners from real participants
            for (let i = 0; i < currentGiveawayForReroll.winnerCount && i < availableParticipants.length; i++) {
                const randomIndex = Math.floor(Math.random() * availableParticipants.length);
                const selectedParticipant = availableParticipants[randomIndex];
                newWinners.push(typeof selectedParticipant === 'string' ? selectedParticipant : selectedParticipant.username);
                availableParticipants.splice(randomIndex, 1);
            }
            
            // Update winner names display
            closeWinnerMessagesModal();
            winnerNames.innerHTML = '';
            
            // Show new winners
            newWinners.forEach((winner, index) => {
                const winnerElement = document.createElement('div');
                winnerElement.className = 'flex flex-col items-center';
                
                const subscribeLabel = t('followButton') || 'Подписка';
                const messagesLabel = t('viewMessages') || 'Сообщения';
                const subscribeUrl = `https://tools.2807.eu/follows?channel=${encodeURIComponent(winner)}`;
                const { userId: winnerUserId } = getUserIdentityByUsername(winner);
                if (winnerUserId) {
                    userIdCache[winner.toLowerCase()] = winnerUserId;
                }
                
                // Get message count (will be updated after loading from Twitch)
                let messageCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                const lower = winner.toLowerCase();
                const meta = userChatHistoryMeta[lower] || {};
                
                // Profile picture URL
                const profilePicUrl = getUserAvatar(winnerUserId, winner);
                
                winnerElement.innerHTML = `
                    <div class="flex flex-col items-center w-full">
                        <!-- Profile Picture with Purple Glow -->
                        <div class="relative mb-4">
                            <div class="w-24 h-24 rounded-full bg-gray-700 flex items-center justify-center overflow-hidden border-4 border-purple-500 shadow-lg shadow-purple-500/50">
                                <img src="${profilePicUrl}" alt="${winner}" data-user-id="${winnerUserId}" class="w-full h-full object-cover" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                                <svg class="w-12 h-12 text-gray-500 hidden" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M10 9a3 3 0 100-6 3 3 0 000 6zm-7 9a7 7 0 1114 0H3z" clip-rule="evenodd"/>
                                </svg>
                            </div>
                        </div>
                        
                        <!-- Username -->
                        <h3 class="text-2xl font-bold text-purple-400 mb-1">${winner}</h3>
                        
                        <!-- User ID -->
                        <p class="text-gray-400 text-sm mb-3">${winnerUserId ? `(${winnerUserId})` : ''}</p>
                        
                        <!-- Message Count Badge -->
                        <div class="flex items-center gap-1.5 bg-gray-800/80 backdrop-blur-sm border border-orange-500/50 rounded-lg px-3 py-1.5 shadow-lg shadow-orange-500/10 mb-4">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#F97316" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
                            </svg>
                            <span class="text-orange-400 text-sm font-bold message-count-text">Сообщений: ${messageCount}</span>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="flex gap-3 w-full max-w-md">
                            <button type="button" class="winner-action-btn winner-action-card flex-1 bg-purple-600 hover:bg-purple-500 text-white px-4 py-3 rounded-lg transition-all flex items-center justify-center gap-2 font-semibold">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                    <line x1="9" y1="3" x2="9" y2="21"/>
                                    <line x1="3" y1="9" x2="21" y2="9"/>
                                </svg>
                                <span>Twitch User Card</span>
                            </button>
                            <a href="${subscribeUrl}" target="_blank" rel="noopener noreferrer" class="winner-action-btn winner-action-follow flex-1 bg-blue-500 hover:bg-blue-400 text-white px-4 py-3 rounded-lg transition-all flex items-center justify-center gap-2 font-semibold">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/>
                                    <circle cx="9" cy="7" r="4"/>
                                    <path d="M23 21v-2a4 4 0 0 0-3-3.87"/>
                                    <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
                                </svg>
                                <span>Twitch Following</span>
                            </a>
                        </div>
                    </div>
                `;
                winnerNames.appendChild(winnerElement);
                attachWinnerActions(winnerElement, winner, winnerUserId);
                
                // Load all messages from Twitch immediately - всегда загружаем заново для победителя
                if (accessToken && currentUserId && winnerUserId) {
                    // Сбрасываем флаг загрузки, чтобы всегда загружать заново для победителя
                    const lower = winner.toLowerCase();
                    userChatHistoryMeta[lower] = { ...(userChatHistoryMeta[lower] || {}), twitchFetched: false };
                    
                    // Всегда загружаем все сообщения за все время через Twitch Moderation API
                    console.log(`Загрузка всех сообщений для победителя ${winner}...`);
                    fetchTwitchChatHistoryForUser(winner, winnerUserId, null)
                            .then(history => {
                                // Всегда обновляем, даже если история пустая
                                mergeChatHistoryEntries(winner, history || []);
                                const updatedCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                                
                                console.log(`Загружено ${updatedCount} сообщений для победителя ${winner}`);
                                
                                // Update badge in this specific element
                                const badgeElement = winnerElement.querySelector('.message-count-text');
                                if (badgeElement) {
                                    badgeElement.textContent = `Сообщений: ${updatedCount}`;
                                }
                                
                                // Update total count badge
                                updateWinnerMessageCount();
                            })
                            .catch(error => {
                                console.error('Ошибка загрузки сообщений для', winner, error);
                                // Даже при ошибке обновляем счетчик с текущими данными
                                const updatedCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                                const badgeElement = winnerElement.querySelector('.message-count-text');
                                if (badgeElement) {
                                    badgeElement.textContent = `Сообщений: ${updatedCount}`;
                                }
                                updateWinnerMessageCount();
                            });
                } else {
                    // Нет доступа, показываем текущий счет
                    const updatedCount = userChatHistory[winner] ? userChatHistory[winner].length : 0;
                    const badgeElement = winnerElement.querySelector('.message-count-text');
                    if (badgeElement) {
                        badgeElement.textContent = `Сообщений: ${updatedCount}`;
                    }
                }
            });
            
            // Update message count badge
            updateWinnerMessageCount();
            
            // Add new winners to recent winners (replace old ones)
            // Remove previous winners from the same giveaway
            recentWinners = recentWinners.filter(w => w.giveaway !== currentGiveawayForReroll.name);
            
            newWinners.forEach(winner => {
                // Find user ID from participants if available
                const participant = giveawayParticipants[currentGiveawayForReroll.id] ? 
                    giveawayParticipants[currentGiveawayForReroll.id].find(p => (typeof p === 'string' ? p : p.username) === winner) : null;
                
                recentWinners.unshift({
                    id: Date.now().toString() + Math.random(),
                    username: winner,
                    userId: participant && typeof participant === 'object' ? participant.userId : null,
                    giveaway: currentGiveawayForReroll.name,
                    time: new Date(), // Сохраняем реальную дату
                    timeText: 'только что'
                });
            });
            
            // Limit recent winners to 6
            recentWinners = recentWinners.slice(0, 6);
            
            // Save data after reroll
            saveData();
            
            renderRecentWinners();
            
            showNotification(`Победители перевыбраны для "${currentGiveawayForReroll.name}"!`, 'success');
            
            // Update current winners and restart monitoring
            currentWinners = newWinners;
            startWinnerMonitoring();
        });

        // Mobile menu
        mobileActionBtn.addEventListener('click', () => {
            mobileMenu.classList.remove('hidden');
        });

        closeMobileMenu.addEventListener('click', () => {
            mobileMenu.classList.add('hidden');
        });

        // Fetch real viewer count from Twitch API
        async function fetchViewerCount() {
            if (!accessToken || !twitchChannel) return;
            
            try {
                const response = await fetch(`https://api.twitch.tv/helix/streams?user_login=${twitchChannel}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.data && data.data.length > 0) {
                        const stream = data.data[0];
                        const viewers = stream.viewer_count;
                        updateViewerCount(viewers);
                    } else {
                        // Stream is offline
                        updateViewerCount(0);
                    }
                } else {
                    console.error('Ошибка получения данных о зрителях:', response.status);
                }
            } catch (error) {
                console.error('Ошибка при запросе количества зрителей:', error);
            }
        }

        // Update viewer count display
        function updateViewerCount(count) {
            let statusText;
            if (count === 0) {
                statusText = t('offline');
            } else {
                const viewerWord = count === 1 ? t('viewer') : count < 5 ? t('viewersPlural') : t('viewers');
                statusText = `${count} ${viewerWord}`;
            }
            
            viewerCount.textContent = statusText;
            
            // Update viewer count color based on status
            if (count === 0) {
                viewerCount.className = 'bg-gray-600 text-xs px-2 py-1 rounded-full';
            } else {
                viewerCount.className = 'bg-purple-900 text-xs px-2 py-1 rounded-full';
            }
        }

        // Format time ago
        function formatTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return t('justNow');
            
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) {
                if (minutes === 1) return t('minuteAgo');
                return `${minutes} ${t('minutesAgo')}`;
            }
            
            const hours = Math.floor(minutes / 60);
            if (hours < 24) {
                if (hours === 1) return t('hourAgo');
                return `${hours} ${t('hoursAgo')}`;
            }
            
            const days = Math.floor(hours / 24);
            if (days === 1) return t('dayAgo');
            return `${days} ${t('daysAgo')}`;
        }

        // Add winner chat message
        // Add historical message to winner chat container
        function addHistoricalWinnerMessage(username, message, timestamp, color, userId) {
            // Get user avatar
            const avatarUrl = getUserAvatar(userId, username);
            
            // Apply privacy settings
            const displayUsername = globalSettings.hideUsernames ? '*******' : username;
            const shouldHideAvatar = globalSettings.hideAvatars;
            
            // Format timestamp
            const messageTime = timestamp instanceof Date ? timestamp : new Date(timestamp);
            const timeText = messageTime.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' });
            
            // Use provided color or default
            const userColor = color || '#9146FF';
            
            // Create message element
            const messageElement = document.createElement('div');
            messageElement.className = 'winner-chat-message mb-3 border-l-4 border-gray-500 pl-3 bg-gray-700 bg-opacity-20 p-2 rounded';
            
            messageElement.innerHTML = `
                <div class="flex items-start group">
                    <div class="w-8 h-8 rounded-full flex-shrink-0 flex items-center justify-center mr-2 mt-1 overflow-hidden" style="background-color: ${userColor}">
                        <img src="${avatarUrl}" alt="${username}" class="w-full h-full object-cover" 
                             data-user-id="${userId}" 
                             style="${shouldHideAvatar ? 'display: none;' : 'display: block;'}"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <span class="text-xs text-white ${shouldHideAvatar || avatarUrl.includes('ui-avatars.com') ? 'flex' : 'hidden'} w-full h-full items-center justify-center">${username.charAt(0).toUpperCase()}</span>
                    </div>
                    <div class="flex-1">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="font-medium" data-original-username="${username}" style="color: ${userColor}">${displayUsername}</span>
                                
                                <span class="text-gray-400 text-xs ml-2">${timeText}</span>
                            </div>
                            <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-all duration-300 flex-shrink-0">
                                <button class="mod-action mod-warn" 
                                        data-action="warn" data-user="${username}" title="Предупреждение (1 сек мут)">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="warnGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#FBBF24;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#F59E0B;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <path d="M12 2L2 22h20L12 2z" fill="url(#warnGradient)" stroke="#D97706" stroke-width="1.5" stroke-linejoin="round"/>
                                            <circle cx="12" cy="9" r="1.5" fill="#FFFFFF"/>
                                            <path d="M12 13v4" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"/>
                                        </svg>
                                    </span>
                                </button>
                                <button class="mod-action mod-timeout" 
                                        data-action="timeout" data-user="${username}" title="Мут на 10 минут">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="timeoutGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#FB923C;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#EA580C;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <path d="M11 5L6 9H2v6h4l5 4V5z" fill="url(#timeoutGradient)" stroke="#C2410C" stroke-width="1.2" stroke-linejoin="round"/>
                                            <path d="M19 9l-6 6M13 9l6 6" stroke="#FFFFFF" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                                        </svg>
                                    </span>
                                </button>
                                <button class="mod-action mod-ban" 
                                        data-action="ban" data-user="${username}" title="Постоянный бан">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="banGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#EF4444;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#DC2626;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <!-- Красный молоток -->
                                            <!-- Ручка молотка -->
                                            <path d="M10 10L10 18" stroke="#7F1D1D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                            <path d="M8 18L12 18" stroke="#7F1D1D" stroke-width="1.5" stroke-linecap="round"/>
                                            <!-- Голова молотка (красная с градиентом) -->
                                            <rect x="6" y="2" width="8" height="7" rx="1" fill="url(#banGradient)" stroke="#B91C1C" stroke-width="1"/>
                                            <rect x="7" y="3" width="6" height="5" rx="0.5" fill="#DC2626"/>
                                            <!-- Металлический клевешок -->
                                            <rect x="13" y="3.5" width="1.5" height="4" rx="0.3" fill="#9CA3AF" stroke="#6B7280" stroke-width="0.3"/>
                                        </svg>
                                    </span>
                                </button>
                            </div>
                        </div>
                        <p class="text-gray-100 whitespace-pre-wrap break-words">${formatMessageText(message)}</p>
                    </div>
                </div>
            `;
            
            winnerChatContainer.appendChild(messageElement);
            
            // Add event listeners to moderation buttons in winner chat
            messageElement.querySelectorAll('.mod-action').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const action = this.getAttribute('data-action');
                    const user = this.getAttribute('data-user');
                    handleModerationAction(action, user, messageElement);
                });
            });
        }
        
        function addWinnerChatMessage(username, message, tags, userId) {
            // Check if empty winner chat container
            if (winnerChatContainer.innerHTML.includes('Ожидание сообщений') || winnerChatContainer.innerHTML.includes('Загрузка') || winnerChatContainer.innerHTML.includes('Ожидание новых сообщений')) {
                winnerChatContainer.innerHTML = '';
            }
            
            // Mark winner as responded
            if (!winnerHasResponded) {
                winnerHasResponded = true;
                updateWinnerStatus(true);
                showNotification(`${username} ответил в чате!`, 'success');
            }
            
            // Get user color from tags or use default
            const userColor = tags['color'] || '#9146FF';
            
            // Get user avatar
            const avatarUrl = getUserAvatar(userId, username);
            
            // Apply privacy settings
            const displayUsername = globalSettings.hideUsernames ? '*******' : username;
            const shouldHideAvatar = globalSettings.hideAvatars;
            
            // Create message element
            const messageElement = document.createElement('div');
            messageElement.className = 'winner-chat-message mb-3 border-l-4 border-green-500 pl-3 bg-green-700 bg-opacity-20 p-2 rounded';
            
            messageElement.innerHTML = `
                <div class="flex items-start group">
                    <div class="w-8 h-8 rounded-full flex-shrink-0 flex items-center justify-center mr-2 mt-1 overflow-hidden" style="background-color: ${userColor}">
                        <img src="${avatarUrl}" alt="${username}" class="w-full h-full object-cover" 
                             data-user-id="${userId}" 
                             style="${shouldHideAvatar ? 'display: none;' : 'display: block;'}"
                             onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                        <span class="text-xs text-white ${shouldHideAvatar || avatarUrl.includes('ui-avatars.com') ? 'flex' : 'hidden'} w-full h-full items-center justify-center">${username.charAt(0).toUpperCase()}</span>
                    </div>
                    <div class="flex-1">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <span class="font-medium" data-original-username="${username}" style="color: ${userColor}">${displayUsername}</span>
                                
                                <span class="text-gray-400 text-xs ml-2">${new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}</span>
                            </div>
                            <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-all duration-300 flex-shrink-0">
                                <button class="mod-action mod-warn" 
                                        data-action="warn" data-user="${username}" title="Предупреждение (1 сек мут)">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="warnGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#FBBF24;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#F59E0B;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <path d="M12 2L2 22h20L12 2z" fill="url(#warnGradient)" stroke="#D97706" stroke-width="1.5" stroke-linejoin="round"/>
                                            <circle cx="12" cy="9" r="1.5" fill="#FFFFFF"/>
                                            <path d="M12 13v4" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round"/>
                                        </svg>
                                    </span>
                                </button>
                                <button class="mod-action mod-timeout" 
                                        data-action="timeout" data-user="${username}" title="Мут на 10 минут">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="timeoutGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#FB923C;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#EA580C;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <path d="M11 5L6 9H2v6h4l5 4V5z" fill="url(#timeoutGradient)" stroke="#C2410C" stroke-width="1.2" stroke-linejoin="round"/>
                                            <path d="M19 9l-6 6M13 9l6 6" stroke="#FFFFFF" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                                        </svg>
                                    </span>
                                </button>
                                <button class="mod-action mod-ban" 
                                        data-action="ban" data-user="${username}" title="Постоянный бан">
                                    <span class="relative z-10">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                            <defs>
                                                <linearGradient id="banGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                                    <stop offset="0%" style="stop-color:#EF4444;stop-opacity:1" />
                                                    <stop offset="100%" style="stop-color:#DC2626;stop-opacity:1" />
                                                </linearGradient>
                                            </defs>
                                            <!-- Красный молоток -->
                                            <!-- Ручка молотка -->
                                            <path d="M10 10L10 18" stroke="#7F1D1D" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                            <path d="M8 18L12 18" stroke="#7F1D1D" stroke-width="1.5" stroke-linecap="round"/>
                                            <!-- Голова молотка (красная с градиентом) -->
                                            <rect x="6" y="2" width="8" height="7" rx="1" fill="url(#banGradient)" stroke="#B91C1C" stroke-width="1"/>
                                            <rect x="7" y="3" width="6" height="5" rx="0.5" fill="#DC2626"/>
                                            <!-- Металлический клевешок -->
                                            <rect x="13" y="3.5" width="1.5" height="4" rx="0.3" fill="#9CA3AF" stroke="#6B7280" stroke-width="0.3"/>
                                        </svg>
                                    </span>
                                </button>
                            </div>
                        </div>
                        <p class="text-gray-100 whitespace-pre-wrap break-words">${formatMessageText(message)}</p>
                    </div>
                </div>
            `;
            
            winnerChatContainer.appendChild(messageElement);
            
            // Add event listeners to moderation buttons in winner chat
            messageElement.querySelectorAll('.mod-action').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const action = this.getAttribute('data-action');
                    const user = this.getAttribute('data-user');
                    handleModerationAction(action, user, messageElement);
                });
            });
            
            // Update message count badge
            updateWinnerMessageCount();
            
            // Auto scroll to bottom
            winnerChatContainer.scrollTop = winnerChatContainer.scrollHeight;
        }
        
        // Start winner monitoring
        function startWinnerMonitoring() {
            // Use timeout from settings
            winnerTimeLeft = channelSettings.responseTimeout || 60;
            winnerHasResponded = false;
            
            // Clear winner chat - показываем только новые сообщения после выбора победителя
            winnerChatContainer.innerHTML = '<div class="text-center text-gray-400 py-8">Ожидание сообщений от победителя...</div>';
            
            // Update status and timer display
            updateWinnerStatus(false);
            updateWinnerTimer();
            
            // Clear existing timer
            if (winnerTimer) {
                clearInterval(winnerTimer);
            }
            
            console.log('Запуск мониторинга победителя с таймером:', winnerTimeLeft, 'секунд');
            
            // Start new timer
            winnerTimer = setInterval(() => {
                if (winnerHasResponded) {
                    clearInterval(winnerTimer);
                    winnerTimer = null;
                    return;
                }
                
                winnerTimeLeft--;
                updateWinnerTimer();
                
                if (winnerTimeLeft <= 0) {
                    clearInterval(winnerTimer);
                    winnerTimer = null;
                    if (!winnerHasResponded) {
                        showNotification('Время ожидания истекло. Победитель не ответил.', 'error');
                    }
                }
            }, 1000);
        }
        
        // Stop winner monitoring
        function stopWinnerMonitoring() {
            if (winnerTimer) {
                clearInterval(winnerTimer);
                winnerTimer = null;
            }
            currentWinners = [];
            winnerHasResponded = false;
            winnerTimeLeft = channelSettings.responseTimeout || 60;
        }
        
        // Update winner timer display
        function updateWinnerTimer() {
            if (!winnerTimerDisplay) return;
            const minutes = Math.floor(winnerTimeLeft / 60);
            const seconds = winnerTimeLeft % 60;
            const timeText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Find the span element inside timer
            const timeSpan = winnerTimerDisplay.querySelector('span');
            if (timeSpan) {
                timeSpan.textContent = timeText;
            }
            
            // Change color and style based on response status
            if (winnerHasResponded) {
                winnerTimerDisplay.className = 'flex items-center gap-2 bg-green-900/80 backdrop-blur-sm border border-green-500/50 rounded-lg px-3 py-1.5 shadow-lg shadow-green-500/20';
                const dot = winnerTimerDisplay.querySelector('div');
                if (dot) {
                    dot.className = 'w-2 h-2 bg-green-500 rounded-full';
                    dot.classList.remove('animate-pulse');
                }
            } else {
                winnerTimerDisplay.className = 'flex items-center gap-2 bg-red-900/80 backdrop-blur-sm border border-red-500/50 rounded-lg px-3 py-1.5 shadow-lg shadow-red-500/20';
                const dot = winnerTimerDisplay.querySelector('div');
                if (dot) {
                    dot.className = 'w-2 h-2 bg-red-500 rounded-full animate-pulse';
                }
            }
        }
        
        // Update winner status indicator
        function updateWinnerStatus(hasResponded) {
            if (hasResponded) {
                // Stop timer when winner responds
                if (winnerTimer) {
                    clearInterval(winnerTimer);
                    winnerTimer = null;
                }
                // Update timer display to green
                updateWinnerTimer();
                showNotification('Таймер остановлен - победитель ответил!', 'success');
            } else {
                // Reset timer display to red
                if (winnerTimerDisplay) {
                    winnerTimerDisplay.className = 'flex items-center gap-2 bg-red-900/80 backdrop-blur-sm border border-red-500/50 rounded-lg px-3 py-1.5 shadow-lg shadow-red-500/20';
                    const dot = winnerTimerDisplay.querySelector('div');
                    if (dot) {
                        dot.className = 'w-2 h-2 bg-red-500 rounded-full animate-pulse';
                    }
                }
            }
        }

        // Get user avatar URL with real Twitch avatar
        function getUserAvatar(userId, username) {
            if (userId && avatarCache[userId]) {
                // Return cached real avatar
                return avatarCache[userId];
            } else if (userId) {
                // Start async fetch for real avatar and return placeholder
                fetchUserAvatar(userId, username).then(url => {
                    if (url !== avatarCache[userId]) {
                        // Update all existing avatars for this user
                        updateAvatarsInChat(userId, url);
                    }
                });
                // Return placeholder while loading
                return `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=9146FF&color=fff&size=70&rounded=true`;
            } else {
                // Fallback to a default avatar based on username
                return `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=9146FF&color=fff&size=70&rounded=true`;
            }
        }

        // Cache for user avatars
        const avatarCache = {};

        // Fetch real user avatar from Twitch API
        async function fetchUserAvatar(userId, username) {
            if (!userId || !accessToken) {
                const fallbackUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=9146FF&color=fff&size=70&rounded=true`;
                avatarCache[userId] = fallbackUrl;
                return fallbackUrl;
            }
            
            // Check cache first
            if (avatarCache[userId]) {
                return avatarCache[userId];
            }
            
            try {
                const response = await fetch(`https://api.twitch.tv/helix/users?id=${userId}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.data && data.data.length > 0) {
                        const avatarUrl = data.data[0].profile_image_url;
                        console.log(`Получен аватар для ${username}:`, avatarUrl);
                        avatarCache[userId] = avatarUrl;
                        return avatarUrl;
                    }
                }
            } catch (error) {
                console.error('Ошибка получения аватара:', error);
            }
            
            // Fallback
            const fallbackUrl = `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=9146FF&color=fff&size=70&rounded=true`;
            avatarCache[userId] = fallbackUrl;
            return fallbackUrl;
        }

        // Update avatars in chat after loading real ones
        function updateAvatarsInChat(userId, newAvatarUrl) {
            // Update all avatar images with this userId (both in chat and winners list)
            const avatarImages = document.querySelectorAll(`img[data-user-id="${userId}"]`);
            avatarImages.forEach(img => {
                if (newAvatarUrl && !newAvatarUrl.includes('ui-avatars.com')) {
                    img.src = newAvatarUrl;
                    img.style.display = 'block';
                    // Hide fallback text
                    const fallback = img.nextElementSibling;
                    if (fallback && fallback.tagName === 'SPAN') {
                        fallback.style.display = 'none';
                    }
                }
            });
        }

        // Preload avatars for active users
        function preloadUserAvatars() {
            // Get unique user IDs from recent participants
            const userIds = new Set();
            
            Object.values(giveawayParticipants).forEach(participants => {
                participants.forEach(participant => {
                    if (participant.userId) {
                        userIds.add(participant.userId);
                    }
                });
            });
            
            // Also add user IDs from recent winners
            recentWinners.forEach(winner => {
                if (winner.userId) {
                    userIds.add(winner.userId);
                }
            });
            
            // Preload avatars for these users
            userIds.forEach(userId => {
                if (!avatarCache[userId]) {
                    // Find username from winners or participants
                    let username = 'user';
                    const winner = recentWinners.find(w => w.userId === userId);
                    if (winner) {
                        username = winner.username;
                    }
                    
                    fetchUserAvatar(userId, username).then(url => {
                        // Update all avatars when loaded
                        updateAvatarsInChat(userId, url);
                    });
                }
            });
        }

        // Handle moderation actions
        async function handleModerationAction(action, username, messageElement) {
            let actionText = '';
            let actionColor = '';
            let success = false;
            let timeoutDuration = 0;
            
            // Get current timeout duration from settings
            const currentTimeoutMinutes = channelSettings.timeoutDuration || 10;
            const currentTimeoutSeconds = currentTimeoutMinutes * 60;
            
            // Disable buttons immediately to prevent spam
            if (messageElement) {
                messageElement.querySelectorAll('.mod-action').forEach(btn => {
                    btn.style.opacity = '0.5';
                    btn.disabled = true;
                    btn.style.pointerEvents = 'none';
                });
            }
            
            showNotification(`Выполняется модерация ${username}...`, 'info');
            
            switch(action) {
                case 'warn':
                    actionText = 'предупрежден';
                    actionColor = 'text-yellow-400';
                    timeoutDuration = 1;
                    // Send a 1-second timeout as warning
                    success = await sendModerationCommand(`/timeout ${username} 1`, username, 1);
                    if (success) {
                        showNotification(`${username} получил предупреждение`, 'success');
                    } else {
                        showNotification(`Ошибка при предупреждении ${username}`, 'error');
                    }
                    break;
                    
                case 'timeout':
                    actionText = `замучен на ${currentTimeoutMinutes} ${currentTimeoutMinutes === 1 ? 'минуту' : currentTimeoutMinutes < 5 ? 'минуты' : 'минут'}`;
                    actionColor = 'text-orange-400';
                    timeoutDuration = currentTimeoutSeconds;
                    // Send timeout with settings duration
                    success = await sendModerationCommand(`/timeout ${username} ${currentTimeoutSeconds}`, username, currentTimeoutSeconds);
                    if (success) {
                        showNotification(`${username} замучен на ${currentTimeoutMinutes} ${currentTimeoutMinutes === 1 ? 'минуту' : currentTimeoutMinutes < 5 ? 'минуты' : 'минут'}`, 'success');
                    } else {
                        showNotification(`Ошибка при муте ${username}`, 'error');
                    }
                    break;
                    
                case 'ban':
                    actionText = 'забанен';
                    actionColor = 'text-red-400';
                    // Send permanent ban
                    success = await sendModerationCommand(`/ban ${username}`, username);
                    if (success) {
                        showNotification(`${username} забанен`, 'success');
                    } else {
                        showNotification(`Ошибка при бане ${username}`, 'error');
                    }
                    break;
            }
            
            // Add moderation indicator to message only if successful
            if (messageElement && success) {
                const moderationBadge = document.createElement('span');
                
                // Determine badge class and icon based on action
                let badgeClass = 'mod-badge ';
                let badgeIcon = '';
                let badgeText = '';
                
                switch(action) {
                    case 'warn':
                        badgeClass += 'mod-badge-warned';
                        badgeIcon = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" style="display: inline; margin-right: 4px;">
                            <defs>
                                <linearGradient id="warnBadgeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#FCD34D;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#F59E0B;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <path d="M12 2L2 22h20L12 2z" fill="url(#warnBadgeGradient)" stroke="#F59E0B" stroke-width="1"/>
                            <circle cx="12" cy="17" r="1" fill="#FFFBEB"/>
                            <path d="M12 8v6" stroke="#FFFBEB" stroke-width="2" stroke-linecap="round"/>
                        </svg>`;
                        badgeText = 'ПРЕДУПРЕЖДЕН';
                        break;
                    case 'timeout':
                        badgeClass += 'mod-badge-timeout';
                        badgeIcon = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" style="display: inline; margin-right: 4px;">
                            <defs>
                                <linearGradient id="timeoutBadgeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#FB923C;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#EA580C;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <!-- Иконка звука -->
                            <path d="M11 5L6 9H2v6h4l5 4V5z" fill="url(#timeoutBadgeGradient)" stroke="#EA580C" stroke-width="1"/>
                            <path d="M19.07 4.93l-1.41 1.41A8.5 8.5 0 0 1 20.5 12a8.5 8.5 0 0 1-2.84 5.66l1.41 1.41A10.5 10.5 0 0 0 22.5 12a10.5 10.5 0 0 0-3.43-7.07z" fill="url(#timeoutBadgeGradient)"/>
                            <path d="M15.54 8.46l-1.41 1.41A2.5 2.5 0 0 1 15 12a2.5 2.5 0 0 1-.87 1.13l1.41 1.41A4.5 4.5 0 0 0 17 12a4.5 4.5 0 0 0-1.46-3.54z" fill="url(#timeoutBadgeGradient)"/>
                            <!-- Перечеркивание -->
                            <path d="M3 3l18 18" stroke="#FFF7ED" stroke-width="2" stroke-linecap="round"/>
                        </svg>`;
                        badgeText = `ЗАМУЧЕН НА ${currentTimeoutMinutes} МИН`;
                        break;
                    case 'ban':
                        badgeClass += 'mod-badge-banned';
                        badgeIcon = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" style="display: inline; margin-right: 4px;">
                            <defs>
                                <linearGradient id="banBadgeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#EF4444;stop-opacity:1" />
                                    <stop offset="100%" style="stop-color:#DC2626;stop-opacity:1" />
                                </linearGradient>
                            </defs>
                            <!-- Красный круг -->
                            <circle cx="12" cy="12" r="10" fill="url(#banBadgeGradient)" stroke="#DC2626" stroke-width="1"/>
                            <!-- Горизонтальная линия в середине -->
                            <path d="M6 12h12" stroke="#FEF2F2" stroke-width="2" stroke-linecap="round"/>
                        </svg>`;
                        badgeText = 'ЗАБАНЕН';
                        break;
                }
                
                moderationBadge.className = badgeClass;
                moderationBadge.innerHTML = `${badgeIcon}${badgeText}`;
                moderationBadge.style.marginLeft = '8px';
                
                // Find the username element and add badge after it
                const usernameElement = messageElement.querySelector('.font-medium');
                if (usernameElement && usernameElement.parentNode) {
                    usernameElement.parentNode.insertBefore(moderationBadge, usernameElement.nextSibling);
                }
            } else if (messageElement && !success) {
                // Re-enable buttons if action failed
                messageElement.querySelectorAll('.mod-action').forEach(btn => {
                    btn.style.opacity = '1';
                    btn.disabled = false;
                    btn.style.pointerEvents = 'auto';
                });
            }
        }
        
        // Send moderation command to Twitch (if connected)
        async function sendModerationCommand(command, username, duration = null) {
            if (!accessToken || !twitchChannel) {
                showNotification('Нет доступа к API Twitch для модерации', 'error');
                return false;
            }

            try {
                let apiUrl = '';
                let requestBody = {};
                let method = 'POST';

                // Determine API endpoint based on command
                if (command.startsWith('/timeout')) {
                    // Use Twitch API for timeout
                    apiUrl = `https://api.twitch.tv/helix/moderation/bans`;
                    requestBody = {
                        data: {
                            user_id: await getUserIdByUsername(username),
                            duration: duration || 600, // 10 minutes default
                            reason: 'Модерация через Twitch Giveaways'
                        }
                    };
                } else if (command.startsWith('/ban')) {
                    // Use Twitch API for ban
                    apiUrl = `https://api.twitch.tv/helix/moderation/bans`;
                    requestBody = {
                        data: {
                            user_id: await getUserIdByUsername(username),
                            reason: 'Модерация через Twitch Giveaways'
                        }
                    };
                } else {
                    // For warnings, just send through IRC
                    if (twitchWebSocket && twitchWebSocket.readyState === WebSocket.OPEN) {
                        twitchWebSocket.send(`PRIVMSG #${twitchChannel} :/timeout ${username} 1`);
                        return true;
                    }
                    return false;
                }

                // Get broadcaster ID (your channel ID)
                const broadcasterData = await fetch(`https://api.twitch.tv/helix/users?login=${twitchChannel}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });

                if (!broadcasterData.ok) {
                    throw new Error('Не удалось получить ID канала');
                }

                const broadcasterInfo = await broadcasterData.json();
                const broadcasterId = broadcasterInfo.data[0].id;

                // Add broadcaster_id to URL params
                const urlParams = new URLSearchParams({
                    broadcaster_id: broadcasterId,
                    moderator_id: broadcasterId // Same as broadcaster for self-moderation
                });

                // Send moderation request
                const response = await fetch(`${apiUrl}?${urlParams}`, {
                    method: method,
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                if (response.ok) {
                    console.log(`Команда модерации выполнена: ${command} для ${username}`);
                    return true;
                } else {
                    const errorData = await response.json();
                    console.error('Ошибка API модерации:', errorData);
                    
                    // Fallback to IRC command
                    if (twitchWebSocket && twitchWebSocket.readyState === WebSocket.OPEN) {
                        twitchWebSocket.send(`PRIVMSG #${twitchChannel} :${command}`);
                        console.log(`Отправлена IRC команда: ${command}`);
                        return true;
                    }
                    return false;
                }
            } catch (error) {
                console.error('Ошибка отправки команды модерации:', error);
                
                // Fallback to IRC command
                if (twitchWebSocket && twitchWebSocket.readyState === WebSocket.OPEN) {
                    try {
                        twitchWebSocket.send(`PRIVMSG #${twitchChannel} :${command}`);
                        console.log(`Отправлена IRC команда как fallback: ${command}`);
                        return true;
                    } catch (ircError) {
                        console.error('Ошибка IRC команды:', ircError);
                        return false;
                    }
                }
                return false;
            }
        }

        // Get user ID by username
        async function getUserIdByUsername(username) {
            try {
                const response = await fetch(`https://api.twitch.tv/helix/users?login=${username.toLowerCase()}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': TWITCH_CLIENT_ID
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.data && data.data.length > 0) {
                        return data.data[0].id;
                    }
                }
            } catch (error) {
                console.error('Ошибка получения ID пользователя:', error);
            }
            return null;
        }

        // Update winner times periodically
        function updateWinnerTimes() {
            // Update time text for all winners
            const winnerTimeElements = document.querySelectorAll('.winner-time-text');
            
            winnerTimeElements.forEach((element, index) => {
                if (recentWinners[index] && recentWinners[index].time instanceof Date) {
                    element.textContent = formatTimeAgo(recentWinners[index].time);
                }
            });
        }

        // Clear only winners function
        function clearWinnersHistory() {
            if (!twitchChannel) return;
            
            // Show confirmation modal
            showConfirmationModal(
                'Очистить историю победителей?',
                'Это действие удалит всех последних победителей из списка. Данные нельзя будет восстановить.',
                () => {
                    // Clear winners data
                    recentWinners = [];
                    localStorage.removeItem(`by_CTPAX_winners_${twitchChannel}`);
                    
                    renderRecentWinners();
                    showNotification('История победителей очищена', 'success');
                }
            );
        }
        
        // Check if user is by_CTPAX
        function checkIfby_CTPAX(username) {
    return (username || '').toLowerCase() === 'by_ctpax';
}
        
        // Load global settings (for all users) - унифицированная версия
        function loadGlobalSettings() {
            try {
                // Используем единый ключ для всех настроек
                const saved = localStorage.getItem('app_global_user_settings');
                
                // Default settings
                const defaultSettings = {
                    hideUsernames: false,
                    hideAvatars: false,
                    language: 'ru',
                    hideMyUsername: false,
                    disableStatistics: false,
                    registrationDate: '2025-07-06'
                };
                
                if (saved) {
                    try {
                        const savedSettings = JSON.parse(saved);
                        globalSettings = { ...defaultSettings, ...savedSettings };
                        console.log('Глобальные настройки загружены:', globalSettings);
                    } catch (parseError) {
                        console.error('Ошибка парсинга настроек:', parseError);
                        // If parsing fails, use defaults
                        globalSettings = defaultSettings;
                        saveGlobalSettings();
                    }
                } else {
                    // No saved settings, use defaults
                    globalSettings = defaultSettings;
                    saveGlobalSettings();
                    console.log('Настройки не найдены, используются значения по умолчанию');
                }
                
                // Apply settings to UI and functionality
                if (typeof applyGlobalSettingsToUI === 'function') {
                    applyGlobalSettingsToUI();
                }
                
                if (typeof applyGlobalSettingsToChat === 'function') {
                    applyGlobalSettingsToChat();
                }
                
                // Apply language to interface with delay
                setTimeout(() => {
                    if (typeof applyLanguageToInterface === 'function') {
                        applyLanguageToInterface();
                    }
                }, 100);
                
            } catch (error) {
                console.error('Ошибка загрузки настроек:', error);
                
                // Fallback to safe defaults
                globalSettings = {
                    hideUsernames: false,
                    hideAvatars: false,
                    language: 'ru',
                    hideMyUsername: false,
                    disableStatistics: false,
                    registrationDate: '2025-07-06'
                };
                
                // Try to save fallback settings
                try {
                    saveGlobalSettings();
                } catch (saveError) {
                    console.error('Не удалось сохранить настройки по умолчанию:', saveError);
                }
            }
        }

        // Save global settings
        function saveGlobalSettings() {
            try {
                localStorage.setItem('app_global_user_settings', JSON.stringify(globalSettings));
                console.log('Настройки сохранены в localStorage:', globalSettings);
            } catch (error) {
                console.error('Ошибка сохранения настроек:', error);
            }
        }
        
        // Update language buttons
        function updateLanguageButtons(activeLanguage) {
            try {
                console.log('Обновление кнопок языка, активный:', activeLanguage);
                
                const languageButtons = document.querySelectorAll('.language-btn');
                languageButtons.forEach(btn => {
                    btn.className = 'language-btn px-4 py-2 rounded-lg border border-gray-600 text-gray-300 hover:text-white hover:border-purple-500 transition-all duration-200';
                });
                
                const activeLangBtn = document.getElementById(`lang${activeLanguage.toUpperCase()}`);
                if (activeLangBtn) {
                    activeLangBtn.className = 'language-btn px-4 py-2 rounded-lg border border-purple-500 bg-purple-600 text-white';
                    console.log('Активирована кнопка языка:', activeLanguage);
                } else {
                    console.warn('Кнопка для языка не найдена:', activeLanguage);
                }
            } catch (error) {
                console.error('Ошибка обновления кнопок языка:', error);
            }
        }
        
        // Apply global settings to chat display
        function applyGlobalSettingsToChat() {
            // Update existing chat messages with new settings
            const chatMessages = document.querySelectorAll('.chat-message, .winner-chat-message');
            
            chatMessages.forEach(message => {
                // Handle username hiding
                const usernameElement = message.querySelector('.font-medium');
                if (usernameElement && globalSettings.hideUsernames) {
                    const originalText = usernameElement.getAttribute('data-original-username') || usernameElement.textContent;
                    usernameElement.setAttribute('data-original-username', originalText);
                    usernameElement.textContent = '*******';
                } else if (usernameElement && !globalSettings.hideUsernames) {
                    const originalText = usernameElement.getAttribute('data-original-username');
                    if (originalText) {
                        usernameElement.textContent = originalText;
                    }
                }
                
                // Handle avatar hiding
                const avatarImg = message.querySelector('img[data-user-id]');
                const avatarSpan = message.querySelector('.text-xs.text-white');
                if (avatarImg && avatarSpan) {
                    if (globalSettings.hideAvatars) {
                        avatarImg.style.display = 'none';
                        avatarSpan.style.display = 'flex';
                    } else {
                        avatarImg.style.display = 'block';
                        avatarSpan.style.display = avatarImg.complete && !avatarImg.src.includes('ui-avatars.com') ? 'none' : 'flex';
                    }
                }
            });
        }
        
        // Collect global settings from UI
        function collectGlobalSettingsFromUI() {
            try {
                const elements = {
                    hideUsernames: document.getElementById('hideUsernames'),
                    hideAvatars: document.getElementById('hideAvatars'),
                    hideMyUsername: document.getElementById('hideMyUsername'),
                    disableStatistics: document.getElementById('disableStatistics')
                };
                
                Object.keys(elements).forEach(key => {
                    const element = elements[key];
                    if (element && element.type === 'checkbox') {
                        globalSettings[key] = element.checked;
                    }
                });
                function applyGlobalSettingsToUI() {
    try {
        // Update checkboxes
        const hideUsernamesEl = document.getElementById('hideUsernames');
        if (hideUsernamesEl) hideUsernamesEl.checked = globalSettings.hideUsernames;
        
        const hideAvatarsEl = document.getElementById('hideAvatars');
        if (hideAvatarsEl) hideAvatarsEl.checked = globalSettings.hideAvatars;
        
        const hideMyUsernameEl = document.getElementById('hideMyUsername');
        if (hideMyUsernameEl) hideMyUsernameEl.checked = globalSettings.hideMyUsername;
        
        const disableStatisticsEl = document.getElementById('disableStatistics');
        if (disableStatisticsEl) disableStatisticsEl.checked = globalSettings.disableStatistics;
        
        // Update language buttons
        updateLanguageButtons(globalSettings.language);
        
        console.log('Global settings applied to UI');
    } catch (error) {
        console.error('Error applying settings to UI:', error);
    }
}
                
                console.log('Глобальные настройки собраны из UI:', globalSettings);
                
            } catch (error) {
                console.error('Ошибка сбора глобальных настроек из UI:', error);
            }
        }
        
        // Clear giveaway history
        function clearGiveawayHistory() {
            showConfirmationModal(
                'Очистить историю розыгрышей?',
                'Это действие удалит всю вашу историю участия в розыгрышах. Данные нельзя будет восстановить.',
                () => {
                    // Clear only user's participation data, not the entire giveaway system
                    Object.keys(giveawayParticipants).forEach(giveawayId => {
                        const participants = giveawayParticipants[giveawayId];
                        if (Array.isArray(participants)) {
                            giveawayParticipants[giveawayId] = participants.filter(p => {
                                const participantName = typeof p === 'string' ? p : p.username;
                                return participantName.toLowerCase() !== currentUsername.toLowerCase();
                            });
                        }
                    });
                    
                    // Remove user from winners list
                    recentWinners = recentWinners.filter(winner => 
                        winner.username.toLowerCase() !== currentUsername.toLowerCase()
                    );
                    
                    // Update displays
                    renderActiveGiveaways();
                    renderRecentWinners();
                    saveData();
                    
                    showNotification('Ваша история розыгрышей очищена', 'success');
                }
            );
        }
        
        // Delete account
        function deleteAccount() {
            showConfirmationModal(
                'Удалить аккаунт с сайта?',
                'Это действие выйдет из аккаунта и очистит ваши данные розыгрышей. Глобальные настройки интерфейса сохранятся.',
                () => {
                    // Clear auth data
                    localStorage.removeItem('twitch_access_token');
                    
                    // Clear user-specific data from giveaways and winners but keep global settings
                    clearGiveawayHistory();
                    
                    // Clear channel-specific data
                    if (twitchChannel) {
                        localStorage.removeItem(`by_CTPAX_winners_${twitchChannel}`);
                        localStorage.removeItem(`by_CTPAX_giveaways_${twitchChannel}`);
                        localStorage.removeItem(`by_CTPAX_participants_${twitchChannel}`);
                        localStorage.removeItem(`by_CTPAX_chat_history_${twitchChannel}`);
                    }
                    
                    // DON'T remove global settings - they should persist
                    // localStorage.removeItem('by_CTPAX_user_settings'); // Не удаляем!
                    
                    // Disconnect and reload
                    if (twitchWebSocket) {
                        twitchWebSocket.close();
                    }
                    
                    showNotification('Аккаунт отключен, настройки интерфейса сохранены', 'success');
                    
                    setTimeout(() => {
                        window.location.reload();
                    }, 2000);
                }
            );
        }
        
        // Report bug or suggest idea
        function reportBugOrIdea() {
            const userAgent = navigator.userAgent;
            const url = window.location.href;
            const timestamp = new Date().toISOString();
            
            const emailBody = `
Привет! Я хочу сообщить об ошибке или предложить идею для Twitch Giveaways:

ОПИСАНИЕ:
[Опишите ошибку или вашу идею здесь]

ТЕХНИЧЕСКАЯ ИНФОРМАЦИЯ:
- Дата: ${timestamp}
- Браузер: ${userAgent}
- URL: ${url}
- Пользователь: ${currentUsername || 'Не авторизован'}

ШАГИ ДЛЯ ВОСПРОИЗВЕДЕНИЯ (для ошибок):
1. [Опишите шаги]
2. [что вы делали]
3. [когда произошла ошибка]

ОЖИДАЕМОЕ ПОВЕДЕНИЕ:
[Что должно было произойти]

ФАКТИЧЕСКОЕ ПОВЕДЕНИЕ:
[Что произошло на самом деле]

Спасибо за улучшение сервиса!
            `.trim();
            
            const mailtoLink = `mailto:support@by_CTPAX.com?subject=Bug Report / Feature Request - Twitch Giveaways&body=${encodeURIComponent(emailBody)}`;
            
            try {
                window.open(mailtoLink, '_blank');
                showNotification('Клиент электронной почты открыт', 'success');
            } catch (error) {
                // Fallback - copy to clipboard
                navigator.clipboard.writeText(emailBody).then(() => {
                    showNotification('Шаблон отчета скопирован в буфер обмена', 'success');
                }).catch(() => {
                    showNotification('Отправьте отчет на: support@by_CTPAX.com', 'info');
                });
            }
        }
        
        // Load channel settings
        function loadChannelSettings() {
            if (!isby_CTPAX|| !twitchChannel) return;
            
            try {
                const settingsKey = `by_CTPAX_channel_settings_${twitchChannel}`;
                const saved = localStorage.getItem(settingsKey);
                
                if (saved) {
                    const savedSettings = JSON.parse(saved);
                    // Merge with defaults to ensure all properties exist
                    channelSettings = {
                        autoAnnounce: true,
                        soundNotifications: false,
                        responseTimeout: 60,
                        autoModeration: false,
                        timeoutDuration: 10,
                        bannedWords: [],
                        maxParticipants: 1000,
                        minFollowDays: 0,
                        followersOnly: false,
                        ...savedSettings
                    };
                    console.log('Настройки канала загружены:', channelSettings);
                } else {
                    console.log('Настройки канала не найдены, используются по умолчанию');
                    // Save default settings
                    saveChannelSettings();
                }
                
                // Force apply settings to UI after a short delay
                setTimeout(() => {
                    applyChannelSettingsToUI();
                    updateTimeoutDuration();
                    updateResponseTimeout();
                }, 200);
                
            } catch (error) {
                console.error('Ошибка загрузки настроек канала:', error);
                // Reset to defaults on error
                channelSettings = {
                    autoAnnounce: true,
                    soundNotifications: false,
                    responseTimeout: 60,
                    autoModeration: false,
                    timeoutDuration: 10,
                    bannedWords: [],
                    maxParticipants: 1000,
                    minFollowDays: 0,
                    followersOnly: false
                };
            }
        }
        
        // Save channel settings
        function saveChannelSettings() {
            if (!isby_CTPAX || !twitchChannel) return;
            
            try {
                const settingsKey = `by_CTPAX_channel_settings_${twitchChannel}`;
                const settingsToSave = JSON.stringify(channelSettings);
                
                localStorage.setItem(settingsKey, settingsToSave);
                console.log('Настройки канала сохранены для канала:', twitchChannel);
                console.log('Сохраненные настройки:', channelSettings);
                
                // Verify the save was successful
                const verification = localStorage.getItem(settingsKey);
                if (verification === settingsToSave) {
                    showNotification('Настройки канала сохранены и проверены!', 'success');
                } else {
                    throw new Error('Верификация сохранения не прошла');
                }
                
                // Immediately update all dependent variables
                updateTimeoutDuration();
                updateResponseTimeout();
                
            } catch (error) {
                console.error('Ошибка сохранения настроек канала:', error);
                showNotification('Ошибка сохранения настроек: ' + error.message, 'error');
            }
        }
        
        // Apply channel settings to UI
        function applyChannelSettingsToUI() {
            if (!isby_CTPAX) return;
            
            try {
                console.log('Применение настроек к UI:', channelSettings);
                
                const elements = {
                    autoAnnounce: document.getElementById('autoAnnounce'),
                    soundNotifications: document.getElementById('soundNotifications'),
                    responseTimeout: document.getElementById('responseTimeout'),
                    autoModeration: document.getElementById('autoModeration'),
                    timeoutDuration: document.getElementById('timeoutDuration'),
                    bannedWords: document.getElementById('bannedWords'),
                    maxParticipants: document.getElementById('maxParticipants'),
                    minFollowDays: document.getElementById('minFollowDays'),
                    followersOnly: document.getElementById('followersOnly')
                };
                
                // Apply settings with detailed logging
                Object.keys(elements).forEach(key => {
                    const element = elements[key];
                    if (element) {
                        const setting = channelSettings[key];
                        if (element.type === 'checkbox') {
                            element.checked = Boolean(setting);
                            console.log(`Установлен ${key}:`, element.checked);
                        } else if (element.type === 'number' || element.tagName === 'SELECT') {
                            element.value = setting;
                            console.log(`Установлен ${key}:`, element.value);
                        } else if (element.tagName === 'TEXTAREA') {
                            element.value = Array.isArray(setting) ? setting.join(', ') : setting;
                            console.log(`Установлен ${key}:`, element.value);
                        }
                    } else {
                        console.warn(`Элемент ${key} не найден в DOM`);
                    }
                });
                
                console.log('UI успешно обновлен настройками канала');
                
                // Update global timeout variables
                updateTimeoutDuration();
                updateResponseTimeout();
                
                // Show current settings in console for debugging
                console.log('Текущие настройки после применения:', {
                    timeoutDuration: channelSettings.timeoutDuration,
                    responseTimeout: channelSettings.responseTimeout,
                    autoAnnounce: channelSettings.autoAnnounce,
                    autoModeration: channelSettings.autoModeration
                });
                
            } catch (error) {
                console.error('Ошибка применения настроек к UI:', error);
            }
        }
        
        // Collect channel settings from UI
        function collectChannelSettingsFromUI() {
            if (!isby_CTPAX) return;
            
            try {
                console.log('Сбор настроек из UI...');
                
                const elements = {
                    autoAnnounce: document.getElementById('autoAnnounce'),
                    soundNotifications: document.getElementById('soundNotifications'),
                    responseTimeout: document.getElementById('responseTimeout'),
                    autoModeration: document.getElementById('autoModeration'),
                    timeoutDuration: document.getElementById('timeoutDuration'),
                    bannedWords: document.getElementById('bannedWords'),
                    maxParticipants: document.getElementById('maxParticipants'),
                    minFollowDays: document.getElementById('minFollowDays'),
                    followersOnly: document.getElementById('followersOnly')
                };
                
                // Collect settings with validation
                if (elements.autoAnnounce) {
                    channelSettings.autoAnnounce = elements.autoAnnounce.checked;
                    console.log('autoAnnounce собран:', channelSettings.autoAnnounce);
                }
                
                if (elements.soundNotifications) {
                    channelSettings.soundNotifications = elements.soundNotifications.checked;
                    console.log('soundNotifications собран:', channelSettings.soundNotifications);
                }
                
                if (elements.responseTimeout) {
                    const timeout = parseInt(elements.responseTimeout.value);
                    channelSettings.responseTimeout = isNaN(timeout) ? 60 : Math.max(30, Math.min(300, timeout));
                    console.log('responseTimeout собран:', channelSettings.responseTimeout);
                }
                
                if (elements.autoModeration) {
                    channelSettings.autoModeration = elements.autoModeration.checked;
                    console.log('autoModeration собран:', channelSettings.autoModeration);
                }
                
                if (elements.timeoutDuration) {
                    const duration = parseInt(elements.timeoutDuration.value);
                    channelSettings.timeoutDuration = isNaN(duration) ? 10 : Math.max(1, Math.min(1440, duration));
                    console.log('timeoutDuration собран:', channelSettings.timeoutDuration);
                }
                
                if (elements.bannedWords) {
                    const bannedWordsText = elements.bannedWords.value.trim();
                    channelSettings.bannedWords = bannedWordsText ? 
                        bannedWordsText.split(',').map(word => word.trim()).filter(word => word.length > 0) : [];
                    console.log('bannedWords собран:', channelSettings.bannedWords);
                }
                
                if (elements.maxParticipants) {
                    const maxP = parseInt(elements.maxParticipants.value);
                    channelSettings.maxParticipants = isNaN(maxP) ? 1000 : Math.max(1, maxP);
                    console.log('maxParticipants собран:', channelSettings.maxParticipants);
                }
                
                if (elements.minFollowDays) {
                    const minDays = parseInt(elements.minFollowDays.value);
                    channelSettings.minFollowDays = isNaN(minDays) ? 0 : Math.max(0, minDays);
                    console.log('minFollowDays собран:', channelSettings.minFollowDays);
                }
                
                if (elements.followersOnly) {
                    channelSettings.followersOnly = elements.followersOnly.checked;
                    console.log('followersOnly собран:', channelSettings.followersOnly);
                }
                
                console.log('Все настройки собраны:', channelSettings);
                
            } catch (error) {
                console.error('Ошибка сбора настроек из UI:', error);
            }
        }
        
        // Update statistics in settings
        function updateChannelStatistics() {
            if (!isby_CTPAX) return;
            
            try {
                // Calculate total giveaways from localStorage
                let totalGiveaways = 0;
                let totalParticipants = 0;
                
                // Get all stored giveaway data
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('by_CTPAX_giveaways_')) {
                        try {
                            const giveaways = JSON.parse(localStorage.getItem(key) || '[]');
                            totalGiveaways += giveaways.length;
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }
                    if (key && key.startsWith('by_CTPAX_participants_')) {
                        try {
                            const participants = JSON.parse(localStorage.getItem(key) || '{}');
                            Object.values(participants).forEach(pList => {
                                if (Array.isArray(pList)) {
                                    totalParticipants += pList.length;
                                }
                            });
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }
                }
                
                const totalWinners = recentWinners.length;
                
                // Update UI
                document.getElementById('totalGiveaways').textContent = totalGiveaways;
                document.getElementById('totalWinners').textContent = totalWinners;
                document.getElementById('totalParticipants').textContent = totalParticipants;
            } catch (error) {
                console.error('Ошибка обновления статистики:', error);
            }
        }
        
        // Export data function
        function exportChannelData() {
            if (!isby_CTPAX) return;
            
            try {
                const exportData = {
                    exported: new Date().toISOString(),
                    channel: twitchChannel,
                    settings: channelSettings,
                    giveaways: activeGiveaways,
                    winners: recentWinners,
                    participants: giveawayParticipants
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `by_CTPAX_data_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                showNotification('Данные экспортированы', 'success');
            } catch (error) {
                console.error('Ошибка экспорта данных:', error);
                showNotification('Ошибка экспорта данных', 'error');
            }
        }
        
        // Clear all data function (enhanced for by_CTPAX)
        function clearAllChannelData() {
            if (!isby_CTPAX) return;
            
            showConfirmationModal(
                'Очистить ВСЕ данные канала?',
                'Это действие удалит все розыгрыши, победителей, участников и настройки. Данные нельзя будет восстановить!',
                () => {
                    // Clear all localStorage data related to by_CTPAX
                    const keysToRemove = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && key.startsWith('by_CTPAX_')) {
                            keysToRemove.push(key);
                        }
                    }
                    
                    keysToRemove.forEach(key => localStorage.removeItem(key));
                    
                    // Reset all data
                    recentWinners = [];
                    activeGiveaways = [];
                    giveawayParticipants = {};
                    channelSettings = {
                        autoAnnounce: true,
                        soundNotifications: false,
                        responseTimeout: 60,
                        autoModeration: false,
                        timeoutDuration: 10,
                        bannedWords: [],
                        maxParticipants: 1000,
                        minFollowDays: 0,
                        followersOnly: false
                    };
                    
                    // Update UI
                    renderActiveGiveaways();
                    renderRecentWinners();
                    applyChannelSettingsToUI();
                    updateChannelStatistics();
                    
                    showNotification('Все данные канала очищены', 'success');
                }
            );
        }
        
        // Загрузка всех пользователей из visitors.json и создание записей
        async function loadUsersFromVisitors() {
            if (!USE_SERVER || !isby_CTPAX) return;
            
            try {
                // Загружаем список удаленных пользователей (может быть массив ID или объектов с id и deletedAt)
                const deletedUsersRaw = JSON.parse(localStorage.getItem('by_CTPAX_deleted_users') || '[]');
                // Преобразуем в формат { id: string, deletedAt: string }
                const deletedUsersMap = {};
                deletedUsersRaw.forEach(item => {
                    if (typeof item === 'string') {
                        // Старый формат (только ID)
                        deletedUsersMap[item] = { id: item, deletedAt: null };
                    } else if (item && item.id) {
                        // Новый формат (объект с id и deletedAt)
                        deletedUsersMap[item.id] = item;
                    }
                });
                
                // Загружаем всех посетителей с action="auth" (только те, кто реально зашел на сайт)
                const response = await fetch(`${SERVER_URL}/api/visitors?limit=10000`);
                if (!response.ok) throw new Error('Server error');
                const data = await response.json();
                
                if (data.success && data.visitors && Array.isArray(data.visitors)) {
                    let newUsersAdded = 0;
                    let updatedUsers = 0;
                    let restoredUsers = 0;
                    
                    // Группируем посетителей по username, берем последнюю запись для каждого
                    const visitorsByUser = {};
                    data.visitors.forEach(visitor => {
                        // Берем только записи с action="auth" (реальная авторизация)
                        if (visitor.action === 'auth' && visitor.username && visitor.userId) {
                            const username = visitor.username.toLowerCase();
                            if (!visitorsByUser[username] || 
                                new Date(visitor.timestamp) > new Date(visitorsByUser[username].timestamp)) {
                                visitorsByUser[username] = visitor;
                            }
                        }
                    });
                    
                    // Создаем или обновляем пользователей
                    for (const [username, visitor] of Object.entries(visitorsByUser)) {
                        const visitorTimestamp = new Date(visitor.timestamp);
                        const deletedUserInfo = deletedUsersMap[visitor.userId];
                        
                        // Если пользователь был удален, проверяем, есть ли новая запись после удаления
                        if (deletedUserInfo) {
                            if (deletedUserInfo.deletedAt) {
                                const deletedAt = new Date(deletedUserInfo.deletedAt);
                                // Если новая запись после удаления - восстанавливаем пользователя
                                if (visitorTimestamp > deletedAt) {
                                    // Удаляем из списка удаленных
                                    delete deletedUsersMap[visitor.userId];
                                    restoredUsers++;
                                    console.log(`Пользователь ${visitor.username} восстановлен после повторного входа`);
                                } else {
                                    // Запись до удаления - пропускаем
                                    continue;
                                }
                            } else {
                                // Старый формат без времени удаления - если есть запись в visitors.json, 
                                // значит пользователь снова зашел, восстанавливаем его
                                delete deletedUsersMap[visitor.userId];
                                restoredUsers++;
                                console.log(`Пользователь ${visitor.username} восстановлен (старый формат удаления)`);
                            }
                        }
                        
                        const existingUser = registeredUsers.find(u => 
                            u.login?.toLowerCase() === username || u.id === visitor.userId
                        );
                        
                        // Получаем публичный IP
                        let userIP = visitor.publicIP || visitor.ip;
                        if (!userIP || userIP === '127.0.0.1' || userIP === '::1' || 
                            userIP.startsWith('192.168.') || userIP.startsWith('10.')) {
                            continue; // Пропускаем локальные IP
                        }
                        
                        if (existingUser) {
                            // Обновляем существующего пользователя
                            const visitorTimestamp = new Date(visitor.timestamp);
                            const currentLastLogin = existingUser.lastLoginDate ? new Date(existingUser.lastLoginDate) : null;
                            
                            // Обновляем IP, если он публичный и отличается
                            if (userIP && userIP !== existingUser.ipAddress) {
                                existingUser.ipAddress = userIP;
                                updatedUsers++;
                            }
                            
                            // Устанавливаем дату входа только при первом входе (если еще не установлена)
                            if (!currentLastLogin) {
                                existingUser.lastLoginDate = visitor.timestamp;
                                updatedUsers++;
                            }
                            
                            // Обновляем lastSeen (последнее посещение) всегда
                            existingUser.lastSeen = visitor.timestamp;
                        } else {
                            // Создаем нового пользователя
                            const newUser = {
                                id: visitor.userId,
                                login: visitor.username.toLowerCase(),
                                displayName: visitor.username,
                                avatarUrl: `https://ui-avatars.com/api/?name=${encodeURIComponent(visitor.username)}&background=9146FF&color=fff&size=50`,
                                joinDate: visitor.timestamp,
                                lastSeen: visitor.timestamp,
                                lastLoginDate: visitor.timestamp,
                                ipAddress: userIP,
                                userType: 'viewer',
                                status: 'verified',
                                followerCount: 0,
                                giveawayCount: 0
                            };
                            
                            registeredUsers.push(newUser);
                            newUsersAdded++;
                            console.log(`Добавлен новый пользователь из visitors.json: ${visitor.username} (${userIP})`);
                        }
                    }
                    
                    // Сохраняем обновленный список удаленных пользователей
                    if (restoredUsers > 0) {
                        const updatedDeletedUsers = Object.values(deletedUsersMap);
                        localStorage.setItem('by_CTPAX_deleted_users', JSON.stringify(updatedDeletedUsers));
                    }
                    
                    if (newUsersAdded > 0 || updatedUsers > 0 || restoredUsers > 0) {
                        saveUserManagementData();
                        renderUsersTable();
                        console.log(`Загружено пользователей из visitors.json: ${newUsersAdded} новых, ${updatedUsers} обновлено, ${restoredUsers} восстановлено`);
                        return { newUsersAdded, updatedUsers, restoredUsers };
                    } else {
                        console.log('Все пользователи из visitors.json уже в системе');
                        return { newUsersAdded: 0, updatedUsers: 0, restoredUsers: 0 };
                    }
                }
            } catch (error) {
                console.error('Ошибка загрузки пользователей из visitors.json:', error);
                throw error;
            }
        }
        
        // Синхронизация IP адресов пользователей с сервера
        async function syncUserIPsFromServer() {
            if (!USE_SERVER || !isby_CTPAX) return;
            
            try {
                // Сначала загружаем всех пользователей из visitors.json
                await loadUsersFromVisitors();
                
                // Затем синхронизируем IP адреса
                const response = await fetch(`${SERVER_URL}/api/users-ip`);
                if (!response.ok) throw new Error('Server error');
                const data = await response.json();
                
                if (data.success && data.ipMap) {
                    // Загружаем список удаленных пользователей (может быть массив ID или объектов)
                    const deletedUsersRaw = JSON.parse(localStorage.getItem('by_CTPAX_deleted_users') || '[]');
                    // Преобразуем в массив ID для проверки
                    const deletedUserIds = deletedUsersRaw.map(item => 
                        typeof item === 'string' ? item : (item && item.id ? item.id : null)
                    ).filter(id => id !== null);
                    
                    let updated = false;
                    registeredUsers.forEach(user => {
                        // Пропускаем удаленных пользователей
                        if (deletedUserIds.includes(user.id)) {
                            return;
                        }
                        
                        const usernameLower = user.login?.toLowerCase();
                        const userId = user.id;
                        
                        // Пытаемся найти IP по username или userId
                        let serverIPData = null;
                        if (usernameLower && data.ipMap[usernameLower]) {
                            serverIPData = data.ipMap[usernameLower];
                        } else if (userId) {
                            // Ищем по userId в ipMap (если сервер возвращает userId)
                            for (const [username, ipData] of Object.entries(data.ipMap)) {
                                if (ipData.userId === userId) {
                                    serverIPData = ipData;
                                    break;
                                }
                            }
                        }
                        
                        if (serverIPData && serverIPData.ip) {
                            let serverIP = serverIPData.ip;
                            
                            // Пропускаем localhost и IPv6 localhost
                            if (!serverIP || serverIP === '::1' || serverIP === '127.0.0.1' || 
                                serverIP === '::ffff:127.0.0.1') {
                                return;
                            }
                            
                            // Убираем префикс IPv6-mapped IPv4
                            if (serverIP.startsWith('::ffff:')) {
                                serverIP = serverIP.replace('::ffff:', '');
                            }
                            
                            // Обновляем IP только если он отличается и не является симулированным или локальным
                            const currentIP = user.ipAddress;
                            // Определяем локальный/симулированный IP (192.168.x.x, 10.x.x.x, 172.16-31.x.x)
                            const isLocalOrSimulatedIP = currentIP && (
                                currentIP.includes('192.168') || 
                                currentIP === '127.0.0.1' ||
                                currentIP === '::1' ||
                                (currentIP.match(/^\d+\.\d+\.\d+\.\d+$/) && 
                                 (currentIP.startsWith('10.') || 
                                  (currentIP.startsWith('172.') && 
                                   parseInt(currentIP.split('.')[1]) >= 16 && 
                                   parseInt(currentIP.split('.')[1]) <= 31)))
                            );
                            
                            // Всегда обновляем, если текущий IP локальный/симулированный, а серверный - публичный
                            // Или если текущий IP отличается от серверного и серверный - публичный
                            const isServerIPPublic = serverIP && 
                                !serverIP.startsWith('192.168.') && 
                                !serverIP.startsWith('10.') && 
                                !serverIP.startsWith('172.') &&
                                serverIP !== '127.0.0.1' && 
                                serverIP !== '::1';
                            
                            if (isServerIPPublic && (isLocalOrSimulatedIP || !currentIP || 
                                currentIP === 'unknown' || currentIP === 'N/A' || 
                                serverIP !== currentIP)) {
                                user.ipAddress = serverIP;
                                // Устанавливаем lastLoginDate только при первом входе (если еще не установлена)
                                if (serverIPData.timestamp && !user.lastLoginDate) {
                                    user.lastLoginDate = serverIPData.timestamp;
                                }
                                updated = true;
                                console.log(`Обновлен IP для ${user.login}: ${currentIP || 'N/A'} → ${serverIP}`);
                            }
                        }
                    });
                    
                    if (updated) {
                        saveUserManagementData();
                        renderUsersTable();
                        console.log('IP адреса пользователей синхронизированы с visitors.json');
                    } else {
                        console.log('IP адреса пользователей актуальны');
                    }
                }
            } catch (error) {
                console.warn('Не удалось синхронизировать IP адреса с сервера:', error);
                throw error;
            }
        }
        
        // Initialize user management data
        function initializeUserManagementData() {
            if (!isby_CTPAX) return;
            
            // Загружаем список удаленных пользователей (может быть массив ID или объектов)
            const deletedUsersRaw = JSON.parse(localStorage.getItem('by_CTPAX_deleted_users') || '[]');
            // Преобразуем в массив ID для фильтрации
            const deletedUserIds = deletedUsersRaw.map(item => 
                typeof item === 'string' ? item : (item && item.id ? item.id : null)
            ).filter(id => id !== null);
            
            // Load from localStorage - no demo data, only real users
            const savedUsers = localStorage.getItem('by_CTPAX_users');
            const savedStreamers = localStorage.getItem('by_CTPAX_streamers');
            const savedAuthLog = localStorage.getItem('by_CTPAX_auth_log');
            const savedNotifications = localStorage.getItem('by_CTPAX_notifications');
            
            if (savedUsers) {
                registeredUsers = JSON.parse(savedUsers);
                
                // Удаляем пользователей, которые были удалены
                registeredUsers = registeredUsers.filter(user => !deletedUserIds.includes(user.id));
                
                // Обновляем старых пользователей: добавляем lastLoginDate, если его нет
                registeredUsers.forEach(user => {
                    if (!user.lastLoginDate) {
                        // Если нет lastLoginDate, используем lastSeen или joinDate
                        user.lastLoginDate = user.lastSeen || user.joinDate || new Date();
                    }
                });
                // Загружаем пользователей из visitors.json и синхронизируем IP адреса
                if (USE_SERVER) {
                    loadUsersFromVisitors().then(() => {
                        syncUserIPsFromServer();
                    }).catch(err => {
                        console.warn('Ошибка загрузки пользователей при инициализации:', err);
                    });
                }
            } else {
                // Start with empty arrays - data will be populated from real users
                registeredUsers = [];
                // Загружаем пользователей из visitors.json, если список пуст
                if (USE_SERVER) {
                    loadUsersFromVisitors().then(() => {
                        syncUserIPsFromServer();
                    }).catch(err => {
                        console.warn('Ошибка загрузки пользователей при инициализации:', err);
                    });
                }
            }
            
            if (savedStreamers) {
                registeredStreamers = JSON.parse(savedStreamers);
                // Ensure all streamers have IP addresses and streamHistory
                registeredStreamers.forEach(streamer => {
                    if (!streamer.ipAddress || streamer.ipAddress === 'unknown') {
                        streamer.ipAddress = getUserIP();
                    }
                    // Инициализируем streamHistory, если его нет
                    if (!streamer.streamHistory) {
                        streamer.streamHistory = [];
                    }
                    
                    // Конвертируем даты в streamHistory из строк в Date объекты
                    if (streamer.streamHistory && streamer.streamHistory.length > 0) {
                        streamer.streamHistory.forEach(stream => {
                            if (stream.date && !(stream.date instanceof Date)) {
                                stream.date = new Date(stream.date);
                            }
                        });
                    }
                    
                    // Конвертируем lastStreamDate из строки в Date объект
                    if (streamer.lastStreamDate && !(streamer.lastStreamDate instanceof Date)) {
                        streamer.lastStreamDate = new Date(streamer.lastStreamDate);
                    }
                    
                    // Конвертируем lastLoginDate из строки в Date объект
                    if (streamer.lastLoginDate && !(streamer.lastLoginDate instanceof Date)) {
                        streamer.lastLoginDate = new Date(streamer.lastLoginDate);
                    }
                    
                    // Пересчитываем средний онлайн из истории, если есть данные
                    if (streamer.streamHistory && streamer.streamHistory.length > 0) {
                        const totalViewers = streamer.streamHistory.reduce((sum, s) => sum + (s.viewers || 0), 0);
                        streamer.avgOnline = Math.round(totalViewers / streamer.streamHistory.length);
                        
                        // Обновляем lastStreamDate из истории, если его нет или он старый
                        const sortedHistory = [...streamer.streamHistory].sort((a, b) => {
                            const dateA = a.date instanceof Date ? a.date : new Date(a.date);
                            const dateB = b.date instanceof Date ? b.date : new Date(b.date);
                            return dateB - dateA;
                        });
                        if (sortedHistory.length > 0) {
                            const lastStream = sortedHistory[0];
                            const lastStreamDate = lastStream.date instanceof Date ? lastStream.date : new Date(lastStream.date);
                            if (!streamer.lastStreamDate || lastStreamDate > new Date(streamer.lastStreamDate)) {
                                streamer.lastStreamDate = lastStreamDate;
                            }
                        }
                    }
                });
            } else {
                // Start with empty arrays - data will be populated from real streamers
                registeredStreamers = [];
            }
            
            // Добавляем 3 стримера по умолчанию
            const defaultStreamers = [
                { login: 'evelone2004', displayName: 'evelone2004' },
                { login: 'shadowkekw', displayName: 'shadowkekw' },
                { login: 'StRoGo', displayName: 'StRoGo' }
            ];
            
            defaultStreamers.forEach(streamerInfo => {
                const existingStreamer = registeredStreamers.find(s => 
                    s.login?.toLowerCase() === streamerInfo.login.toLowerCase()
                );
                
                if (!existingStreamer) {
                    registeredStreamers.push({
                        id: streamerInfo.login.toLowerCase(),
                        login: streamerInfo.login.toLowerCase(),
                        displayName: streamerInfo.displayName,
                        avatarUrl: `https://ui-avatars.com/api/?name=${encodeURIComponent(streamerInfo.displayName)}&background=9146FF&color=fff&size=50`,
                        followerCount: 0,
                        giveawayCount: 0,
                        totalWinners: 0,
                        avgViewers: 0,
                        lastStreamDate: new Date(),
                        lastLoginDate: new Date(),
                        activityLevel: 'low',
                        isOnline: false,
                        ipAddress: null,
                        avgOnline: 0,
                        streamHistory: [] // История стримов для расчета среднего онлайна
                    });
                } else {
                    // Убеждаемся, что у существующего стримера есть streamHistory
                    if (!existingStreamer.streamHistory) {
                        existingStreamer.streamHistory = [];
                    }
                }
            });
            
            if (savedAuthLog) {
                authorizationLog = JSON.parse(savedAuthLog).map(entry => ({
                    ...entry,
                    timestamp: new Date(entry.timestamp)
                }));
            } else {
                // Start with empty log - will be populated with real actions
                authorizationLog = [];
            }
            
            if (savedNotifications) {
                notificationSettings = { ...notificationSettings, ...JSON.parse(savedNotifications) };
            }
            
            // Load user management settings
            loadUserManagementSettings();
            
            // Add current user to the system if by_CTPAX (только если пользователь реально авторизован)
            if (currentUsername && isAuthenticated) {
                const now = new Date();
                addUserToSystem(currentUsername, {
                    id: currentUserId || 'by_CTPAX_owner',
                    login: currentUsername.toLowerCase(),
                    displayName: currentUsername,
                    avatarUrl: streamerAvatar?.querySelector('img')?.src || `https://ui-avatars.com/api/?name=${encodeURIComponent(currentUsername)}&background=9146FF&color=fff&size=50`,
                    joinDate: now,
                    lastSeen: now,
                    lastLoginDate: now, // Дата первого входа владельца (не изменяется)
                    ipAddress: currentUserRealIP || storedVisitorIp || null,
                    userType: 'owner',
                    status: 'verified',
                    followerCount: 0,
                    giveawayCount: 0
                });
            }
            
            // Save updated data with IP addresses
            saveUserManagementData();
        }
        
        // Debounce для saveUserManagementData
        let saveUserDataTimeout = null;
        let lastSaveUserDataTime = 0;
        const SAVE_USER_DATA_DEBOUNCE = 2000; // Минимум 2 секунды между сохранениями на сервер
        
        // Save user management data
        function saveUserManagementData() {
            if (!isby_CTPAX) return;
            
            // Сохраняем в localStorage
            localStorage.setItem('by_CTPAX_users', JSON.stringify(registeredUsers));
            localStorage.setItem('by_CTPAX_streamers', JSON.stringify(registeredStreamers));
            localStorage.setItem('by_CTPAX_auth_log', JSON.stringify(authorizationLog));
            localStorage.setItem('by_CTPAX_notifications', JSON.stringify(notificationSettings));
            localStorage.setItem('by_CTPAX_user_management_settings', JSON.stringify(userManagementSettings));
            
            // Отправляем на сервер с debounce (не блокируем работу при ошибке)
            if (USE_SERVER) {
                const now = Date.now();
                if (now - lastSaveUserDataTime < SAVE_USER_DATA_DEBOUNCE) {
                    // Отменяем предыдущий таймер и устанавливаем новый
                    if (saveUserDataTimeout) {
                        clearTimeout(saveUserDataTimeout);
                    }
                    saveUserDataTimeout = setTimeout(() => {
                        saveUserDataToServer();
                    }, SAVE_USER_DATA_DEBOUNCE - (now - lastSaveUserDataTime));
                } else {
                    saveUserDataToServer();
                }
            }
        }
        
        // Отдельная функция для отправки данных пользователей на сервер
        function saveUserDataToServer() {
            lastSaveUserDataTime = Date.now();
            fetch(`${SERVER_URL}/api/users`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    users: registeredUsers,
                    streamers: registeredStreamers,
                    authLog: authorizationLog,
                    notifications: notificationSettings,
                    settings: userManagementSettings
                })
            }).catch(error => {
                // Тихо игнорируем ошибки сервера, не критично
                console.warn('Не удалось сохранить данные пользователей на сервер (не критично):', error.message);
            });
        }
        
        // Load user management settings
        function loadUserManagementSettings() {
            if (!isby_CTPAX) return;
            
            try {
                const savedSettings = localStorage.getItem('by_CTPAX_user_management_settings');
                if (savedSettings) {
                    userManagementSettings = { ...userManagementSettings, ...JSON.parse(savedSettings) };
                    console.log('Настройки управления пользователями загружены:', userManagementSettings);
                }
            } catch (error) {
                console.error('Ошибка загрузки настроек управления пользователями:', error);
            }
        }
        
        // Apply user management settings to UI
        function applyUserManagementSettingsToUI() {
            if (!isby_CTPAX) return;
            
            try {
                // Apply search and filter values
                const userSearch = document.getElementById('userSearch');
                const userSortBy = document.getElementById('userSortBy');
                const userFilterStatus = document.getElementById('userFilterStatus');
                const streamerSearch = document.getElementById('streamerSearch');
                const streamerSortBy = document.getElementById('streamerSortBy');
                const streamerFilterActivity = document.getElementById('streamerFilterActivity');
                const logStartDate = document.getElementById('logStartDate');
                const logEndDate = document.getElementById('logEndDate');
                
                if (userSearch) userSearch.value = userManagementSettings.userSearch || '';
                if (userSortBy) userSortBy.value = userManagementSettings.userSortBy || 'date';
                if (userFilterStatus) userFilterStatus.value = userManagementSettings.userFilterStatus || 'all';
                if (streamerSearch) streamerSearch.value = userManagementSettings.streamerSearch || '';
                if (streamerSortBy) streamerSortBy.value = userManagementSettings.streamerSortBy || 'activity';
                if (streamerFilterActivity) streamerFilterActivity.value = userManagementSettings.streamerFilterActivity || 'all';
                if (logStartDate) logStartDate.value = userManagementSettings.logStartDate || '';
                if (logEndDate) logEndDate.value = userManagementSettings.logEndDate || '';
                
                // Настройки уведомлений удалены
                
                // Switch to saved active tab
                if (userManagementSettings.activeTab === 'streamers') {
                    document.getElementById('streamersTab')?.click();
                } else if (userManagementSettings.activeTab === 'notifications') {
                    document.getElementById('notificationsTab')?.click();
                } else {
                    document.getElementById('usersTab')?.click();
                }
                
                console.log('Настройки управления пользователями применены к UI');
            } catch (error) {
                console.error('Ошибка применения настроек управления пользователями к UI:', error);
            }
        }
        
        // Collect user management settings from UI
        function collectUserManagementSettingsFromUI() {
            if (!isby_CTPAX) return;
            
            try {
                const userSearch = document.getElementById('userSearch');
                const userSortBy = document.getElementById('userSortBy');
                const userFilterStatus = document.getElementById('userFilterStatus');
                const streamerSearch = document.getElementById('streamerSearch');
                const streamerSortBy = document.getElementById('streamerSortBy');
                const streamerFilterActivity = document.getElementById('streamerFilterActivity');
                const logStartDate = document.getElementById('logStartDate');
                const logEndDate = document.getElementById('logEndDate');
                
                userManagementSettings.userSearch = userSearch?.value || '';
                userManagementSettings.userSortBy = userSortBy?.value || 'date';
                userManagementSettings.userFilterStatus = userFilterStatus?.value || 'all';
                userManagementSettings.streamerSearch = streamerSearch?.value || '';
                userManagementSettings.streamerSortBy = streamerSortBy?.value || 'activity';
                userManagementSettings.streamerFilterActivity = streamerFilterActivity?.value || 'all';
                userManagementSettings.logStartDate = logStartDate?.value || '';
                userManagementSettings.logEndDate = logEndDate?.value || '';
                
                // Collect notification settings
                // Настройки уведомлений удалены
                
                console.log('Настройки управления пользователями собраны:', userManagementSettings);
            } catch (error) {
                console.error('Ошибка сбора настроек управления пользователями:', error);
            }
        }
        
        // Render users table
        function renderUsersTable() {
            if (!isby_CTPAX) return;
            
            const tableBody = document.getElementById('usersTableBody');
            const emptyState = document.getElementById('usersEmptyState');
            const searchTerm = document.getElementById('userSearch').value.toLowerCase();
            const sortBy = document.getElementById('userSortBy').value;
            const statusFilter = document.getElementById('userFilterStatus').value;
            
            // Filter users
            let filteredUsers = registeredUsers.filter(user => {
                const matchesSearch = user.login.toLowerCase().includes(searchTerm) || 
                                    user.id.includes(searchTerm) ||
                                    user.displayName.toLowerCase().includes(searchTerm);
                                    
                const matchesStatus = statusFilter === 'all' || user.status === statusFilter;
                
                return matchesSearch && matchesStatus;
            });
            
            // Sort users
            filteredUsers.sort((a, b) => {
                switch(sortBy) {
                    case 'login':
                        return a.login.localeCompare(b.login);
                    case 'status':
                        return a.status.localeCompare(b.status);
                    case 'date':
                    default:
                        // Сортируем по дате последнего входа
                        const dateA = new Date(b.lastLoginDate || b.lastSeen || b.joinDate || 0);
                        const dateB = new Date(a.lastLoginDate || a.lastSeen || a.joinDate || 0);
                        return dateA - dateB;
                }
            });
            
            if (filteredUsers.length === 0) {
                tableBody.innerHTML = '';
                emptyState.classList.remove('hidden');
                return;
            }
            
            emptyState.classList.add('hidden');
            
            // Функция для проверки, является ли IP подозрительным
            function isSuspiciousIP(ip) {
                if (!ip || ip === '::1' || ip === '127.0.0.1') return true;
                // Проверяем локальные IP
                if (ip.startsWith('192.168.') || ip.startsWith('10.') || 
                    (ip.startsWith('172.') && parseInt(ip.split('.')[1]) >= 16 && parseInt(ip.split('.')[1]) <= 31)) {
                    return true;
                }
                // Проверяем на VPN/Proxy (можно расширить список)
                // Пока просто проверяем, что IP валидный публичный IPv4
                const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
                if (!ipv4Regex.test(ip)) return true;
                return false;
            }
            
            tableBody.innerHTML = filteredUsers.map(user => {
                // Определяем статус: если IP не подозрителен и пользователь не заблокирован, то "Подтверждён"
                let userStatus = user.status;
                if (userStatus !== 'blocked') {
                    const ip = user.ipAddress;
                    if (ip && !isSuspiciousIP(ip)) {
                        userStatus = 'verified';
                    } else {
                        userStatus = 'unverified';
                    }
                }
                
                const statusBadges = {
                    verified: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">✅ Подтверждён</span>',
                    blocked: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800">⛔ Заблокирован</span>',
                    unverified: '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">❓ Неподтверждён</span>'
                };
                
                return `
                    <tr class="hover:bg-gray-600 transition-colors duration-200">
                        <td class="px-4 py-3">
                            <img src="${user.avatarUrl}" alt="${user.displayName}" class="w-10 h-10 rounded-full">
                        </td>
                        <td class="px-4 py-3">
                            <div class="flex flex-col">
                                <span class="font-medium">${user.displayName}</span>
                                <span class="text-sm text-gray-400">@${user.login}</span>
                            </div>
                        </td>
                        <td class="px-4 py-3 font-mono text-sm">${user.id}</td>
                        <td class="px-4 py-3 text-sm">${user.lastLoginDate ? formatDate(user.lastLoginDate) : (user.lastSeen ? formatDate(user.lastSeen) : formatDate(user.joinDate))}</td>
                        <td class="px-4 py-3 font-mono text-sm">
                            ${user.ipAddress && user.ipAddress !== '::1' && user.ipAddress !== '127.0.0.1' 
                                ? user.ipAddress 
                                : '<span class="text-gray-500">—</span>'}
                        </td>
                        <td class="px-4 py-3">${statusBadges[userStatus]}</td>
                        <td class="px-4 py-3">
                            <div class="flex justify-center space-x-2">
                                <button class="user-action-btn text-blue-400 hover:text-blue-300 p-1" data-action="view" data-user-id="${user.id}" title="Просмотр профиля">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
                                        <circle cx="12" cy="12" r="3"></circle>
                                    </svg>
                                </button>
                                ${user.status === 'blocked' ? 
                                    `<button class="user-action-btn text-green-400 hover:text-green-300 p-1" data-action="unblock" data-user-id="${user.id}" title="Разблокировать">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <rect x="3" y="11" width="18" height="10" rx="2" ry="2"></rect>
                                            <path d="M7 11V7a5 5 0 0 1 9.9-1"></path>
                                        </svg>
                                    </button>` :
                                    `<button class="user-action-btn text-red-400 hover:text-red-300 p-1" data-action="block" data-user-id="${user.id}" title="Заблокировать">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <rect x="3" y="11" width="18" height="10" rx="2" ry="2"></rect>
                                            <circle cx="12" cy="16" r="1"></circle>
                                            <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
                                        </svg>
                                    </button>`
                                }
                                <button class="user-action-btn text-red-400 hover:text-red-300 p-1" data-action="delete" data-user-id="${user.id}" title="Удалить">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="3,6 5,6 21,6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    </svg>
                                </button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            
            // Add event listeners to action buttons
            document.querySelectorAll('.user-action-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const action = this.dataset.action;
                    const userId = this.dataset.userId;
                    handleUserAction(action, userId);
                });
            });
        }
        
        // Render streamers table
        function renderStreamersTable() {
            if (!isby_CTPAX) return;
            
            const tableBody = document.getElementById('streamersTableBody');
            const emptyState = document.getElementById('streamersEmptyState');
            const searchTerm = document.getElementById('streamerSearch').value.toLowerCase();
            const sortBy = document.getElementById('streamerSortBy').value;
            const activityFilter = document.getElementById('streamerFilterActivity').value;
            
            // Filter streamers
            let filteredStreamers = registeredStreamers.filter(streamer => {
                const matchesSearch = streamer.login.toLowerCase().includes(searchTerm) || 
                                    streamer.displayName.toLowerCase().includes(searchTerm);
                                    
                // Фильтр по статусу стриминга
                let matchesStatus = true;
                if (activityFilter === 'streaming') {
                    matchesStatus = streamer.isOnline === true;
                } else if (activityFilter === 'offline') {
                    matchesStatus = streamer.isOnline !== true;
                }
                
                return matchesSearch && matchesStatus;
            });
            
            // Sort streamers
            filteredStreamers.sort((a, b) => {
                switch(sortBy) {
                    case 'login':
                        return a.login.localeCompare(b.login);
                    case 'followers':
                        return (b.followerCount || 0) - (a.followerCount || 0);
                    case 'lastStream':
                        const dateA = a.lastStreamDate ? new Date(a.lastStreamDate) : new Date(0);
                        const dateB = b.lastStreamDate ? new Date(b.lastStreamDate) : new Date(0);
                        return dateB - dateA;
                    case 'status':
                    default:
                        // Сначала стримящие, потом не стримящие
                        if (a.isOnline && !b.isOnline) return -1;
                        if (!a.isOnline && b.isOnline) return 1;
                        return 0;
                }
            });
            
            if (filteredStreamers.length === 0) {
                tableBody.innerHTML = '';
                emptyState.classList.remove('hidden');
                return;
            }
            
            emptyState.classList.add('hidden');
            
            tableBody.innerHTML = filteredStreamers.map(streamer => {
                // Подсвечиваем красным если стримят
                const isStreaming = streamer.isOnline;
                const rowClass = isStreaming 
                    ? 'hover:bg-gray-600 transition-colors duration-200 bg-red-900/30 border-l-4 border-red-500' 
                    : 'hover:bg-gray-600 transition-colors duration-200';
                
                // Форматируем дату последнего стрима
                let lastStreamText = '<span class="text-gray-500">—</span>';
                if (streamer.lastStreamDate) {
                    try {
                        const lastStreamDate = streamer.lastStreamDate instanceof Date 
                            ? streamer.lastStreamDate 
                            : new Date(streamer.lastStreamDate);
                        if (!isNaN(lastStreamDate.getTime())) {
                            lastStreamText = formatDateTime(lastStreamDate);
                        }
                    } catch (e) {
                        console.warn('Ошибка форматирования даты последнего стрима:', e);
                    }
                }
                
                // Форматируем средний онлайн
                let avgOnlineText = '<span class="text-gray-500">—</span>';
                if (streamer.avgOnline !== undefined && streamer.avgOnline !== null) {
                    // Пересчитываем из истории, если есть
                    if (streamer.streamHistory && streamer.streamHistory.length > 0) {
                        const totalViewers = streamer.streamHistory.reduce((sum, s) => sum + (s.viewers || 0), 0);
                        const calculatedAvg = Math.round(totalViewers / streamer.streamHistory.length);
                        avgOnlineText = `${calculatedAvg.toLocaleString()} зрителей`;
                    } else if (streamer.avgOnline > 0) {
                        avgOnlineText = `${streamer.avgOnline.toLocaleString()} зрителей`;
                    }
                }
                
                return `
                    <tr class="${rowClass}">
                        <td class="px-4 py-3">
                            <div class="flex items-center space-x-3">
                                <div class="relative">
                                    <img src="${streamer.avatarUrl}" alt="${streamer.displayName}" class="w-12 h-12 rounded-full ${isStreaming ? 'ring-2 ring-red-500' : ''}">
                                    ${isStreaming ? '<div class="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full border-2 border-gray-700 animate-pulse"></div>' : ''}
                                </div>
                                <div>
                                    <div class="font-medium ${isStreaming ? 'text-red-400' : ''}">${streamer.displayName}</div>
                                    ${isStreaming ? '<div class="text-xs text-red-400 font-bold">🔴 В ЭФИРЕ</div>' : ''}
                                </div>
                            </div>
                        </td>
                        <td class="px-4 py-3">
                            <span class="font-medium">${streamer.followerCount.toLocaleString()}</span>
                        </td>
                        <td class="px-4 py-3 text-sm">${lastStreamText}</td>
                        <td class="px-4 py-3 text-sm">${avgOnlineText}</td>
                        <td class="px-4 py-3">
                            ${isStreaming 
                                ? '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-800">🔴 Стримит сейчас</span>'
                                : '<span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-800">⚫ Не стримит</span>'
                            }
                        </td>
                    </tr>
                `;
            }).join('');
        }
        
        // Проверка стриминга и получение реальных данных для всех стримеров
        async function checkStreamersStatus() {
            if (!isby_CTPAX || !accessToken) return;
            
            const streamerLogins = ['evelone2004', 'shadowkekw', 'StRoGo'];
            
            try {
                // Получаем ID всех стримеров
                const userLogins = streamerLogins.join('&login=');
                const usersResponse = await fetch(`https://api.twitch.tv/helix/users?login=${userLogins}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                    }
                });
                
                if (!usersResponse.ok) return;
                
                const usersData = await usersResponse.json();
                if (!usersData.data || usersData.data.length === 0) return;
                
                const userIds = usersData.data.map(u => u.id);
                const userIdsParam = userIds.join('&user_id=');
                
                // Проверяем стриминг
                const streamsResponse = await fetch(`https://api.twitch.tv/helix/streams?user_id=${userIdsParam}`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                    }
                });
                
                const streamingUserIds = new Set();
                const streamsMap = new Map();
                
                if (streamsResponse.ok) {
                    const streamsData = await streamsResponse.json();
                    if (streamsData.data && streamsData.data.length > 0) {
                        streamsData.data.forEach(stream => {
                            streamingUserIds.add(stream.user_id);
                            streamsMap.set(stream.user_id, stream);
                        });
                    }
                }
                
                // Получаем данные о подписчиках и видео для каждого стримера
                for (const userData of usersData.data) {
                    let followerCount = 0;
                    try {
                        const followResponse = await fetch(`https://api.twitch.tv/helix/channels/followers?broadcaster_id=${userData.id}&first=1`, {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`,
                                'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                            }
                        });
                        if (followResponse.ok) {
                            const followData = await followResponse.json();
                            followerCount = followData.total || 0;
                        }
                    } catch (err) {
                        console.warn(`Ошибка получения подписчиков для ${userData.login}:`, err);
                    }
                    
                    // Получаем последние видео (VODs) только для определения последнего стрима
                    // НЕ используем их для расчета среднего онлайна, так как view_count - это не средний онлайн
                    let videosData = [];
                    try {
                        const videosResponse = await fetch(`https://api.twitch.tv/helix/videos?user_id=${userData.id}&first=1&type=archive`, {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`,
                                'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                            }
                        });
                        if (videosResponse.ok) {
                            const videosResponseData = await videosResponse.json();
                            if (videosResponseData.data && videosResponseData.data.length > 0) {
                                videosData = videosResponseData.data;
                            }
                        }
                    } catch (err) {
                        console.warn(`Ошибка получения видео для ${userData.login}:`, err);
                    }
                    
                    // Находим или создаем стримера
                    let streamer = registeredStreamers.find(s => 
                        s.login?.toLowerCase() === userData.login.toLowerCase() || s.id === userData.id
                    );
                    
                    if (!streamer) {
                        streamer = {
                            id: userData.id,
                            login: userData.login.toLowerCase(),
                            displayName: userData.display_name,
                            avatarUrl: userData.profile_image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(userData.display_name)}&background=9146FF&color=fff&size=50`,
                            followerCount: 0,
                            giveawayCount: 0,
                            totalWinners: 0,
                            avgViewers: 0,
                            lastStreamDate: null,
                            lastLoginDate: null,
                            activityLevel: 'low',
                            isOnline: false,
                            ipAddress: null,
                            avgOnline: 0, // Средний онлайн за последние 20 стримов
                            streamHistory: [] // История стримов: [{date, viewers, streamId}]
                        };
                        registeredStreamers.push(streamer);
                    }
                    
                    // Инициализируем streamHistory, если его нет
                    if (!streamer.streamHistory) {
                        streamer.streamHistory = [];
                    }
                    
                    // Обновляем данные стримера
                    streamer.id = userData.id;
                    streamer.login = userData.login.toLowerCase();
                    streamer.displayName = userData.display_name;
                    streamer.avatarUrl = userData.profile_image_url || streamer.avatarUrl;
                    streamer.followerCount = followerCount;
                    const wasOnline = streamer.isOnline;
                    streamer.isOnline = streamingUserIds.has(userData.id);
                    
                    // Обрабатываем видео только для определения последнего стрима
                    // НЕ используем их для расчета среднего онлайна
                    if (videosData.length > 0) {
                        const lastVideo = videosData[0];
                        if (lastVideo) {
                            // Используем published_at вместо created_at для более точной даты
                            const videoDate = new Date(lastVideo.published_at || lastVideo.created_at);
                            
                            // Обновляем lastStreamDate только если новое видео новее
                            if (!streamer.lastStreamDate) {
                                streamer.lastStreamDate = videoDate;
                            } else {
                                const currentLastDate = streamer.lastStreamDate instanceof Date 
                                    ? streamer.lastStreamDate 
                                    : new Date(streamer.lastStreamDate);
                                if (videoDate > currentLastDate) {
                                    streamer.lastStreamDate = videoDate;
                                    console.log(`Обновлен lastStreamDate для ${streamer.login}: ${videoDate}`);
                                }
                            }
                        }
                    }
                    
                    if (streamer.isOnline) {
                        const stream = streamsMap.get(userData.id);
                        if (stream) {
                            const streamId = stream.id;
                            const streamDate = new Date(stream.started_at);
                            const viewers = stream.viewer_count || 0;
                            
                            // Обновляем lastStreamDate из текущего стрима (он всегда самый новый)
                            streamer.lastStreamDate = streamDate;
                            streamer.avgViewers = viewers;
                            
                            // Проверяем, не добавляли ли мы уже этот стрим
                            const existingStream = streamer.streamHistory.find(s => s.streamId === streamId);
                            
                            if (!existingStream) {
                                // Добавляем новый стрим в историю с текущим количеством зрителей
                                streamer.streamHistory.push({
                                    date: streamDate,
                                    viewers: viewers,
                                    streamId: streamId,
                                    checkCount: 1, // Количество проверок для расчета среднего
                                    isActive: true // Флаг активного стрима
                                });
                                
                                // Оставляем только последние 20 стримов
                                streamer.streamHistory.sort((a, b) => {
                                    const dateA = a.date instanceof Date ? a.date : new Date(a.date);
                                    const dateB = b.date instanceof Date ? b.date : new Date(b.date);
                                    return dateB - dateA;
                                });
                                if (streamer.streamHistory.length > 20) {
                                    streamer.streamHistory = streamer.streamHistory.slice(0, 20);
                                }
                            } else {
                                // Обновляем количество зрителей для текущего стрима (накапливаем среднее)
                                existingStream.checkCount = (existingStream.checkCount || 1) + 1;
                                // Вычисляем скользящее среднее для более точного результата
                                existingStream.viewers = Math.round(
                                    (existingStream.viewers * (existingStream.checkCount - 1) + viewers) / existingStream.checkCount
                                );
                                existingStream.isActive = true;
                            }
                        }
                    } else if (wasOnline && !streamer.isOnline) {
                        // Стрим закончился, помечаем его как неактивный
                        const lastActiveStream = streamer.streamHistory.find(s => s.isActive === true);
                        if (lastActiveStream) {
                            lastActiveStream.isActive = false;
                        }
                    }
                    
                    // Всегда пересчитываем средний онлайн из истории стримов
                    // Используем только данные из Streams API (когда стример был онлайн)
                    if (streamer.streamHistory && streamer.streamHistory.length > 0) {
                        // Сортируем историю по дате (новые первые)
                        streamer.streamHistory.sort((a, b) => {
                            const dateA = a.date instanceof Date ? a.date : new Date(a.date);
                            const dateB = b.date instanceof Date ? b.date : new Date(b.date);
                            return dateB - dateA;
                        });
                        
                        // Рассчитываем средний онлайн за последние 20 стримов
                        // Берем только последние 20 записей (только из Streams API, не из Videos)
                        const recentStreams = streamer.streamHistory.slice(0, 20);
                        const totalViewers = recentStreams.reduce((sum, s) => sum + (s.viewers || 0), 0);
                        streamer.avgOnline = recentStreams.length > 0 
                            ? Math.round(totalViewers / recentStreams.length) 
                            : 0;
                        
                        console.log(`Стример ${streamer.login}: средний онлайн = ${streamer.avgOnline} (из ${recentStreams.length} стримов), последний стрим: ${streamer.lastStreamDate}`);
                    } else if (streamer.isOnline) {
                        // Если нет истории, но стример онлайн, используем текущее значение
                        const stream = streamsMap.get(userData.id);
                        if (stream) {
                            streamer.avgOnline = stream.viewer_count || 0;
                        }
                    } else {
                        // Если нет истории и стример не онлайн, средний онлайн = 0
                        streamer.avgOnline = 0;
                    }
                }
                
                // Получаем данные о последнем посещении сайта из visitors.json
                if (USE_SERVER) {
                    try {
                        const visitorsResponse = await fetch(`${SERVER_URL}/api/visitors?limit=10000`);
                        if (visitorsResponse.ok) {
                            const visitorsData = await visitorsResponse.json();
                            if (visitorsData.success && visitorsData.visitors) {
                                registeredStreamers.forEach(streamer => {
                                    const streamerVisits = visitorsData.visitors.filter(v => 
                                        v.username?.toLowerCase() === streamer.login || 
                                        v.userId === streamer.id
                                    );
                                    if (streamerVisits.length > 0) {
                                        const lastVisit = streamerVisits.sort((a, b) => 
                                            new Date(b.timestamp) - new Date(a.timestamp)
                                        )[0];
                                        streamer.lastLoginDate = new Date(lastVisit.timestamp);
                                    }
                                });
                            }
                        }
                    } catch (err) {
                        console.warn('Ошибка получения данных о посещениях:', err);
                    }
                }
                
                // Сохраняем данные после обновления
                saveUserManagementData();
                
                // Обновляем статистику и таблицу
                updateStreamerStatistics();
                renderStreamersTable();
                
                console.log('Данные стримеров обновлены:', registeredStreamers.map(s => ({
                    login: s.login,
                    isOnline: s.isOnline,
                    lastStreamDate: s.lastStreamDate,
                    avgOnline: s.avgOnline,
                    historyLength: s.streamHistory?.length || 0
                })));
            } catch (error) {
                console.warn('Ошибка проверки статуса стримеров:', error);
            }
        }
        
        // Update streamer statistics
        function updateStreamerStatistics() {
            if (!isby_CTPAX) return;
            
            const totalStreamers = registeredStreamers.length;
            const onlineStreamers = registeredStreamers.filter(s => s.isOnline).length;
            const totalFollowers = registeredStreamers.reduce((sum, s) => sum + (s.followerCount || 0), 0);
            const avgOnline = registeredStreamers.length > 0 
                ? Math.round(registeredStreamers.reduce((sum, s) => sum + (s.avgOnline || 0), 0) / registeredStreamers.length)
                : 0;
            
            document.getElementById('totalStreamers').textContent = totalStreamers;
            document.getElementById('activeStreamers').textContent = onlineStreamers;
            document.getElementById('totalStreamerGiveaways').textContent = totalFollowers.toLocaleString();
            document.getElementById('onlineStreamers').textContent = avgOnline.toLocaleString();
        }
        
        // Render authorization log
        async function renderAuthorizationLog() {
            if (!isby_CTPAX) return;
            
            const tableBody = document.getElementById('authLogTableBody');
            const startDate = document.getElementById('logStartDate').value;
            const endDate = document.getElementById('logEndDate').value;
            
            // Создаем лог из всех зарегистрированных пользователей
            let logEntries = [];
            
            // Добавляем записи из authorizationLog
            logEntries.push(...authorizationLog.map(entry => ({
                timestamp: entry.timestamp,
                username: entry.username,
                userId: entry.userId,
                action: entry.action,
                ipAddress: entry.ipAddress,
                userAgent: entry.userAgent || 'Unknown'
            })));
            
            // Добавляем записи из registeredUsers (все кто зарегистрировался)
            registeredUsers.forEach(user => {
                if (user.lastLoginDate) {
                    logEntries.push({
                        timestamp: new Date(user.lastLoginDate),
                        username: user.login,
                        userId: user.id,
                        action: 'REGISTER',
                        ipAddress: user.ipAddress || 'N/A',
                        userAgent: 'Twitch Auth'
                    });
                }
            });
            
            // Если есть сервер, загружаем данные из visitors.json
            if (USE_SERVER) {
                try {
                    const response = await fetch(`${SERVER_URL}/api/visitors?limit=10000`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.visitors && Array.isArray(data.visitors)) {
                            // Добавляем записи из visitors.json с action="auth"
                            data.visitors.forEach(visitor => {
                                if (visitor.action === 'auth' && visitor.username && visitor.userId) {
                                    logEntries.push({
                                        timestamp: new Date(visitor.timestamp),
                                        username: visitor.username,
                                        userId: visitor.userId,
                                        action: 'REGISTER',
                                        ipAddress: visitor.publicIP || visitor.ip || 'N/A',
                                        userAgent: visitor.userAgent || 'Unknown'
                                    });
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.warn('Ошибка загрузки visitors для лога:', error);
                }
            }
            
            // Удаляем дубликаты (по username + timestamp)
            const uniqueEntries = [];
            const seen = new Set();
            logEntries.forEach(entry => {
                const key = `${entry.username}_${entry.timestamp.getTime()}`;
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueEntries.push(entry);
                }
            });
            
            let filteredLog = uniqueEntries;
            
            // Filter by date range
            if (startDate) {
                const start = new Date(startDate);
                filteredLog = filteredLog.filter(entry => {
                    const entryDate = entry.timestamp instanceof Date ? entry.timestamp : new Date(entry.timestamp);
                    return entryDate >= start;
                });
            }
            
            if (endDate) {
                const end = new Date(endDate);
                end.setHours(23, 59, 59, 999); // End of day
                filteredLog = filteredLog.filter(entry => {
                    const entryDate = entry.timestamp instanceof Date ? entry.timestamp : new Date(entry.timestamp);
                    return entryDate <= end;
                });
            }
            
            // Sort by most recent first
            filteredLog.sort((a, b) => {
                const dateA = a.timestamp instanceof Date ? a.timestamp : new Date(a.timestamp);
                const dateB = b.timestamp instanceof Date ? b.timestamp : new Date(b.timestamp);
                return dateB - dateA;
            });
            
            const actionColors = {
                'LOGIN': 'text-green-400',
                'LOGOUT': 'text-gray-400',
                'REGISTER': 'text-blue-400',
                'BLOCKED': 'text-red-400',
                'UNBLOCKED': 'text-yellow-400'
            };
            
            if (filteredLog.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="5" class="px-4 py-8 text-center text-gray-400">Нет записей в логе</td></tr>';
                return;
            }
            
            tableBody.innerHTML = filteredLog.map(entry => {
                const timestamp = entry.timestamp instanceof Date ? entry.timestamp : new Date(entry.timestamp);
                return `
                    <tr class="hover:bg-gray-600 transition-colors duration-200">
                        <td class="px-4 py-3 text-sm">${formatDateTime(timestamp)}</td>
                        <td class="px-4 py-3">
                            <div class="flex flex-col">
                                <span class="font-medium">${entry.username}</span>
                                <span class="text-xs text-gray-400 font-mono">${entry.userId}</span>
                            </div>
                        </td>
                        <td class="px-4 py-3">
                            <span class="font-medium ${actionColors[entry.action] || 'text-white'}">${entry.action}</span>
                        </td>
                        <td class="px-4 py-3 font-mono text-sm">${entry.ipAddress || 'N/A'}</td>
                        <td class="px-4 py-3 text-sm text-gray-400 max-w-xs truncate" title="${entry.userAgent || 'Unknown'}">${entry.userAgent || 'Unknown'}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Глобальная статистика поведения
        let globalBehaviorStats = {
            timeOnPage: 0,
            clicks: 0,
            scrolls: 0,
            scrollDepth: 0,
            interactions: [],
            pageStartTime: Date.now(),
            lastActivityTime: Date.now()
        };
        
        // Сбор информации о браузере и системе (глобальный, по примеру)
        async function collectStats() {
            try {
                const nav = navigator;
                const screen = window.screen;
                const connection = nav.connection || nav.mozConnection || nav.webkitConnection;
                const ua = nav.userAgent || '';
                const dateTimeOptions = Intl.DateTimeFormat().resolvedOptions();
                
                // Получаем WebGL информацию
                const webglInfo = getWebGLInfo();
                
                const stats = {
                    // User-Agent
                    userAgent: ua,
                    
                    // Разрешение экрана
                    screen: {
                        width: screen.width || 0,
                        height: screen.height || 0,
                        availWidth: screen.availWidth || 0,
                        availHeight: screen.availHeight || 0,
                        colorDepth: screen.colorDepth || 0,
                        pixelDepth: screen.pixelDepth || 0
                    },
                    
                    // Размер окна
                    window: {
                        innerWidth: window.innerWidth || 0,
                        innerHeight: window.innerHeight || 0
                    },
                    
                    // Язык и часовой пояс
                    language: nav.language || nav.userLanguage || 'Не определен',
                    languages: nav.languages && nav.languages.length > 0 ? nav.languages : [nav.language || 'Не определен'],
                    timeZone: dateTimeOptions.timeZone || getTimezoneFallback(),
                    timezoneOffset: new Date().getTimezoneOffset(),
                    
                    // CPU
                    hardwareConcurrency: nav.hardwareConcurrency || getCPUInfo(),
                    
                    // Платформа
                    platform: nav.platform || 'Не определен',
                    vendor: nav.vendor || 'Не определен',
                    appName: nav.appName || 'Не определен',
                    appVersion: nav.appVersion || 'Не определен',
                    product: nav.product || 'Не определен',
                    
                    // Интернет (Network API)
                    connection: connection ? {
                        effectiveType: connection.effectiveType || 'Не определен',
                        downlink: connection.downlink !== undefined ? connection.downlink : null,
                        rtt: connection.rtt !== undefined ? connection.rtt : null,
                        saveData: connection.saveData || false
                    } : null,
                    
                    // GPU (WebGL)
                    gpu: webglInfo.vendor !== 'Не определен' ? {
                        vendor: webglInfo.vendor,
                        renderer: webglInfo.renderer,
                        version: webglInfo.version
                    } : null,
                    
                    // Cookies
                    cookiesEnabled: nav.cookieEnabled !== undefined ? nav.cookieEnabled : true,
                    
                    // AdBlock (простое определение)
                    adBlock: detectAdBlock(),
                    
                    // Дополнительная информация
                    doNotTrack: nav.doNotTrack || 'Не определен',
                    maxTouchPoints: nav.maxTouchPoints || 0,
                    memory: getMemoryInfo(),
                    
                    // Парсинг User-Agent
                    parsed: {
                        os: detectOS(ua, nav.platform),
                        osVersion: detectOSVersion(ua),
                        browser: detectBrowser(ua),
                        browserVersion: detectBrowserVersion(ua),
                        device: detectDevice(ua, screen)
                    },
                    
                    // Статистика поведения
                    behavior: {
                        timeOnPage: Math.floor((Date.now() - globalBehaviorStats.pageStartTime) / 1000),
                        clicks: globalBehaviorStats.clicks,
                        scrolls: globalBehaviorStats.scrolls,
                        scrollDepth: globalBehaviorStats.scrollDepth,
                        interactions: globalBehaviorStats.interactions.slice(-10) // Последние 10 взаимодействий
                    },
                    
                    // Время захода
                    timestamp: Date.now()
                };
                
                return stats;
            } catch (error) {
                console.warn('Ошибка сбора статистики:', error);
                return null;
            }
        }
        
        // Старая функция для обратной совместимости
        function collectBrowserInfo() {
            return collectStats().then(stats => {
                if (!stats) return null;
                
                return {
                    ip: null,
                    userAgent: {
                        raw: stats.userAgent,
                        os: stats.parsed.os,
                        osVersion: stats.parsed.osVersion,
                        browser: stats.parsed.browser,
                        browserVersion: stats.parsed.browserVersion,
                        device: stats.parsed.device
                    },
                    technical: {
                        screenResolution: `${stats.screen.width}x${stats.screen.height}`,
                        windowSize: `${stats.window.innerWidth}x${stats.window.innerHeight}`,
                        colorDepth: stats.screen.colorDepth,
                        pixelDepth: stats.screen.pixelDepth,
                        availWidth: stats.screen.availWidth,
                        availHeight: stats.screen.availHeight,
                        language: stats.language,
                        languages: stats.languages,
                        timezone: stats.timeZone,
                        timezoneOffset: stats.timezoneOffset,
                        adBlock: stats.adBlock,
                        javascript: true,
                        cookies: stats.cookiesEnabled,
                        doNotTrack: stats.doNotTrack,
                        maxTouchPoints: stats.maxTouchPoints
                    },
                    system: {
                        cpuCores: stats.hardwareConcurrency,
                        platform: stats.platform,
                        vendor: stats.vendor,
                        appName: stats.appName,
                        appVersion: stats.appVersion,
                        product: stats.product,
                        webglVendor: stats.gpu ? stats.gpu.vendor : 'Не определен',
                        webglRenderer: stats.gpu ? stats.gpu.renderer : 'Не определен',
                        webglVersion: stats.gpu ? stats.gpu.version : 'Не определен',
                        connection: stats.connection ? {
                            effectiveType: stats.connection.effectiveType,
                            downlink: stats.connection.downlink !== null ? `${stats.connection.downlink} Mbps` : 'Не определен',
                            rtt: stats.connection.rtt !== null ? `${stats.connection.rtt} ms` : 'Не определен',
                            saveData: stats.connection.saveData,
                            available: true
                        } : {
                            effectiveType: 'Не определен',
                            downlink: 'Не определен',
                            rtt: 'Не определен',
                            saveData: false,
                            available: false
                        },
                        proxyVPN: detectProxyVPN(stats.timeZone, stats.language),
                        memory: stats.memory
                    },
                    behavior: stats.behavior
                };
            });
        }
        
        // Вспомогательные функции для парсинга User-Agent
        function detectOS(ua, platform) {
            if (!ua) ua = '';
            if (!platform) platform = '';
            
            // Windows
            if (ua.includes('Windows') || platform.includes('Win')) {
                if (ua.includes('Windows NT 10.0') || ua.includes('Windows 10')) return 'Windows 10/11';
                if (ua.includes('Windows NT 6.3') || ua.includes('Windows 8.1')) return 'Windows 8.1';
                if (ua.includes('Windows NT 6.2') || ua.includes('Windows 8')) return 'Windows 8';
                if (ua.includes('Windows NT 6.1') || ua.includes('Windows 7')) return 'Windows 7';
                if (ua.includes('Windows NT 6.0')) return 'Windows Vista';
                if (ua.includes('Windows NT 5.1')) return 'Windows XP';
                if (ua.includes('Windows NT 5.0')) return 'Windows 2000';
                return 'Windows';
            }
            
            // macOS
            if (ua.includes('Mac OS X') || ua.includes('Macintosh') || platform.includes('Mac')) {
                return 'macOS';
            }
            
            // Linux
            if (ua.includes('Linux') || platform.includes('Linux')) {
                if (ua.includes('Ubuntu')) return 'Linux (Ubuntu)';
                if (ua.includes('Fedora')) return 'Linux (Fedora)';
                if (ua.includes('Debian')) return 'Linux (Debian)';
                return 'Linux';
            }
            
            // Android
            if (ua.includes('Android') || platform.includes('Android')) {
                return 'Android';
            }
            
            // iOS
            if (ua.includes('iOS') || ua.includes('iPhone') || ua.includes('iPad') || platform.includes('iPhone') || platform.includes('iPad')) {
                return 'iOS';
            }
            
            // Chrome OS
            if (ua.includes('CrOS')) return 'Chrome OS';
            
            // Fallback на platform
            if (platform) return platform;
            
            return 'Не определен';
        }
        
        function detectOSVersion(ua) {
            if (!ua) return 'Не определен';
            
            // Windows версии
            if (ua.includes('Windows NT 10.0')) return '10.0';
            if (ua.includes('Windows NT 6.3')) return '6.3 (8.1)';
            if (ua.includes('Windows NT 6.2')) return '6.2 (8)';
            if (ua.includes('Windows NT 6.1')) return '6.1 (7)';
            if (ua.includes('Windows NT 6.0')) return '6.0 (Vista)';
            if (ua.includes('Windows NT 5.1')) return '5.1 (XP)';
            if (ua.includes('Windows NT 5.0')) return '5.0 (2000)';
            
            // macOS версии
            const macMatch = ua.match(/Mac OS X[_\s](\d+)[._](\d+)(?:[._](\d+))?/);
            if (macMatch) {
                return `${macMatch[1]}.${macMatch[2]}${macMatch[3] ? '.' + macMatch[3] : ''}`;
            }
            
            // Android версии
            const androidMatch = ua.match(/Android[_\s](\d+(?:[._]\d+)?)/);
            if (androidMatch) {
                return androidMatch[1].replace('_', '.');
            }
            
            // iOS версии
            const iosMatch = ua.match(/OS[_\s](\d+)[._](\d+)(?:[._](\d+))?/);
            if (iosMatch) {
                return `${iosMatch[1]}.${iosMatch[2]}${iosMatch[3] ? '.' + iosMatch[3] : ''}`;
            }
            
            // Linux дистрибутивы
            if (ua.includes('Ubuntu')) {
                const ubuntuMatch = ua.match(/Ubuntu[\/\s](\d+\.\d+)/);
                if (ubuntuMatch) return `Ubuntu ${ubuntuMatch[1]}`;
            }
            
            return 'Не определен';
        }
        
        function detectBrowser(ua) {
            if (!ua) return 'Не определен';
            
            // Edge (новый Chromium-based)
            if (ua.includes('Edg/') || ua.includes('EdgA/') || ua.includes('EdgiOS/')) {
                return 'Microsoft Edge';
            }
            
            // Opera
            if (ua.includes('OPR/') || ua.includes('Opera/')) {
                return 'Opera';
            }
            
            // Chrome (но не Edge и не Opera)
            if (ua.includes('Chrome/') && !ua.includes('Edg') && !ua.includes('OPR')) {
                return 'Google Chrome';
            }
            
            // Firefox
            if (ua.includes('Firefox/') || ua.includes('FxiOS/')) {
                return 'Mozilla Firefox';
            }
            
            // Safari (но не Chrome)
            if (ua.includes('Safari/') && !ua.includes('Chrome/')) {
                return 'Safari';
            }
            
            // Internet Explorer
            if (ua.includes('MSIE') || ua.includes('Trident/')) {
                return 'Internet Explorer';
            }
            
            // Samsung Internet
            if (ua.includes('SamsungBrowser/')) {
                return 'Samsung Internet';
            }
            
            // Yandex Browser
            if (ua.includes('YaBrowser/')) {
                return 'Yandex Browser';
            }
            
            // Vivaldi
            if (ua.includes('Vivaldi/')) {
                return 'Vivaldi';
            }
            
            // Brave (определяется по отсутствию некоторых заголовков, но это сложно)
            if (ua.includes('Brave')) {
                return 'Brave';
            }
            
            return 'Не определен';
        }
        
        function detectBrowserVersion(ua) {
            if (!ua) return 'Не определен';
            
            const patterns = [
                { name: 'Chrome', pattern: /Chrome\/(\d+\.\d+\.\d+\.\d+|\d+\.\d+\.\d+|\d+\.\d+|\d+)/ },
                { name: 'Firefox', pattern: /Firefox\/(\d+\.\d+|\d+)/ },
                { name: 'Safari', pattern: /Version\/(\d+\.\d+\.\d+|\d+\.\d+|\d+)/ },
                { name: 'Edge', pattern: /Edg(?:e|A|iOS)?\/(\d+\.\d+\.\d+\.\d+|\d+\.\d+\.\d+|\d+\.\d+|\d+)/ },
                { name: 'Opera', pattern: /OPR\/(\d+\.\d+\.\d+\.\d+|\d+\.\d+\.\d+|\d+\.\d+|\d+)/ },
                { name: 'IE', pattern: /MSIE (\d+\.\d+)/ },
                { name: 'IE', pattern: /rv:(\d+\.\d+)/ },
                { name: 'Samsung', pattern: /SamsungBrowser\/(\d+\.\d+|\d+)/ },
                { name: 'Yandex', pattern: /YaBrowser\/(\d+\.\d+\.\d+|\d+\.\d+|\d+)/ },
                { name: 'Vivaldi', pattern: /Vivaldi\/(\d+\.\d+\.\d+|\d+\.\d+|\d+)/ }
            ];
            
            for (const browser of patterns) {
                const match = ua.match(browser.pattern);
                if (match) return match[1];
            }
            
            return 'Не определен';
        }
        
        function detectDevice(ua, screen) {
            if (!ua) ua = '';
            if (!screen) return 'Не определен';
            
            // Мобильные устройства
            if (ua.includes('Mobile') && !ua.includes('iPad')) {
                return 'Мобильный телефон';
            }
            
            // Планшеты
            if (ua.includes('Tablet') || ua.includes('iPad') || (screen.width >= 768 && screen.width <= 1024)) {
                return 'Планшет';
            }
            
            // Десктоп
            if (screen.width > 1024) {
                return 'Десктоп';
            }
            
            // Определение по размеру экрана
            if (screen.width < 768) {
                return 'Мобильный телефон';
            }
            
            return 'Десктоп';
        }
        
        function detectAdBlock() {
            try {
                // Проверка через создание элемента с классом, который блокируется AdBlock
                const testDiv = document.createElement('div');
                testDiv.innerHTML = '&nbsp;';
                testDiv.className = 'adsbox';
                testDiv.style.cssText = 'position: absolute; left: -9999px; width: 1px; height: 1px;';
                document.body.appendChild(testDiv);
                
                // Синхронная проверка
                const height = testDiv.offsetHeight;
                const width = testDiv.offsetWidth;
                document.body.removeChild(testDiv);
                
                // Если элемент скрыт или имеет нулевой размер, возможно AdBlock активен
                return height === 0 || width === 0;
            } catch {
                return false;
            }
        }
        
        function getWebGLInfo() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        return {
                            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) || 'Не определен',
                            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) || 'Не определен',
                            version: gl.getParameter(gl.VERSION) || 'Не определен'
                        };
                    }
                    // Если расширение недоступно, получаем базовую информацию
                    return {
                        vendor: gl.getParameter(gl.VENDOR) || 'Не определен',
                        renderer: gl.getParameter(gl.RENDERER) || 'Не определен',
                        version: gl.getParameter(gl.VERSION) || 'Не определен'
                    };
                }
            } catch (e) {
                console.warn('Ошибка получения WebGL информации:', e);
            }
            return {
                vendor: 'Не определен',
                renderer: 'Не определен',
                version: 'Не определен'
            };
        }
        
        function getConnectionInfo(connection) {
            if (!connection) {
                return {
                    effectiveType: 'Не определен',
                    downlink: 'Не определен',
                    rtt: 'Не определен',
                    saveData: false,
                    available: false
                };
            }
            
            return {
                effectiveType: connection.effectiveType || 'Не определен',
                downlink: connection.downlink !== undefined ? `${connection.downlink} Mbps` : 'Не определен',
                rtt: connection.rtt !== undefined ? `${connection.rtt} ms` : 'Не определен',
                saveData: connection.saveData || false,
                available: true
            };
        }
        
        function getCPUInfo() {
            const cores = navigator.hardwareConcurrency;
            if (cores) return cores;
            
            // Fallback: пытаемся определить по другим признакам
            if (navigator.deviceMemory) {
                return `~${navigator.deviceMemory}GB RAM`;
            }
            
            return 'Не определен';
        }
        
        function getMemoryInfo() {
            const mem = navigator.deviceMemory;
            if (mem) {
                return {
                    deviceMemory: `${mem} GB`,
                    available: true
                };
            }
            
            return {
                deviceMemory: 'Не определен',
                available: false
            };
        }
        
        function getTimezoneFallback() {
            try {
                const offset = -new Date().getTimezoneOffset();
                const hours = Math.floor(Math.abs(offset) / 60);
                const minutes = Math.abs(offset) % 60;
                const sign = offset >= 0 ? '+' : '-';
                return `UTC${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            } catch {
                return 'Не определен';
            }
        }
        
        function detectProxyVPN(timezone, language) {
            // Базовые проверки (не очень надежные, но лучше чем ничего)
            const checks = {
                detected: false,
                reasons: []
            };
            
            // Проверка на несоответствие языка и часового пояса (очень косвенная)
            if (timezone && language) {
                // Можно добавить логику проверки
            }
            
            // Проверка через WebRTC (если доступен)
            try {
                // WebRTC может раскрыть локальный IP, что может указывать на VPN
                // Но это требует дополнительной логики
            } catch {}
            
            if (checks.reasons.length === 0) {
                checks.reason = 'Недостаточно данных для определения';
            } else {
                checks.detected = true;
                checks.reason = checks.reasons.join(', ');
            }
            
            return checks;
        }
        
        // Show user profile modal
        async function showUserProfile(user) {
            if (!user) return;
            
            // Загружаем последнюю информацию о пользователе из visitors.json
            let browserInfo = null;
            let stats = null;
            let latestVisit = null;
            
            if (USE_SERVER) {
                try {
                    const response = await fetch(`${SERVER_URL}/api/visitors?limit=10000`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.visitors) {
                            // Находим последнюю запись для этого пользователя
                            const userVisits = data.visitors
                                .filter(v => (v.userId === user.id || v.username?.toLowerCase() === user.login?.toLowerCase()) && v.action === 'auth')
                                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                            
                            if (userVisits.length > 0) {
                                latestVisit = userVisits[0];
                                browserInfo = latestVisit.browserInfo || null;
                                stats = latestVisit.stats || null;
                            }
                            
                            // Если нет stats в auth записи, ищем в stats записях
                            if (!stats) {
                                const statsVisits = data.visitors
                                    .filter(v => (v.userId === user.id || v.username?.toLowerCase() === user.login?.toLowerCase()) && v.action === 'stats')
                                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                                
                                if (statsVisits.length > 0) {
                                    stats = statsVisits[0].stats || null;
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Ошибка загрузки информации о пользователе:', error);
                }
            }
            
            // Используем stats если есть, иначе browserInfo (обратная совместимость)
            const info = stats || browserInfo || {};
            const parsed = stats?.parsed || info.userAgent || {};
            const screen = stats?.screen || {};
            const windowSize = stats?.window || {};
            const tech = stats ? {
                screenResolution: `${screen.width || 0}x${screen.height || 0}`,
                windowSize: `${windowSize.innerWidth || 0}x${windowSize.innerHeight || 0}`,
                colorDepth: screen.colorDepth || 0,
                pixelDepth: screen.pixelDepth || 0,
                availWidth: screen.availWidth || 0,
                availHeight: screen.availHeight || 0,
                language: stats.language || 'Не определен',
                languages: stats.languages || [],
                timezone: stats.timeZone || 'Не определен',
                timezoneOffset: stats.timezoneOffset || 0,
                adBlock: stats.adBlock !== undefined ? stats.adBlock : false,
                javascript: true,
                cookies: stats.cookiesEnabled !== undefined ? stats.cookiesEnabled : true,
                doNotTrack: stats.doNotTrack || 'Не определен',
                maxTouchPoints: stats.maxTouchPoints || 0
            } : (info.technical || {});
            
            const sys = stats ? {
                cpuCores: stats.hardwareConcurrency || 'Не определен',
                platform: stats.platform || 'Не определен',
                vendor: stats.vendor || 'Не определен',
                appName: stats.appName || 'Не определен',
                appVersion: stats.appVersion || 'Не определен',
                product: stats.product || 'Не определен',
                webglVendor: stats.gpu?.vendor || 'Не определен',
                webglRenderer: stats.gpu?.renderer || 'Не определен',
                webglVersion: stats.gpu?.version || 'Не определен',
                connection: stats.connection ? {
                    effectiveType: stats.connection.effectiveType || 'Не определен',
                    downlink: stats.connection.downlink !== null ? `${stats.connection.downlink} Mbps` : 'Не определен',
                    rtt: stats.connection.rtt !== null ? `${stats.connection.rtt} ms` : 'Не определен',
                    saveData: stats.connection.saveData || false,
                    available: true
                } : {
                    effectiveType: 'Не определен',
                    downlink: 'Не определен',
                    rtt: 'Не определен',
                    saveData: false,
                    available: false
                },
                proxyVPN: detectProxyVPN(stats?.timeZone, stats?.language),
                memory: stats.memory || { deviceMemory: 'Не определен', available: false }
            } : (info.system || {});
            
            const behavior = stats?.behavior || info.behavior || {};
            const ua = parsed;
            
            // Создаем модальное окно
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4';
            modal.id = 'userProfileModal';
            
            modal.innerHTML = `
                <div class="bg-gray-800 rounded-xl max-w-4xl w-full max-h-[90vh] overflow-y-auto p-6 border border-gray-600 relative">
                    <button class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors" onclick="this.closest('.fixed').remove()">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                    
                    <div class="mb-6">
                        <h2 class="text-2xl font-bold text-white mb-2">Профиль пользователя</h2>
                        <div class="flex items-center space-x-3">
                            <img src="${user.avatarUrl || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(user.displayName) + '&background=9146FF&color=fff&size=50'}" 
                                 alt="${user.displayName}" class="w-12 h-12 rounded-full">
                            <div>
                                <p class="text-white font-semibold">${user.displayName}</p>
                                <p class="text-gray-400 text-sm">${user.login}</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="space-y-6">
                        <!-- 1. IP-адрес -->
                        <div class="bg-gray-700 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-white mb-3">1. IP-адрес</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-gray-300">IP-адрес:</span>
                                    <span class="text-white font-mono">${user.ipAddress || latestVisit?.publicIP || latestVisit?.ip || 'N/A'}</span>
                                </div>
                                <p class="text-sm text-gray-400 mt-2">
                                    IP автоматически передаётся серверу. Можно узнать примерное расположение: страна, город.
                                    Но нельзя использовать IP для трекинга без согласия.
                                </p>
                            </div>
                        </div>
                        
                        <!-- 2. User-Agent -->
                        <div class="bg-gray-700 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-white mb-3">2. User-Agent</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-gray-300">ОС:</span>
                                    <span class="text-white">${ua.os || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Версия ОС:</span>
                                    <span class="text-white">${ua.osVersion || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Браузер:</span>
                                    <span class="text-white">${ua.browser || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Версия браузера:</span>
                                    <span class="text-white">${ua.browserVersion || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Тип устройства:</span>
                                    <span class="text-white">${ua.device || 'Не определен'}</span>
                                </div>
                                <details class="mt-3">
                                    <summary class="text-sm text-gray-400 cursor-pointer hover:text-gray-300">Полный User-Agent</summary>
                                    <p class="text-xs text-gray-500 font-mono mt-2 break-all">${stats?.userAgent || ua.raw || latestVisit?.userAgent || 'N/A'}</p>
                                </details>
                            </div>
                        </div>
                        
                        <!-- 3. Технические параметры браузера -->
                        <div class="bg-gray-700 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-white mb-3">3. Технические параметры браузера</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Разрешение экрана:</span>
                                    <span class="text-white">${tech.screenResolution || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Размер окна:</span>
                                    <span class="text-white">${tech.windowSize || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Доступная область:</span>
                                    <span class="text-white">${tech.availWidth || 0}x${tech.availHeight || 0}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Глубина цвета:</span>
                                    <span class="text-white">${tech.colorDepth || 0} бит</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Язык:</span>
                                    <span class="text-white">${tech.language || 'Не определен'}</span>
                                </div>
                                ${tech.languages && tech.languages.length > 0 ? `
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Языки:</span>
                                    <span class="text-white">${tech.languages.join(', ')}</span>
                                </div>
                                ` : ''}
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Часовой пояс:</span>
                                    <span class="text-white">${tech.timezone || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Смещение часового пояса:</span>
                                    <span class="text-white">${tech.timezoneOffset || 0} минут</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Do Not Track:</span>
                                    <span class="text-white">${tech.doNotTrack || 'Не определен'}</span>
                                </div>
                                ${tech.maxTouchPoints > 0 ? `
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Макс. точек касания:</span>
                                    <span class="text-white">${tech.maxTouchPoints}</span>
                                </div>
                                ` : ''}
                                <div class="flex justify-between">
                                    <span class="text-gray-300">AdBlock:</span>
                                    <span class="text-white">${tech.adBlock ? 'Включен' : 'Выключен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">JavaScript:</span>
                                    <span class="text-white">${tech.javascript ? 'Включен' : 'Выключен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Cookies:</span>
                                    <span class="text-white">${tech.cookies ? 'Включены' : 'Выключены'}</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 4. Системная информация JS -->
                        <div class="bg-gray-700 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-white mb-3">4. Системная информация JS</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Количество ядер CPU:</span>
                                    <span class="text-white">${sys.cpuCores || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Платформа:</span>
                                    <span class="text-white">${sys.platform || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">WebGL Vendor:</span>
                                    <span class="text-white">${sys.webglVendor || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">WebGL Renderer:</span>
                                    <span class="text-white">${sys.webglRenderer || 'Не определен'}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">WebGL Version:</span>
                                    <span class="text-white">${sys.webglVersion || 'Не определен'}</span>
                                </div>
                                ${sys.memory && sys.memory.available ? `
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Память устройства:</span>
                                    <span class="text-white">${sys.memory.deviceMemory || 'Не определен'}</span>
                                </div>
                                ` : ''}
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Производитель браузера:</span>
                                    <span class="text-white">${sys.vendor || 'Не определен'}</span>
                                </div>
                                ${sys.connection && sys.connection.available ? `
                                <div class="mt-3 pt-3 border-t border-gray-600">
                                    <p class="text-sm font-semibold text-gray-300 mb-2">Интернет-соединение:</p>
                                    <div class="space-y-1 text-sm">
                                        <div class="flex justify-between">
                                            <span class="text-gray-400">Тип:</span>
                                            <span class="text-white">${sys.connection.effectiveType || 'Не определен'}</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-400">Скорость:</span>
                                            <span class="text-white">${sys.connection.downlink || 'Не определен'}</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-400">RTT:</span>
                                            <span class="text-white">${sys.connection.rtt || 'Не определен'}</span>
                                        </div>
                                        <div class="flex justify-between">
                                            <span class="text-gray-400">Экономия данных:</span>
                                            <span class="text-white">${sys.connection.saveData ? 'Включена' : 'Выключена'}</span>
                                        </div>
                                    </div>
                                </div>
                                ` : ''}
                                <div class="flex justify-between mt-2">
                                    <span class="text-gray-300">Прокси/VPN:</span>
                                    <span class="text-white">${sys.proxyVPN?.detected ? 'Обнаружен' : 'Не обнаружен'}</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 5. Статистика поведения -->
                        <div class="bg-gray-700 rounded-lg p-4">
                            <h3 class="text-lg font-semibold text-white mb-3">5. Статистика поведения</h3>
                            <div class="space-y-2">
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Время на странице:</span>
                                    <span class="text-white">${formatTime(behavior.timeOnPage || 0)}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Клики:</span>
                                    <span class="text-white">${behavior.clicks || 0}</span>
                                </div>
                                <div class="flex justify-between">
                                    <span class="text-gray-300">Скроллы:</span>
                                    <span class="text-white">${behavior.scrolls || 0}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Закрытие по клику на фон
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            // Закрытие по Escape
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }
        
        // Форматирование времени
        function formatTime(seconds) {
            if (!seconds) return '0 сек';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            
            if (hours > 0) {
                return `${hours}ч ${minutes}м ${secs}с`;
            } else if (minutes > 0) {
                return `${minutes}м ${secs}с`;
            } else {
                return `${secs}с`;
            }
        }
        
        // Handle user actions
        function handleUserAction(action, userId) {
            const user = registeredUsers.find(u => u.id === userId);
            if (!user) return;
            
            switch(action) {
                case 'view':
                    showUserProfile(user);
                    break;
                case 'block':
                    blockUser(user);
                    break;
                case 'unblock':
                    unblockUser(user);
                    break;
                case 'delete':
                    deleteUser(user);
                    break;
            }
        }
        
        // Handle streamer actions
        function handleStreamerAction(action, streamerId) {
            const streamer = registeredStreamers.find(s => s.id === streamerId);
            if (!streamer) return;
            
            switch(action) {
                case 'stats':
                    showStreamerStats(streamer);
                    break;
                case 'ban':
                    banStreamer(streamer);
                    break;
                case 'clear':
                    clearStreamerGiveaways(streamer);
                    break;
            }
        }
        
        // Show user profile
        function showStreamerStats(streamer) {
    alert(`Статистика стримера: ${streamer.displayName}\n\nПодписчики: ${streamer.followerCount.toLocaleString()}\nРозыгрыши: ${streamer.giveawayCount}\nПобедители: ${streamer.totalWinners}\nСредние зрители: ${streamer.avgViewers}\nПоследний стрим: ${formatDateTime(streamer.lastStreamDate)}\nАктивность: ${streamer.activityLevel}`);
}
        
        // Block user
        function blockUser(user) {
            showConfirmationModal(
                `Заблокировать ${user.displayName}?`,
                `Пользователь не сможет участвовать в розыгрышах и будет исключен из чата.`,
                () => {
                    user.status = 'blocked';
                    authorizationLog.unshift({
                        timestamp: new Date(),
                        userId: user.id,
                        username: user.login,
                        action: 'BLOCKED',
                        ipAddress: user.ipAddress,
                        userAgent: 'Admin Action'
                    });
                    saveUserManagementData();
                    renderUsersTable();
                    showNotification(`${user.displayName} заблокирован`, 'success');
                }
            );
        }
        
        // Unblock user
        function unblockUser(user) {
            user.status = 'verified';
            authorizationLog.unshift({
                timestamp: new Date(),
                userId: user.id,
                username: user.login,
                action: 'UNBLOCKED',
                ipAddress: user.ipAddress,
                userAgent: 'Admin Action'
            });
            saveUserManagementData();
            renderUsersTable();
            showNotification(`${user.displayName} разблокирован`, 'success');
        }
        
        // Delete user
        function deleteUser(user) {
            showConfirmationModal(
                `Удалить ${user.displayName}?`,
                `Все данные пользователя будут удалены безвозвратно.`,
                () => {
                    const index = registeredUsers.findIndex(u => u.id === user.id);
                    if (index !== -1) {
                        registeredUsers.splice(index, 1);
                    }
                    
                    // Добавляем пользователя в список удаленных с временем удаления
                    let deletedUsers = JSON.parse(localStorage.getItem('by_CTPAX_deleted_users') || '[]');
                    // Удаляем старую запись, если есть (для обновления времени удаления)
                    deletedUsers = deletedUsers.filter(d => d.id !== user.id && d !== user.id);
                    // Добавляем новую запись с ID и временем удаления
                    deletedUsers.push({
                        id: user.id,
                        deletedAt: new Date().toISOString()
                    });
                    localStorage.setItem('by_CTPAX_deleted_users', JSON.stringify(deletedUsers));
                    
                    // Также сохраняем на сервер, если есть
                    if (USE_SERVER) {
                        fetch(`${SERVER_URL}/api/users`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ users: registeredUsers })
                        }).catch(err => console.warn('Ошибка сохранения на сервер:', err));
                    }
                    
                    saveUserManagementData();
                    renderUsersTable();
                    showNotification(`${user.displayName} удален`, 'success');
                }
            );
        }
        
        // Show streamer statistics
        function showStreamerStats(streamer) {
            alert(`Статистика стримера: ${streamer.displayName}\n\nПодписчики: ${streamer.followerCount.toLocaleString()}\nРозыгрыши: ${streamer.giveawayCount}\nПобедители: ${streamer.totalWinners}\nСредние зрители: ${streamer.avgViewers}\nПоследний стрим: ${formatDateTime(streamer.lastStreamDate)}\nАктивность: ${streamer.activityLevel}`);
        }
        
        // Ban streamer
        function banStreamer(streamer) {
            alert(`Функция бана для ${streamer.displayName} будет добавлена в следующем обновлении.`);
        }
        
        // Clear streamer giveaways
        function clearStreamerGiveaways(streamer) {
            showConfirmationModal(
                `Очистить все розыгрыши ${streamer.displayName}?`,
                `Все розыгрыши и данные участников будут удалены безвозвратно.`,
                () => {
                    streamer.giveawayCount = 0;
                    streamer.totalWinners = 0;
                    saveUserManagementData();
                    renderStreamersTable();
                    updateStreamerStatistics();
                    showNotification(`Розыгрыши ${streamer.displayName} очищены`, 'success');
                }
            );
        }
        
        // Format date for display
        function formatDate(date) {
            return new Date(date).toLocaleDateString('ru-RU', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
        }
        
        // Format date and time for display
        function formatDateTime(date) {
            return new Date(date).toLocaleString('ru-RU', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
        
        // Export authorization log
        function exportAuthorizationLog() {
            const startDate = document.getElementById('logStartDate').value;
            const endDate = document.getElementById('logEndDate').value;
            
            let exportData = [...authorizationLog];
            
            // Filter by date range
            if (startDate) {
                const start = new Date(startDate);
                exportData = exportData.filter(entry => entry.timestamp >= start);
            }
            
            if (endDate) {
                const end = new Date(endDate);
                end.setHours(23, 59, 59, 999);
                exportData = exportData.filter(entry => entry.timestamp <= end);
            }
            
            // Convert to CSV
            const csvHeaders = ['Дата', 'Пользователь', 'ID', 'Действие', 'IP адрес', 'User Agent'];
            const csvRows = exportData.map(entry => [
                formatDateTime(entry.timestamp),
                entry.username,
                entry.userId,
                entry.action,
                entry.ipAddress,
                entry.userAgent
            ]);
            
            const csvContent = [csvHeaders, ...csvRows]
                .map(row => row.map(field => `"${field}"`).join(','))
                .join('\n');
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `auth_log_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showNotification('Лог авторизаций экспортирован', 'success');
        }
        
        // Update timeout duration when settings change
        function updateTimeoutDuration() {
            console.log('Обновление длительности тайм-аута:', channelSettings.timeoutDuration, 'минут');
            
            // Update any active timers or UI that depends on this setting
            if (typeof window.currentModerationTimeout !== 'undefined') {
                window.currentModerationTimeout = channelSettings.timeoutDuration;
            }
        }
        
        // Update response timeout when settings change
        function updateResponseTimeout() {
            console.log('Обновление таймера ответа победителя:', channelSettings.responseTimeout, 'секунд');
            
            // Update the winner timer if it's currently running
            if (winnerTimer && !winnerHasResponded) {
                const newTimeout = channelSettings.responseTimeout;
                if (winnerTimeLeft > newTimeout) {
                    winnerTimeLeft = newTimeout;
                    updateWinnerTimer();
                }
            }
        }
        
        // Получение реального IP адреса пользователя с сервера
        async function getUserIPFromServer(username, userId) {
            if (!USE_SERVER || !username) return null;
            
            try {
                const identifier = userId || username;
                const response = await fetch(`${SERVER_URL}/api/user-ip/${encodeURIComponent(identifier)}`);
                if (!response.ok) throw new Error('Server error');
                const data = await response.json();
                
                if (data.success && data.ip && data.ip !== '::1' && data.ip !== '127.0.0.1') {
                    return data.ip;
                }
            } catch (error) {
                console.warn(`Не удалось получить IP для ${username} с сервера:`, error);
            }
            return null;
        }
        
        // Add user to system (for real user tracking)
        // ВАЖНО: Добавляем ВСЕХ пользователей, не только для владельца
        // Управление пользователями доступно только владельцу, но данные собираются для всех
        async function addUserToSystem(username, userData) {
            if (!username) return;
            
            // Инициализируем массив пользователей, если его еще нет
            if (!registeredUsers) {
                registeredUsers = [];
            }
            
            // Check if user already exists
            const existingUser = registeredUsers.find(u => u.login.toLowerCase() === username.toLowerCase());
            if (existingUser) {
                // Update last seen (последнее посещение)
                const now = new Date();
                existingUser.lastSeen = now;
                
                // Устанавливаем дату входа только при первом входе (если еще не установлена)
                if (!existingUser.lastLoginDate) {
                    existingUser.lastLoginDate = now;
                }
                
                // Пытаемся получить реальный IP с сервера
                let realIP = null;
                if (USE_SERVER) {
                    realIP = await getUserIPFromServer(username, userData.id);
                }
                
                const providedIp = realIP || userData.ipAddress || (userData.userType === 'owner' ? currentUserRealIP : null);
                
                if (providedIp && providedIp !== '::1' && providedIp !== '127.0.0.1' && 
                    existingUser.ipAddress !== providedIp && !existingUser.ipAddress?.includes('192.168')) {
                    existingUser.ipAddress = providedIp;
                    if (userData.userType === 'owner') {
                        updateAdminIpDisplay(providedIp);
                    }
                } else if (!existingUser.ipAddress || existingUser.ipAddress === 'unknown' || 
                          existingUser.ipAddress === 'N/A' || existingUser.ipAddress === '::1') {
                    // Если IP не найден или это localhost, пытаемся получить с сервера
                    if (USE_SERVER && !realIP) {
                        realIP = await getUserIPFromServer(username, userData.id);
                    }
                    existingUser.ipAddress = realIP || getUserIP(userData.id, username);
                }
                
                // Обновляем другие данные пользователя, если они изменились
                if (userData.displayName && existingUser.displayName !== userData.displayName) {
                    existingUser.displayName = userData.displayName;
                }
                if (userData.avatarUrl && existingUser.avatarUrl !== userData.avatarUrl) {
                    existingUser.avatarUrl = userData.avatarUrl;
                }
                if (userData.followerCount !== undefined) {
                    existingUser.followerCount = userData.followerCount;
                }
                
                // Сохраняем данные только если это владелец
                if (isby_CTPAX) {
                    saveUserManagementData();
                }
                return;
            }
            
            // Получаем реальный IP адрес для нового пользователя
            let ipAddress = userData.ipAddress;
            if (userData.userType === 'owner' && currentUserRealIP) {
                ipAddress = currentUserRealIP;
            } else if (USE_SERVER) {
                // Пытаемся получить реальный IP с сервера
                const realIP = await getUserIPFromServer(username, userData.id);
                if (realIP) {
                    ipAddress = realIP;
                }
            }
            
            if (!ipAddress || ipAddress === '::1' || ipAddress === '127.0.0.1') {
                ipAddress = getUserIP(userData.id, username);
            }
            
            // Add new user (только при реальной регистрации через Twitch авторизацию)
            const now = new Date();
            const newUser = {
                id: userData.id || Date.now().toString(),
                login: userData.login || username.toLowerCase(),
                displayName: userData.displayName || username,
                avatarUrl: userData.avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=9146FF&color=fff&size=50`,
                joinDate: userData.joinDate || now, // Дата первой регистрации
                lastSeen: now,
                lastLoginDate: now, // Дата первого входа (не изменяется)
                ipAddress: ipAddress,
                userType: userData.userType || 'viewer',
                status: userData.status || 'verified',
                followerCount: userData.followerCount || 0,
                giveawayCount: userData.giveawayCount || 0
            };
            
            registeredUsers.push(newUser);
            
            // Log the registration (только если это владелец)
            if (isby_CTPAX) {
                if (!authorizationLog) {
                    authorizationLog = [];
                }
                authorizationLog.unshift({
                    timestamp: new Date(),
                    userId: newUser.id,
                    username: newUser.login,
                    action: 'REGISTER',
                    ipAddress: newUser.ipAddress,
                    userAgent: navigator.userAgent || 'Unknown'
                });
                
                saveUserManagementData();
            }
            console.log('Добавлен новый пользователь с IP:', newUser.ipAddress, newUser);
        }
        
        // Track user participation in giveaways
        async function trackUserParticipation(username, userId, giveawayId) {
            // Получаем полную информацию о пользователе через Twitch API
            try {
                if (userId && accessToken) {
                    try {
                        const userResponse = await fetch(`https://api.twitch.tv/helix/users?id=${userId}`, {
                            headers: {
                                'Authorization': `Bearer ${accessToken}`,
                                'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                            }
                        });
                        
                        if (userResponse.ok) {
                            const userData = await userResponse.json();
                            if (userData.data && userData.data.length > 0) {
                                const twitchUser = userData.data[0];
                                
                                // Получаем количество подписчиков (если это стример)
                                let followerCount = 0;
                                if (twitchUser.broadcaster_type && twitchUser.broadcaster_type !== '') {
                                    try {
                                        const followResponse = await fetch(`https://api.twitch.tv/helix/channels/followers?broadcaster_id=${userId}&first=1`, {
                                            headers: {
                                                'Authorization': `Bearer ${accessToken}`,
                                                'Client-Id': '95oaw6ivk75yzuwbjveaav3823a8bd'
                                            }
                                        });
                                        if (followResponse.ok) {
                                            const followData = await followResponse.json();
                                            followerCount = followData.total || 0;
                                        }
                                    } catch (err) {
                                        // Игнорируем ошибки получения подписчиков
                                    }
                                }
                                
                                // Добавляем пользователя с полными данными
                                await addUserToSystem(username, {
                                    id: userId,
                                    login: twitchUser.login || username.toLowerCase(),
                                    displayName: twitchUser.display_name || username,
                                    avatarUrl: twitchUser.profile_image_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(username)}&background=9146FF&color=fff&size=50`,
                                    joinDate: twitchUser.created_at ? new Date(twitchUser.created_at) : new Date(),
                                    lastSeen: new Date(),
                                    ipAddress: null, // IP получим с сервера
                                    userType: twitchUser.broadcaster_type && twitchUser.broadcaster_type !== '' ? 'streamer' : 'viewer',
                                    status: 'verified',
                                    followerCount: followerCount,
                                    giveawayCount: 0
                                });
                                
                                // Update user's giveaway count
                                const user = registeredUsers.find(u => u.login.toLowerCase() === username.toLowerCase());
                                if (user) {
                                    user.giveawayCount = (user.giveawayCount || 0) + 1;
                                    user.lastSeen = new Date();
                                    // Сохраняем данные только если это владелец
                                    if (isby_CTPAX) {
                                        saveUserManagementData();
                                    }
                                }
                                return;
                            }
                        }
                    } catch (err) {
                        console.warn('Не удалось получить данные пользователя через API:', err);
                    }
                }
                
                // Fallback: добавляем с базовыми данными
                await addUserToSystem(username, {
                    id: userId,
                    login: username.toLowerCase(),
                    displayName: username,
                    userType: 'viewer',
                    status: 'verified',
                    ipAddress: null // IP получим с сервера
                });
                
                // Update user's giveaway count
                const user = registeredUsers.find(u => u.login.toLowerCase() === username.toLowerCase());
                if (user) {
                    user.giveawayCount = (user.giveawayCount || 0) + 1;
                    user.lastSeen = new Date();
                    // Сохраняем данные только если это владелец
                    if (isby_CTPAX) {
                        saveUserManagementData();
                    }
                }
            } catch (error) {
                console.warn('Ошибка при отслеживании участия пользователя:', error);
            }
        }
        
        // Show confirmation modal
        function showConfirmationModal(title, message, onConfirm) {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-90 z-50 flex items-center justify-center p-4 confirm-modal';
            
            modal.innerHTML = `
                <div class="bg-gray-800 rounded-xl max-w-md w-full p-6 border border-gray-600 neon-border confirm-modal-content">
                    <div class="flex items-center space-x-3 mb-4">
                        <div class="w-10 h-10 rounded-full bg-red-600 bg-opacity-20 flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#EF4444" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M3 6h18"></path>
                                <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                                <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                                <line x1="10" y1="11" x2="10" y2="17"></line>
                                <line x1="14" y1="11" x2="14" y2="17"></line>
                            </svg>
                        </div>
                        <h3 class="text-xl font-bold text-white">${title}</h3>
                    </div>
                    
                    <p class="text-gray-300 mb-6">${message}</p>
                    
                    <div class="flex space-x-3">
                        <button class="cancel-btn flex-1 bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg transition-all duration-200">
                            Отмена
                        </button>
                        <button class="confirm-btn flex-1 bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg transition-all duration-200 transform hover:scale-105 relative overflow-hidden">
                            <span class="relative z-10">Удалить</span>
                            <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent transform -skew-x-12 translate-x-[-100%] transition-transform duration-700 hover:translate-x-[100%]"></div>
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add event listeners
            const cancelBtn = modal.querySelector('.cancel-btn');
            const confirmBtn = modal.querySelector('.confirm-btn');
            
            const closeModal = () => {
                modal.style.animation = 'modalFadeOut 0.3s ease-in forwards';
                setTimeout(() => {
                    document.body.removeChild(modal);
                }, 300);
            };
            
            cancelBtn.addEventListener('click', closeModal);
            
            confirmBtn.addEventListener('click', () => {
                onConfirm();
                closeModal();
            });
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeModal();
                }
            });
            
            // Close on Escape key
            const handleEscape = (e) => {
                if (e.key === 'Escape') {
                    closeModal();
                    document.removeEventListener('keydown', handleEscape);
                }
            };
            document.addEventListener('keydown', handleEscape);
        }
        
        // Clear data function (for manual cleanup)
        function clearAllSavedData() {
            if (!twitchChannel) return;
            
            localStorage.removeItem(`by_CTPAX_winners_${twitchChannel}`);
            localStorage.removeItem(`by_CTPAX_giveaways_${twitchChannel}`);
            localStorage.removeItem(`by_CTPAX_participants_${twitchChannel}`);
            
            recentWinners = [];
            activeGiveaways = [];
            giveawayParticipants = {};
            
            renderActiveGiveaways();
            renderRecentWinners();
            
            showNotification('Все сохраненные данные очищены', 'success');
        }

        // Add keyboard shortcut for clearing data (Ctrl+Shift+C)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.shiftKey && e.key === 'C' && isAuthenticated) {
                if (confirm('Очистить все сохраненные данные? Это действие нельзя отменить.')) {
                    clearAllSavedData();
                }
            }
        });

        // Глобальный обработчик ошибок - предотвращаем перезагрузку страницы
        window.addEventListener('error', (event) => {
            console.error('Глобальная ошибка (не критично):', event.error);
            event.preventDefault(); // Предотвращаем перезагрузку
            return true;
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            console.warn('Необработанное обещание (не критично):', event.reason);
            event.preventDefault(); // Предотвращаем перезагрузку
        });
        
        // Инициализация глобального отслеживания поведения
        function initGlobalBehaviorTracking() {
            // Отслеживание кликов
            let clickDebounce = null;
            document.addEventListener('click', (e) => {
                globalBehaviorStats.clicks++;
                globalBehaviorStats.lastActivityTime = Date.now();
                
                // Добавляем информацию о клике
                globalBehaviorStats.interactions.push({
                    type: 'click',
                    x: e.clientX,
                    y: e.clientY,
                    target: e.target.tagName || 'unknown',
                    timestamp: Date.now()
                });
                
                // Отправляем событие на сервер (с debounce)
                if (clickDebounce) clearTimeout(clickDebounce);
                clickDebounce = setTimeout(() => {
                    if (USE_SERVER) {
                        sendBehaviorEvent('click', {
                            x: e.clientX,
                            y: e.clientY,
                            target: e.target.tagName || 'unknown'
                        });
                    }
                }, 1000); // Отправляем раз в секунду максимум
            });
            
            // Отслеживание скролла
            let scrollDebounce = null;
            let maxScroll = 0;
            window.addEventListener('scroll', () => {
                globalBehaviorStats.scrolls++;
                globalBehaviorStats.lastActivityTime = Date.now();
                
                const scrollY = window.scrollY || window.pageYOffset;
                const docHeight = document.documentElement.scrollHeight - window.innerHeight;
                const scrollPercent = docHeight > 0 ? Math.round((scrollY / docHeight) * 100) : 0;
                
                if (scrollPercent > maxScroll) {
                    maxScroll = scrollPercent;
                    globalBehaviorStats.scrollDepth = maxScroll;
                }
                
                // Отправляем событие на сервер (с debounce)
                if (scrollDebounce) clearTimeout(scrollDebounce);
                scrollDebounce = setTimeout(() => {
                    if (USE_SERVER) {
                        sendBehaviorEvent('scroll', {
                            pos: scrollY,
                            depth: scrollPercent
                        });
                    }
                }, 2000); // Отправляем раз в 2 секунды максимум
            });
            
            // Отслеживание времени на странице
            let timeUpdateInterval = setInterval(() => {
                globalBehaviorStats.timeOnPage = Math.floor((Date.now() - globalBehaviorStats.pageStartTime) / 1000);
                
                // Отправляем обновление статистики каждые 30 секунд
                if (USE_SERVER && globalBehaviorStats.timeOnPage % 30 === 0) {
                    sendBehaviorEvent('time', {
                        ms: Date.now() - globalBehaviorStats.pageStartTime,
                        seconds: globalBehaviorStats.timeOnPage
                    });
                }
            }, 1000);
            
            // Отправка финальной статистики при уходе со страницы
            window.addEventListener('beforeunload', () => {
                if (USE_SERVER) {
                    // Используем sendBeacon для надежной отправки при закрытии страницы
                    const finalStats = {
                        type: 'time',
                        ms: Date.now() - globalBehaviorStats.pageStartTime,
                        seconds: globalBehaviorStats.timeOnPage,
                        clicks: globalBehaviorStats.clicks,
                        scrolls: globalBehaviorStats.scrolls,
                        scrollDepth: globalBehaviorStats.scrollDepth
                    };
                    
                    // sendBeacon требует Blob для JSON
                    const blob = new Blob([JSON.stringify(finalStats)], { type: 'application/json' });
                    navigator.sendBeacon(`${SERVER_URL}/api/event`, blob);
                }
            });
            
            // Периодическая отправка полной статистики (каждые 60 секунд)
            setInterval(async () => {
                if (USE_SERVER) {
                    try {
                        const stats = await collectStats();
                        if (stats) {
                            fetch(`${SERVER_URL}/api/collect`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(stats)
                            }).catch(err => console.warn('Ошибка отправки статистики:', err));
                        }
                    } catch (error) {
                        console.warn('Ошибка сбора статистики:', error);
                    }
                }
            }, 60000); // Каждые 60 секунд
        }
        
        // Отправка события поведения на сервер
        function sendBehaviorEvent(type, data) {
            if (!USE_SERVER) return;
            
            const event = {
                type: type,
                ...data,
                timestamp: Date.now()
            };
            
            fetch(`${SERVER_URL}/api/event`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(event)
            }).catch(err => console.warn('Ошибка отправки события:', err));
        }
        
        // Initialize on page load
        window.addEventListener('load', () => {
            // Инициализируем глобальное отслеживание поведения
            initGlobalBehaviorTracking();
            
            // Load global settings FIRST, before auth
            loadGlobalSettings();
            
            checkAuth();
            
            // Add event listener for clear winners button
            document.getElementById('clearWinnersBtn')?.addEventListener('click', clearWinnersHistory);
            
            
            const usernameBtn = document.getElementById('username');
            const ownerDropdown = document.getElementById('ownerSettingsDropdown');
            const channelSettingsBtn = document.getElementById('channelSettingsBtn');
            const channelSettingsModal = document.getElementById('channelSettingsModal');
            const closeChannelSettingsModal = document.getElementById('closeChannelSettingsModal');
            const saveChannelSettingsBtn = document.getElementById('saveChannelSettings');
            const resetChannelSettingsBtn = document.getElementById('resetChannelSettings');
            const exportDataBtn = document.getElementById('exportDataBtn');
            const clearAllDataBtn = document.getElementById('clearAllDataBtn');
            
            // User management elements
            const userManagementBtn = document.getElementById('userManagementBtn');
            const userManagementModal = document.getElementById('userManagementModal');
            const closeUserManagementModal = document.getElementById('closeUserManagementModal');
            
            // Tab elements
            const usersTab = document.getElementById('usersTab');
            const streamersTab = document.getElementById('streamersTab');
            const notificationsTab = document.getElementById('notificationsTab');
            
            const usersContent = document.getElementById('usersContent');
            const streamersContent = document.getElementById('streamersContent');
            const notificationsContent = document.getElementById('notificationsContent');
            
            // Search and filter elements
            const userSearch = document.getElementById('userSearch');
            const userSortBy = document.getElementById('userSortBy');
            const userFilterStatus = document.getElementById('userFilterStatus');
            
            const streamerSearch = document.getElementById('streamerSearch');
            const streamerSortBy = document.getElementById('streamerSortBy');
            const streamerFilterActivity = document.getElementById('streamerFilterActivity');
            
            const exportLogBtn = document.getElementById('exportLogBtn');
            
            // Username click handler
            usernameBtn?.addEventListener('click', (e) => {
                e.stopPropagation();
                if (isby_CTPAX) {
                    if (ownerDropdown.classList.contains('hidden')) {
                        // Create a new high-level container for dropdown
                        let dropdownContainer = document.getElementById('dropdown-container');
                        if (!dropdownContainer) {
                            dropdownContainer = document.createElement('div');
                            dropdownContainer.id = 'dropdown-container';
                            dropdownContainer.className = 'owner-dropdown-container';
                            dropdownContainer.style.cssText = `
                                position: fixed !important;
                                top: 0 !important;
                                left: 0 !important;
                                width: 100vw !important;
                                height: 100vh !important;
                                z-index: 100000 !important;
                                pointer-events: none !important;
                            `;
                            document.body.appendChild(dropdownContainer);
                        }
                        
                        // Position dropdown relative to button
                        const rect = usernameBtn.getBoundingClientRect();
                        
                        // Remove dropdown from current position and add to container
                        ownerDropdown.remove();
                        dropdownContainer.appendChild(ownerDropdown);
                        
                        // Position and show dropdown
                        ownerDropdown.style.cssText = `
                            position: absolute !important;
                            top: ${rect.bottom + 8}px !important;
                            right: ${window.innerWidth - rect.right}px !important;
                            left: auto !important;
                            z-index: 100001 !important;
                            background: rgba(31, 41, 55, 0.98) !important;
                            backdrop-filter: blur(15px) !important;
                            border: 2px solid rgba(147, 51, 234, 0.8) !important;
                            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(147, 51, 234, 0.5) !important;
                            border-radius: 0.5rem !important;
                            min-width: 12rem !important;
                            pointer-events: auto !important;
                        `;
                        ownerDropdown.classList.remove('hidden');
                    } else {
                        ownerDropdown.classList.add('hidden');
                        // Clean up container
                        const dropdownContainer = document.getElementById('dropdown-container');
                        if (dropdownContainer) {
                            dropdownContainer.remove();
                        }
                    }
                }
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!usernameBtn?.contains(e.target) && !ownerDropdown?.contains(e.target)) {
                    ownerDropdown?.classList.add('hidden');
                    // Clean up container
                    const dropdownContainer = document.getElementById('dropdown-container');
                    if (dropdownContainer) {
                        dropdownContainer.remove();
                    }
                }
            });
            
            // Channel settings modal handlers
            channelSettingsBtn?.addEventListener('click', () => {
                ownerDropdown?.classList.add('hidden');
                // Clean up dropdown container
                const dropdownContainer = document.getElementById('dropdown-container');
                if (dropdownContainer) {
                    dropdownContainer.remove();
                }
                
                console.log('Открытие модала настроек канала');
                channelSettingsModal?.classList.remove('hidden');
                
                // Ensure settings are loaded and applied
                setTimeout(() => {
                    console.log('Применение настроек к модалу:', channelSettings);
                    loadChannelSettings(); // Reload from localStorage
                    applyChannelSettingsToUI();
                    updateChannelStatistics();
                }, 50);
            });
            
            closeChannelSettingsModal?.addEventListener('click', () => {
                channelSettingsModal?.classList.add('hidden');
            });
            
            // Settings buttons
            saveChannelSettingsBtn?.addEventListener('click', () => {
                console.log('Кнопка сохранения настроек нажата');
                collectChannelSettingsFromUI();
                saveChannelSettings();
            });
            
            // Auto-save settings when they change
            const settingsInputs = [
                'autoAnnounce', 'soundNotifications', 'responseTimeout', 
                'autoModeration', 'timeoutDuration', 'bannedWords', 
                'maxParticipants', 'minFollowDays', 'followersOnly'
            ];
            
            settingsInputs.forEach(inputId => {
                const element = document.getElementById(inputId);
                if (element) {
                    const eventType = element.type === 'checkbox' ? 'change' : 'input';
                    element.addEventListener(eventType, () => {
                        if (isby_CTPAX) {
                            console.log(`Настройка ${inputId} изменена, автосохранение...`);
                            setTimeout(() => {
                                collectChannelSettingsFromUI();
                                saveChannelSettings();
                            }, 100);
                        }
                    });
                }
            });
            
            resetChannelSettingsBtn?.addEventListener('click', () => {
                if (confirm('Сбросить настройки к значениям по умолчанию?')) {
                    console.log('Сброс настроек к умолчанию');
                    channelSettings = {
                        autoAnnounce: true,
                        soundNotifications: false,
                        responseTimeout: 60,
                        autoModeration: false,
                        timeoutDuration: 10,
                        bannedWords: [],
                        maxParticipants: 1000,
                        minFollowDays: 0,
                        followersOnly: false
                    };
                    
                    // Apply to UI and save
                    setTimeout(() => {
                        applyChannelSettingsToUI();
                        saveChannelSettings();
                        updateTimeoutDuration();
                        updateResponseTimeout();
                        showNotification('Настройки сброшены и сохранены!', 'success');
                    }, 100);
                }
            });
            
            exportDataBtn?.addEventListener('click', exportChannelData);
            clearAllDataBtn?.addEventListener('click', clearAllChannelData);
            
            // User management handlers
            userManagementBtn?.addEventListener('click', () => {
                ownerDropdown?.classList.add('hidden');
                // Clean up dropdown container
                const dropdownContainer = document.getElementById('dropdown-container');
                if (dropdownContainer) {
                    dropdownContainer.remove();
                }
                
                if (isby_CTPAX) {
                    initializeUserManagementData();
                    userManagementModal?.classList.remove('hidden');
                    
                    // Apply saved settings after a short delay
                    setTimeout(() => {
                        applyUserManagementSettingsToUI();
                        renderUsersTable();
                        updateStreamerStatistics();
                        renderAuthorizationLog();
                        
                        // Проверяем статус стримеров
                        checkStreamersStatus();
                        
                        // Загружаем и синхронизируем пользователей из visitors.json при открытии модального окна
                        if (USE_SERVER) {
                            // Загружаем всех пользователей из visitors.json
                            loadUsersFromVisitors().then(() => {
                                // Затем синхронизируем IP адреса
                                syncUserIPsFromServer();
                            }).catch(err => {
                                console.warn('Ошибка загрузки пользователей:', err);
                            });
                        }
                        
                        // Обновляем статус стримеров каждые 30 секунд
                        if (window.streamerCheckInterval) {
                            clearInterval(window.streamerCheckInterval);
                        }
                        window.streamerCheckInterval = setInterval(() => {
                            checkStreamersStatus();
                        }, 30000);
                    }, 100);
                }
            });
            
            closeUserManagementModal?.addEventListener('click', () => {
                // Save settings before closing
                collectUserManagementSettingsFromUI();
                saveUserManagementData();
                userManagementModal?.classList.add('hidden');
                
                // Останавливаем проверку стримеров при закрытии
                if (window.streamerCheckInterval) {
                    clearInterval(window.streamerCheckInterval);
                    window.streamerCheckInterval = null;
                }
            });
            
            // Кнопка обновления IP адресов
            const refreshUserIPsBtn = document.getElementById('refreshUserIPsBtn');
            refreshUserIPsBtn?.addEventListener('click', async () => {
                if (!USE_SERVER) {
                    showNotification('Сервер не включен. Включите USE_SERVER = true', 'error');
                    return;
                }
                
                refreshUserIPsBtn.disabled = true;
                const originalHTML = refreshUserIPsBtn.innerHTML;
                refreshUserIPsBtn.innerHTML = '<svg class="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> <span>Обновление...</span>';
                
                try {
                    // Загружаем всех пользователей из visitors.json
                    const result = await loadUsersFromVisitors();
                    
                    if (result) {
                        const { newUsersAdded, updatedUsers } = result;
                        if (newUsersAdded > 0 || updatedUsers > 0) {
                            showNotification(
                                `Обновлено: ${newUsersAdded} новых пользователей, ${updatedUsers} обновлено`, 
                                'success'
                            );
                        } else {
                            showNotification('Все данные актуальны', 'success');
                        }
                    } else {
                        // Если loadUsersFromVisitors не вернул результат, просто синхронизируем IP
                        await syncUserIPsFromServer();
                        showNotification('Данные обновлены', 'success');
                    }
                    
                    renderUsersTable();
                } catch (error) {
                    console.error('Ошибка обновления данных:', error);
                    showNotification('Ошибка обновления данных: ' + (error.message || 'Неизвестная ошибка'), 'error');
                } finally {
                    refreshUserIPsBtn.disabled = false;
                    refreshUserIPsBtn.innerHTML = originalHTML;
                }
            });
            
            // Tab switching
            usersTab?.addEventListener('click', () => {
                // Save current settings before switching
                collectUserManagementSettingsFromUI();
                userManagementSettings.activeTab = 'users';
                saveUserManagementData();
                
                // Update tab styles
                document.querySelectorAll('#userManagementModal button[id$="Tab"]').forEach(tab => {
                    tab.className = 'flex-1 px-4 py-2 rounded-lg transition-all duration-200 text-gray-300 hover:text-white hover:bg-gray-600';
                });
                usersTab.className = 'flex-1 px-4 py-2 rounded-lg transition-all duration-200 bg-blue-600 text-white';
                
                // Show/hide content
                usersContent?.classList.remove('hidden');
                streamersContent?.classList.add('hidden');
                notificationsContent?.classList.add('hidden');
                
                renderUsersTable();
                
                // Синхронизируем IP адреса при открытии вкладки пользователей
                if (USE_SERVER) {
                    syncUserIPsFromServer();
                }
            });
            
            streamersTab?.addEventListener('click', () => {
                // Save current settings before switching
                collectUserManagementSettingsFromUI();
                userManagementSettings.activeTab = 'streamers';
                saveUserManagementData();
                
                // Update tab styles
                document.querySelectorAll('#userManagementModal button[id$="Tab"]').forEach(tab => {
                    tab.className = 'flex-1 px-4 py-2 rounded-lg transition-all duration-200 text-gray-300 hover:text-white hover:bg-gray-600';
                });
                streamersTab.className = 'flex-1 px-4 py-2 rounded-lg transition-all duration-200 bg-blue-600 text-white';
                
                // Show/hide content
                usersContent?.classList.add('hidden');
                streamersContent?.classList.remove('hidden');
                notificationsContent?.classList.add('hidden');
                
                renderStreamersTable();
                updateStreamerStatistics();
            });
            
            notificationsTab?.addEventListener('click', () => {
                // Save current settings before switching
                collectUserManagementSettingsFromUI();
                userManagementSettings.activeTab = 'notifications';
                saveUserManagementData();
                
                // Update tab styles
                document.querySelectorAll('#userManagementModal button[id$="Tab"]').forEach(tab => {
                    tab.className = 'flex-1 px-4 py-2 rounded-lg transition-all duration-200 text-gray-300 hover:text-white hover:bg-gray-600';
                });
                notificationsTab.className = 'flex-1 px-4 py-2 rounded-lg transition-all duration-200 bg-blue-600 text-white';
                
                // Show/hide content
                usersContent?.classList.add('hidden');
                streamersContent?.classList.add('hidden');
                notificationsContent?.classList.remove('hidden');
                
                renderAuthorizationLog();
            });
            
            // Search and filter handlers with auto-save
            userSearch?.addEventListener('input', () => {
                userManagementSettings.userSearch = userSearch.value;
                saveUserManagementData();
                renderUsersTable();
            });
            userSortBy?.addEventListener('change', () => {
                userManagementSettings.userSortBy = userSortBy.value;
                saveUserManagementData();
                renderUsersTable();
            });
            userFilterStatus?.addEventListener('change', () => {
                userManagementSettings.userFilterStatus = userFilterStatus.value;
                saveUserManagementData();
                renderUsersTable();
            });
            
            streamerSearch?.addEventListener('input', () => {
                userManagementSettings.streamerSearch = streamerSearch.value;
                saveUserManagementData();
                renderStreamersTable();
            });
            streamerSortBy?.addEventListener('change', () => {
                userManagementSettings.streamerSortBy = streamerSortBy.value;
                saveUserManagementData();
                renderStreamersTable();
            });
            streamerFilterActivity?.addEventListener('change', () => {
                userManagementSettings.streamerFilterActivity = streamerFilterActivity.value;
                saveUserManagementData();
                renderStreamersTable();
            });
            
            // Date filter handlers with auto-save
            document.getElementById('logStartDate')?.addEventListener('change', () => {
                userManagementSettings.logStartDate = document.getElementById('logStartDate').value;
                saveUserManagementData();
                renderAuthorizationLog();
            });
            document.getElementById('logEndDate')?.addEventListener('change', () => {
                userManagementSettings.logEndDate = document.getElementById('logEndDate').value;
                saveUserManagementData();
                renderAuthorizationLog();
            });
            
            // Notification settings auto-save
            // Обработчики настроек уведомлений удалены
            
            // Export log handler
            exportLogBtn?.addEventListener('click', exportAuthorizationLog);
            
            // Global Settings Modal Handlers
            const globalSettingsBtn = document.getElementById('globalSettingsBtn');
            const globalSettingsModal = document.getElementById('globalSettingsModal');
            const closeGlobalSettingsModal = document.getElementById('closeGlobalSettingsModal');
            const saveGlobalSettingsBtn = document.getElementById('saveGlobalSettings');
            const resetGlobalSettingsBtn = document.getElementById('resetGlobalSettings');
            const clearGiveawayHistoryBtn = document.getElementById('clearGiveawayHistory');
            const deleteAccountBtn = document.getElementById('deleteAccountBtn');
            const reportBugBtn = document.getElementById('reportBugBtn');
            
            // Language buttons
            const langEN = document.getElementById('langEN');
            const langRU = document.getElementById('langRU');
            const langUA = document.getElementById('langUA');
            function applyGlobalSettingsToUI() {
    // Получить сохраненные настройки
    const settings = JSON.parse(localStorage.getItem('by_CTPAX_settings') || '{}');
    
    // Применить тему
    if (settings.theme) {
        document.body.className = settings.theme;
    }
    
    // Применить другие настройки, если они есть
    if (settings.fontSize) {
        document.documentElement.style.fontSize = settings.fontSize + 'px';
    }
    
    // Заполнить поля формы текущими значениями
    const inputs = globalSettingsModal?.querySelectorAll('input, select, textarea');
    inputs?.forEach(input => {
        const key = input.name || input.id;
        if (settings[key]) {
            input.value = settings[key];
        }
    });
}
            
            // Open global settings modal
            globalSettingsBtn?.addEventListener('click', () => {
                globalSettingsModal?.classList.remove('hidden');
                applyGlobalSettingsToUI();
            });
            
            // Close global settings modal
            closeGlobalSettingsModal?.addEventListener('click', () => {
                globalSettingsModal?.classList.add('hidden');
            });
            
            // Save global settings
            saveGlobalSettingsBtn?.addEventListener('click', () => {
                collectGlobalSettingsFromUI();
                saveGlobalSettings();
            });
            
            // Reset global settings
            resetGlobalSettingsBtn?.addEventListener('click', () => {
                if (confirm('Сбросить все настройки к значениям по умолчанию?')) {
                    globalSettings = {
                        hideUsernames: false,
                        hideAvatars: false,
                        language: 'ru',
                        hideMyUsername: false,
                        disableStatistics: false,
                        registrationDate: globalSettings.registrationDate || '2025-07-06'
                    };
                    applyGlobalSettingsToUI();
                    saveGlobalSettings();
                    showNotification('Настройки сброшены!', 'success');
                }
            });
            
            // Language selection
            langEN?.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('Переключение на английский язык');
                globalSettings.language = 'en';
                
                // Сразу обновляем UI
                updateLanguageButtons('en');
                applyLanguageToInterface();
                
                // Сохраняем настройки
                saveGlobalSettings();
                showNotification(t('languageChanged') + ' - English', 'success');
            });
            
            langRU?.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('Переключение на русский язык');
                globalSettings.language = 'ru';
                
                // Сразу обновляем UI
                updateLanguageButtons('ru');
                applyLanguageToInterface();
                
                // Сохраняем настройки
                saveGlobalSettings();
                showNotification(t('languageChanged') + ' - Русский', 'success');
            });
            
            langUA?.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('Переключение на украинский язык');
                globalSettings.language = 'ua';
                
                // Сразу обновляем UI
                updateLanguageButtons('ua');
                applyLanguageToInterface();
                
                // Сохраняем настройки
                saveGlobalSettings();
                showNotification(t('languageChanged') + ' - Українська', 'success');
            });
            
            // Auto-save settings when they change
            const globalSettingsInputs = [
                'hideUsernames', 'hideAvatars', 'hideMyUsername', 'disableStatistics'
            ];
            
            globalSettingsInputs.forEach(inputId => {
                const element = document.getElementById(inputId);
                if (element) {
                    element.addEventListener('change', () => {
                        setTimeout(() => {
                            collectGlobalSettingsFromUI();
                            saveGlobalSettings();
                            // Применяем настройки к чату сразу после изменения
                            if (typeof applyGlobalSettingsToChat === 'function') {
                                applyGlobalSettingsToChat();
                            }
                            console.log('Настройки сохранены и применены:', globalSettings);
                        }, 100);
                    });
                }
            });
            
            // Action buttons
            clearGiveawayHistoryBtn?.addEventListener('click', clearGiveawayHistory);
            deleteAccountBtn?.addEventListener('click', deleteAccount);
            reportBugBtn?.addEventListener('click', reportBugOrIdea);
        });

        // Save data before page unload
        window.addEventListener('beforeunload', () => {
            if (twitchChannel) {
                saveData();
            }
        });
    </script>
</body>
</html>
</body>
</html>